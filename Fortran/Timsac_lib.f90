



 !
 !          Author:  
 !                       ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
 !                       ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
 !                          TOKYO
 !                       ** DATE OF THE LATEST REVISION: MARCH 25, 1977
 !                       ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
 !                          "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(2
 !                          BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
 !                          NO.6 MARCH 1976, THE INSTITUTE OF STATISTICAL MATHEMATICS
 !
 !          Copyright notice:
 !                              
 !                               
!C*                             Timsac : Time Series Analysis and ControlProgram Package
!C*                             Copyright (C) 2005    The Institute of Statistical Mathematics
!C*
!C*                             This program is free software; you can redistribute it and/or modify
!C*                             it under the terms of the GNU General Public License as published by
!C!*                            the Free Software Foundation; either version 2 of the License, or
!C*                             (at your option) any later version.
!C*
!C*                             This program is distributed in the hope that it will be useful,
!C*                             but WITHOUT ANY WARRANTY; without even the implied warranty of
!C*                             MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!C*                             GNU General Public License for more details.
!C*
!C*                             You should have received a copy of the GNU General Public License
!C*                             along with this program; if not, write to the Free Software
!C*                             Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
!C*
!C*
!C*                            ismrp at jasp.ism.ac.jp
!C

                              
 
  
    SUBROUTINE AUSPECF(N,LAGH1,CXX1,P1,P2,Q) !GCC$ ATTRIBUTES HOT :: AUSPECF !GCC$ ATTRIBUTES ALIGNED(32) :: AUSPECF

         use omp_lib
     
!C
!C     PROGRAM 5.2.1   POWER SPECTRUM
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C        TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C        "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C        ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C        T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES POWER SPECTRUM ESTIMATES FOR TWO
!C     TRIGONOMETRIC WINDOWS OF BLACKMAN-TUKEY TYPE BY GOERTZEL METHOD.
!C     ONLY ONE CARD OF LAGH(MAXIMUM LAG OF COVARIANCES TO BE USED FOR
!C     POWER SPECTRUM COMPUTATION) SHOULD BE ADDED ON TOP OF THE OUTPUT
!C     OF PROGRAM 5.1.1 AUTCOR TO FORM INPUT TO THIS PROGRAM.
!C     OUTPUTS ARE ESTIMATES P1(I),P2(I) FOR FREQUENCIES I/(2LAGH*DELTAT)
!C     AND THE TEST STATISTICS Q(I) FOR THE DIFFERENCES BETWEEN P1(I) AND
!C     P2(I).   Q(I) GREATER THAN 1 MEANS SIGNIFICANT DIFFERENCE.
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: AUSPECF
!c      USE DFLIB
!C
!cxx      IMPLICIT REAL*8(A-H,O-Z)
!c      DIMENSION CXX(1001),FC(1001),P1(1001),P2(1001),Q(1001)
!c      DIMENSION A1(10),A2(10)
!cxx      DIMENSION CXX1(LAGH1),CXX(LAGH1)
!cxx      DIMENSION FC(LAGH1),P1(LAGH1),P2(LAGH1),Q(LAGH1)
!cxx      DIMENSION A1(2),A2(3)
          INTEGER(kind=4) :: N, LAGH1
          REAL(kind=8), dimension(LAGH1) :: CXX1, P1, P2, Q
          REAL(kind=8), dimension(LAGH1) :: CXX, FC
#if defined __ICC
!DIR$     ASSUME_ALIGNED CXX1:64, P1:64, P2:64, Q:64
!DIR$     ATTRIBUTES ALIGN : 64 :: CXX,FC
#endif
          REAL(kind=8), dimension(2)  :: A1 
          REAL(kind=8), dimension(3)  :: A2
      ! Locals
          INTEGER(kind=4) :: MLA1,MLA2,I
          ! Exec code ....
!C
!C     INPUT / OUTPUT DATA FILE OPEN
!c	CHARACTER(100) DFNAM
!c	DFNAM='auspec.out'
!c	CALL SETWND
!c	CALL FLOPN3(DFNAM,NFL)
!c	IF (NFL.EQ.0) GO TO 999
!C
!C     WINDOW W1 DEFINITION
          MLA1=2
          A1(1)=0.5_8
          A1(2)=0.25_8
!C     WINDOW W2 DEFINITION
          MLA2=3
          A2(1)=0.625_8
          A2(2)=0.25_8
          A2(3)=-0.0625_8
!C
!C     LAGH SPECIFICATION
!c      READ(5,1) LAGH
!c      LAGH1=LAGH+1
!C     READING THE OUTPUTS OF PROGRAM 5.1.1 AUTCOR
!c      READ(5,1) N,LAGH0
!c      LAGH3=LAGH0+1
!C     INITIAL CONDITION PRINT OUT
!c      WRITE(6,60)
!c      WRITE(6,61)
!c      WRITE(6,62) N,LAGH
!c      WRITE(6,63)
!c      CALL PRCOL1(A1,1,MLA1,1)
!c      WRITE(6,64)
!c      CALL PRCOL1(A2,1,MLA2,1)
!C     AUTO COVARIANCE INPUT
!c      READ(5,2) (CXX(I),I=1,LAGH3)
!C     AUTO COVARIANCE PRINT OUT
!c      WRITE(6,172)
!c      WRITE(6,162)
!c      CALL PRCOL1(CXX,1,LAGH1,1)
!c      DO 10 I=2,LAGH
!c   10 CXX(I)=CXX(I)+CXX(I)
           CXX(1)=CXX1(1)
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__ 
!$OMP SIMD LINEAR(i:1)
#endif
           DO 10 I=2,LAGH1-1
!cxx   10 CXX(I)=CXX1(I)+CXX1(I)
                 CXX(I)=CXX1(I)+CXX1(I)
        10 CONTINUE
           CXX(LAGH1)=CXX1(LAGH1)
!C     F-COS TRANSFORMATION
           CALL FGERCO(CXX,LAGH1,FC,LAGH1)
!C     SPECTRUM SMOOTHING BY WINDOW W1
           CALL AUSP(FC,P1,LAGH1,A1,MLA1)
!C     SPECTRUM SMOOTHING BY WINDOW W2
           CALL AUSP(FC,P2,LAGH1,A2,MLA2)
!C     TEST STATISTICS COMPUTATION
           CALL SIGNIF(P1,P2,Q,LAGH1,N)
!C     AUTO SPECTRUM AND TEST STATISTICS PRINT OUT
!c      WRITE(6,66) N,LAGH
!c      WRITE(6,67)
!c      CALL PRCOL3(P1,P2,Q,1,LAGH1,1)
!C     AUTO SPECTRUM SMOOTHED BY WINDOW W1 PUNCH OUT
!c      WRITE(7,1) N,LAGH
!c      WRITE(7,2) (P1(I),I=1,LAGH1)
!c	CALL FLCLS3(NFL)
!c    1 FORMAT(10I5)
!c    2 FORMAT(4D20.10)
!c   60 FORMAT(1H ,30HPROGRAM 5.2.1   POWER SPECTRUM)
!c   62 FORMAT(1H ,2HN=,I5,5X,5HLAGH=,I5)
!c   61 FORMAT(1H ,17HINITIAL CONDITION)
!c   63 FORMAT(1H ,12X,9HWINDOW W1/1H ,4X,1HI,11X,5HA1(I))
!c   64 FORMAT(1H ,12X,9HWINDOW W2/1H ,4X,1HI,11X,5HA2(I))
!c   66 FORMAT(//1H ,14HPOWER SPECTRUM,5X,2HN=,I5,5X,5HLAGH=,I5)
!c   67 FORMAT(1H ,4X,1HI,8X,8HPOWER W1,6X,8HPOWER W2,2X,12HSIGNIFICANCE)
!c  162 FORMAT(1H ,4X,1HI,6X,6HCXX(I))
!c  172 FORMAT(1H ,5X,15HAUTO COVARIANCE)
    
    END SUBROUTINE
    
    SUBROUTINE AUTARMF( N,LAGH01,CYY1,NEWL1,IQI1,B1,IPI1,A1,                    &
                        NEWN,IQ,B2,IP,A2,STD,CXX2,G,SAIC,AICM,KQ,KP,           &
                        LMAX,MMAX,NMAX                                   )
       use omp_lib      
        
!C
!cc      PROGRAM AUTARM
!C     PROGRAM 74.1.2. AUTOMATIC AR-MA MODEL FITTING; SCALAR CASE.
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C        TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C        "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(1
!C        BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C        NO.5, MARCH 1975, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** FOR THE BASIC THEORY SEE "CANONICAL CORRELATION ANALYSIS OF TIM
!C        AND THE USE OF AN INFORMATION CRITERION" BY H. AKAIKE, IN
!C        "SYSTEM IDENTIFICATION: ADVANCES AND CASE STUDIES" R. K. MEHRA
!C        D. G. LAINIOTIS EDS. ACADEMIC PRESS, NEW YORK, 1976
!C-----------------------------------------------------------------------
!C     THIS PROGRAM PROVIDES AN AUTOMATIC AR-MA MODEL FITTING PROCEDURE.
!C     MODELS WITH VARIOUS ORDERS ARE FITTED AND THE BEST CHOICE IS DETER
!C     WITH THE AID OF THE STATISTICS AIC.
!C     THE MAXIMUM LIKELIHOOD ESTIMATES OF THE COEFFICIENTS OF A SCALAR
!C     AUTOREGRESSIVE MOVING AVERAGE MODEL Y(I)+B(1)Y(I-1)+...+B(IQ)Y(I-I
!C     =X(I)+A(1)X(I-1)+...+A(IP)X(I-IP) OF A TIME SERIES Y(I)
!C     ARE OBTAINED BY USING DAVIDON'S VARIANCE ALGORITHM.
!C     PURE AUTOREGRESSION IS NOT ALLOWED.
!C     FOR AR-MODELS USE THE INTERMEDIATE OUTPUTS OF CANARM.
!C
!C     THIS PROGRAM REQUIRES THE FOLLWING INPUTS:
!C     (N,LAGH): N, LENGTH OF THE ORIGINAL DATA
!C                  LAGH, MAXIMUM LAG OF COVARIANCE, NOT GREATER THAN 500
!C     CYY(I) (I=0,LAGH): COVARIANCE SEQUENCE ... LAGH SHOULD BE LARGE EN
!C                             TO KEEP THE INNOVATION VARIANCE AND
!C                             GRADIENT COMPUTATION MEANINGFUL.
!C     ***** WHEN N IS NOT GREATER THAN 501, PUT LAGH EQUAL TO N-1.
!C     NEWL: TOTAL NUMBER OF CASES, NOT GREATER THAN 25
!C     IQ: INITIAL AR ORDER
!C     B(I)(I=1,IQ): INITIAL ESTIMATES OF AR-COEFFICIENTS
!C     IP: INITIAL MA ORDER
!C     A(I)(I=1,IP): INITIAL ESTIMATES OF MA-COEFFICIENTS
!C     (IQI(I),IPI(I))(I=1,NEWL-1): (AR,MA) ORDERS TO BE FITTED SUCCESSIV
!C                                       UNNECESSARY WHEN NEWL=1
!C     ***** WHEN THE BEST CHOICE IS ON THE BORDER, SOME (AR,MA) ORDERS A
!C              AUTOMATICALLY WITHIN THE LIMIT OF THE TOTAL NUMBER 25.
!C
!C     OUTPUTS: FOR EACH PAIR OF AR-MA ORDERS
!C     ONE CARD WITH THE STATEMENTS OF THE PROBLEM
!C     IQ: AR ORDER
!C     B(I)(I=1,IQ): MAXIMUM LIKELIHOOD ESTIMATES OF AR COEFFICIENTS
!C     IP: MA ORDER
!C     A(I)(I=1,IP): MAXIMUM LIKELIHOOD ESTIMATES OF MA COEFFICIENTS
!C     CXX0: INNOVATION VARIANCE
!C

          INTEGER(kind=4), parameter :: ICST = 190_I32P
          INTEGER(kind=4) :: N, LAGH01, NEWL1,NEWN,KQ,KP,LMAX,MMAX,NMAX 
          INTEGER(kind=4), dimension(NEWL1) :: IQI1, IPI1
          INTEGER(kind=4), dimension(NMAX)  :: IQ, IP
          REAL(kind=8), dimension(LAGH01) :: CYY1 
          REAL(kind=8), dimension(IPI1(1)) :: A1 
          REAL(kind=8), dimension(IQI1(1)) :: B1 
          REAL(kind=8), dimension(MMAX,NMAX) :: A2,B2,STD,G
          REAL(kind=8), dimension(NMAX) :: CXX2,SAIC
          REAL(kind=8) :: AICM 
#if defined __ICC
!DIR$  ASSUME_ALIGNED  IQI1:64, IPI1:64
!DIR$  ASSUME_ALIGNED  IQ:64, IP:64
!DIR$  ASSUME_ALIGNED  CYY1:64, A1:64, B1:64
!DIR$  ASSUME_ALIGNED  A2:64, B2:64, STD:64, G:64
!DIR$  ASSUME_ALIGNED  CXX2:64, SAIC:64   
#endif       
          INTEGER(kind=4), dimension(NMAX) :: IQI, IPI, IPO, IQO
#if defined __ICC
!DIR$  ATTRIBUTES ALIGN : 64 :: IQI,IPI,IPO,IQO
#endif
          REAL(kind=8), dimension(LMAX*2+1) :: CYY
#if defined __ICC
!DIR$  ATTRIBUTES ALIGN : 64 :: CYY
#endif
          REAL(kind=8), dimension(MMAX) :: A,B,OA,OB,X,C
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: A,B,OA,OB,X
#endif
          REAL(kind=8), dimension(ICST) ::  CC
 #if defined __ICC         
!DIR$ ATTRIBUTES ALIGN : 64 :: CC
#endif
          REAL(kind=8), dimension(MMAX,MMAX) :: VD
 #if defined __ICC         
!DIR$ ATTRIBUTES ALIGN : 64 :: VD
#endif
          REAL(kind=8), dimension(MMAX+1) ::  CN 
#if defined __ICC          
!DIR$ ATTRIBUTES ALIGN : 64 :: CN
#endif 
          REAL(kind=8), dimension(NMAX) :: SMAIC2
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: SMAIC2
#endif
          REAL(kind=8)    ::            CST0, CST1, CST2, CST05, SMAIC, AN, CXX0, SUM,    &
                                      AIPQ, DMAIC, CONST1, SAN, SMAIC, 
          INTEGER(kind=4) :: LAGH4,I,LAGH1,LAGH2,IIM,IIP,JQO,JPO,NEWL,JP,JQ,  &
                           NEWLM1,IDOS,ISIK,ISWRO,II,IPQ,J,ISFIN,IG,IQM1,IPM1, &
                           IDO,IDE
        
          COMMON /COM70/ISWRO
          COMMON /COM71/IDOS
          COMMON /COM72/ISIK

      CST0=0.0_8
      CST1=1.0_8
      CST2=2.0_8
      CST05=0.00005_8
      !c!c      DO 8 I=1,1001
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 8 I=1,2*LMAX+1
!cxx    8 CYY(I)=CST0
      CYY(I)=CST0
    8 CONTINUE
!cc	LAGH4=501
!cc	LAGH1=500
      LAGH4=LMAX+1
      LAGH1=LMAX
!C     AUTOCOVARIANCE LOADING
!cc	READ(5,1) N,LAGH
      LAGH=LAGH01-1
      LAGH2=LAGH4+LAGH
      !cc	READ(5,2) (CYY(I),I=LAGH4,LAGH2)
      ! SCatter instruction in use?
#if defined __ICC
      !DIR$      VECTOR ALIGNED
      !DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 88 I=1,LAGH01
      CYY(LMAX+I)=CYY1(I)
88    CONTINUE
#if defined __ICC
      !DIR$      VECTOR ALIGNED
      !DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 9 I=1,LAGH1
      IIM=LAGH4-I
      IIP=LAGH4+I
!cxx    9 CYY(IIM)=CYY(IIP)
      CYY(IIM)=CYY(IIP)
    9 CONTINUE
      AN=N
      SMAIC=AN*DLOG(CYY(LAGH4))
!cc      IQO=0
!cc      IPO=0
      JQO=0
      JPO=0
!cc 3200 READ(5,1) NEWL
      NEWL=NEWL1
      NEWN=1
!C     INITIAL CONDITION LOADING FOR AR-MA (IQ,IP)
!cc 2000 READ(5,1) IQ
      JQ=IQI1(1)
      JP=IPI1(1)
!cc      IF(IQ.LE.0) GO TO 4205
      IF(JQ.LE.0) GO TO 4205
      !cc      READ(5,2) (B(I),I=1,IQ)
#if defined __ICC
      !DIR$      VECTOR ALIGNED
      !DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 10 I=1,JQ
         B(I)=B1(I)
   10 CONTINUE
!cc 4205 READ(5,1) IP
 4205 CONTINUE
!cc      IF(IP.LE.0) GO TO 4204
      IF(JP.LE.0) GO TO 4204
      !cc      READ(5,2) (A(I),I=1,IP)
#if defined __ICC
      !DIR$      VECTOR ALIGNED
      !DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 20 I = 1,JP
         A(I)=A1(I)
   20 CONTINUE

 4204 NEWLM1=NEWL-1
!cc      IQI(1)=IQ
!cc      IPI(1)=IP
      IQI(1)=JQ
      IPI(1)=JP
      IF(NEWLM1.EQ.0) GO TO 4208
#if defined __ICC
      !DIR$      VECTOR ALIGNED
      !DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 4206 I=2,NEWL
!cc 4206 READ(5,1) IQI(I),IPI(I)
      IQI(I)=IQI1(I)
!cxx 4206 IPI(I)=IPI1(I)
      IPI(I)=IPI1(I)
 4206 CONTINUE
 4208 IDOS=3
      ISIK=0
 4207 CONTINUE
      ISWRO=0
!C     INITIAL PRINT OUT
!cc      WRITE (6,11111)
!cx      IF (IFG.NE.0) WRITE(LU,11111)
!cc	WRITE(6,1600)
!cc	WRITE(6,1601)
!cc	WRITE(6,1610) N,LAGH,IQ,IP
!cc 4210 IPQ=IP+IQ
 4210 IPQ=JP+JQ
      AIPQ=IPQ
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 100 I=1,JP

      X(I)=A(I)
  100 CONTINUE
!cc      IF(IQ.LE.0) GO TO 420
!cc	DO 110 I=1,IQ
!cc	II=IP+I
      IF(JQ.LE.0) GO TO 420
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif    
      DO 110 I=1,JQ
      II=JP+I
!cxx  110 X(II)=B(I)
      X(II)=B(I)
  110 CONTINUE
  420 CONTINUE
!C     INNOVATION VARIANCE, GRADIENT AND HESSIAN COMPUTATION
!cc	CALL SC0GRH(X,CYY,G,CN,CXX0,IP,IQ)
!cxx      CALL SC0GRH(X,CYY,G(1,NEWN),CN,CXX0,JP,JQ,VD,MMAX,LMAX,ICST,
!cxx     *                   IFG,LU)
      CALL SC0GRH(X,CYY,G(1,NEWN),CN,CXX0,JP,JQ,VD,MMAX,LMAX,ICST)
!C     INVERSE OF HESSIAN COMPUTATION
!C     COMMON SUBROUTINE CALL
!cc	CALL MATINV(HESDET,IPQ)
!cxx      CALL MATINV(IPQ,VD,MMAX,0,LU)
      CALL MATINV(IPQ,VD,MMAX)
!C     CORRECTION TERM C(X)=V*G(X) COMPUTATION
      DO 900 I=1,IPQ
         SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)    
#elif defined __GFORTRAN__ 
!$OMP SIMD REDUCTION(+:SUM) LINEAR(J:1)
#endif     
      DO 910 J=1,IPQ
!cc  910 SUM=SUM+VD(I,J)*G(J)
!cxx  910 SUM=SUM+VD(I,J)*G(J,NEWN)
      SUM=SUM+VD(I,J)*G(J,NEWN)
  910 CONTINUE
!cxx  900 C(I)=SUM
      C(I)=SUM
  900 CONTINUE
!C     DAVODON'S PROCEDURE; MINIMIZATION OF INNOVATION VARIANCE
!cc	CALL SDAV1(X,CYY,CXX0,G,C,IP,IQ,N)
!cxx      CALL SDAV1(X,CYY,CXX0,G(1,NEWN),C,JP,JQ,N,VD,MMAX,LMAX,ICST,
!cxx     *                IFG,LU)
      CALL SDAV1(X,CYY,CXX0,G(1,NEWN),C,JP,JQ,N,VD,MMAX,LMAX,ICST)
      IF(ISWRO.LE.0) GO TO 940
      ISFIN=0
      IF(ISWRO.GE.10) GO TO 940
!cc	DO 902 I=1,IP
!cc	IF(DABS(A(I)-X(I)).GE.CST05) GO TO 904
      DO 902 I=1,JP
      IF(DABS(A(I)-X(I)).GE.CST05) GO TO 904
  902 CONTINUE
!cc	IF(IQ.LE.0) GO TO 919
!cc	DO 903 I=1,IQ
!cc	II=IP+I
!cc	IF(DABS(B(I)-X(II)).GE.CST05) GO TO 904
      IF(JQ.LE.0) GO TO 919
      DO 903 I=1,JQ
      II=JP+I
      IF(DABS(B(I)-X(II)).GE.CST05) GO TO 904
  903 CONTINUE
      GO TO 919
  904 ISFIN=1
!cc  919 DO 920 I=1,IP
!cc  920 A(I)=X(I)
!cc	IF(IQ.LE.0) GO TO 925
!cc	DO 930 I=1,IQ
!cc	II=IP+I
      !cc  930 B(I)=X(II)
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN_    
!$OMP SIMD LINEAR(I:1)
#endif
  919 DO 920 I=1,JP
!cxx  920 A(I)=X(I)
      A(I)=X(I)
  920 CONTINUE
      IF(JQ.LE.0) GO TO 925
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
      DO 930 I=1,JQ
      II=JP+I
!cxx  930 B(I)=X(II)
      B(I)=X(II)
  930 CONTINUE
  925 CONTINUE
      IF(ISFIN.EQ.0) GO TO 940
!cc	WRITE(6,926)
!cx      IF (IFG.NE.0) WRITE(LU,926)
!cxx  926 FORMAT(/1H ,'HESSIAN RESET')
      GO TO 4210
  940 CONTINUE
!cc	WRITE(6,1008) CXX0
!cx      IF (IFG.NE.0) WRITE(LU,1008) CXX0
!C     HESSIAN COMPUTATION
      ISWRO=1
!cc	CALL SC0GRH(X,CYY,G,CN,CXX0,IP,IQ)
!cxx      CALL SC0GRH(X,CYY,G(1,NEWN),CN,CXX0,JP,JQ,VD,MMAX,LMAX,ICST,
!cxx     *                   IFG,LU)
      CALL SC0GRH(X,CYY,G(1,NEWN),CN,CXX0,JP,JQ,VD,MMAX,LMAX,ICST)
!cc	WRITE(6,1008) CXX0
!cx      IF (IFG.NE.0) WRITE(LU,1008) CXX0
!C     INVERSE OF HESSIAN COMPUTATION
!C     COMMON SUBROUTINE CALL
!cc	CALL MATINV(HESD2,IPQ)
!cxx      CALL MATINV(IPQ,VD,MMAX,0,LU)
      CALL MATINV(IPQ,VD,MMAX)
!C     INVERSE OF HESSIAN PRINT OUT
!cc	WRITE(6,3000)
!cc	DO 3100 I=1,IPQ
!cc 3100 WRITE(6,3110) I,(VD(I,J),J=1,IPQ)
!cx      IF (IFG.NE.0) THEN
!cx	 WRITE(LU,3000)
!cx	 DO 3100 I=1,IPQ
!cx 3100	 WRITE(LU,3110) I,(VD(I,J),J=1,IPQ)
!cx      END IF
!C     PARAMETER VARIANCE MATRIX COMPUTATION
      AN=N
      CONST1=CXX0/AN
!cxx      DO 6000 I=1,IPQ
      DO 6001 I=1,IPQ
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 6000 J=1,IPQ
!cxx 6000 VD(I,J)=CONST1*VD(I,J)
      VD(I,J)=CONST1*VD(I,J)
 6000 CONTINUE
 6001 CONTINUE
!cc	WRITE(6,6100)
!cc	DO 6200 I=1,IPQ
!cc 6200 WRITE(6,3110) I,(VD(I,J),J=1,IPQ)
!cx      IF (IFG.NE.0) THEN
!cx	 WRITE(LU,6100)
!cx	 DO 6200 I=1,IPQ
!cx 6200	 WRITE(LU,3110) I,(VD(I,J),J=1,IPQ)
      !cx      END IF
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))    
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 6400 I=1,IPQ
      IF(VD(I,I).LT.CST0) VD(I,I)=CST0
!cc 6400 STD(I)=DSQRT(VD(I,I))
!cxx 6400 STD(I,NEWN)=DSQRT(VD(I,I))
      STD(I,NEWN)=DSQRT(VD(I,I))
 6400 CONTINUE
!C     CN(I)=CXX(I)/CXX(0) I=1,50
!cc	WRITE(6,8000)
      SAN=CST2/DSQRT(AN)
!cc	WRITE(6,7999) SAN
!cc	WRITE(6,7998) (CN(I),I=2,51)
!cx      IF (IFG.NE.0) THEN
!cx	 WRITE(LU,8000) SAN
!cx	 WRITE(LU,7998) (CN(I),I=2,MMAX+1)
!cx      END IF
!cc	DO 800 I=1,IP
!cc  800 A(I)=X(I)
!cc	IF(IQ.LE.0) GO TO 820
!cc	DO 810 I=1,IQ
!cc	II=IP+I
      !cc  810 B(I)=X(II)
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8)) 
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif 
      DO 800 I=1,JP
!cxx  800 A(I)=X(I)
      A(I)=X(I)
  800 CONTINUE
      IF(JQ.LE.0) GO TO 820
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif   
      DO 810 I=1,JQ
      II=JP+I
!cxx  810 B(I)=X(II)
      B(I)=X(II)
  810 CONTINUE
  820 CONTINUE
!cc	WRITE(6,7910)
!cc	WRITE(6,1014) NEWN
!cx      IF (IFG.NE.0) WRITE(LU,1014) NEWN
!cx 1014 FORMAT(//1H ,'CASE NO.',I5)
!cc	IF(IQ.LE.0) GO TO 4290
!cc	IF(IQ(NEWN).LE.0) GO TO 4290
      IF(JQ.LE.0) GO TO 4291
!cc	WRITE(6,862)
!cc	DO 863 I=1,IQ
!cc	II=IP+I
!cc  863 WRITE(6,864) I,B(I),STD(II)
      DO 863 I=1,JQ
      II=JP+I
  863 CONTINUE
!C     INVERSE OF AR(B) COMPUTATION
      IG=0
!cc	CALL INVERS(B,IQ,A,0,CC,IB,IG)
!cx      CALL INVERS(B,JQ,A,0,CC,IB,IG,IFG,LU)
!cxx      CALL INVERS(B,JQ,A,0,CC,IB,ICST,IG,IFG,LU)
      CALL INVERS(B,JQ,A,0,CC,IB,ICST,IG)
!cc	WRITE(6,4289) IB
!cx      IF (IFG.NE.0) WRITE(LU,4289) IB
!cc 4290 IF(IP.LE.0) GO TO 4291
!cc	WRITE(6,865)
!cc	DO 866 I=1,IP
!cc  866 WRITE(6,864) I,A(I),STD(I)
 4291 CONTINUE
!cc	WRITE(6,1008) CXX0
      SAIC(NEWN)=AN*DLOG(CXX0)+CST2*AIPQ
!cc	WRITE(6,1001) SAIC(NEWN)
!cc 1001 FORMAT(/1H ,'AIC=N*LOG(CXX0)+2.0*(IQ+IP)=',D12.5)
!cc	WRITE(7,4) NEWN,IQ,IP,SAIC(NEWN)
!cc    4 FORMAT(/'CASE NO.',I2,1X,'AR',I2,1X,'MA',I2,2X,'AIC=',D12.5)
!cc	WRITE(7,1) IQ
!cc	IF(IQ.LE.0) GO TO 4292
!cc	WRITE(7,2) (B(I),I=1,IQ)
      IF(JQ.LE.0) GO TO 4292
      IQ(NEWN)=JQ
      DO 4200 I=1,JQ
         B2(I,NEWN)=B(I)
 4200 CONTINUE
!cc 4292 WRITE(7,1) IP
 4292 CONTINUE
!cc	IF(IP.LE.0) GO TO 1000
!cc	WRITE(7,2) (A(I),I=1,IP)
      IF(JP.LE.0) GO TO 1000
      IP(NEWN)=JP
      DO 4201 I=1,JP
         A2(I,NEWN)=A(I)
 4201 CONTINUE
!cc 1000 WRITE(7,2) CXX0
 1000 CXX2(NEWN)=CXX0
!C     FINAL GRADIENT PRINT OUT
!cc	WRITE(6,1010)
!cc 1010 FORMAT(/1H ,'FINAL GRADIENT')
!cc	WRITE(6,7998) (G(I),I=1,IPQ)
      DMAIC=SMAIC-SAIC(NEWN)
      IF(DMAIC.LT.CST0) GO TO 1013
      SMAIC=SAIC(NEWN)
!cc	IQO=IQ
!cc	IPO=IP
!cc      DO 1011 I=1,IQ
!cc 1011 OB(I)=B(I)
!cc      DO 1012 I=1,IP
!cc 1012 OA(I)=A(I)
      JQO=JQ
      JPO=JP
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))      
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 1011 I=1,JQ
!cxx 1011 OB(I)=B(I)
      OB(I)=B(I)
1011  CONTINUE
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif 
      DO 1012 I=1,JP
!cxx 1012 OA(I)=A(I)
      OA(I)=A(I)
 1012 CONTINUE
 1013 CONTINUE
      IF(NEWN.GE.NEWL)  GO TO 2100
!cc 2085 IQ1=IQ+1
!cc      IP1=IP+1
 2085 JQ1=JQ+1
      JP1=JP+1
!cc      DO 2090 I=IQ1,50
!cxx      DO 2090 I=JQ1,MMAX
!cxx 2090 B(I)=CST0
      B(JQ1:MMAX)=CST0
!cc      DO 2095 I=IP1,50
!cxx      DO 2095 I=JP1,MMAX
!cxx 2095 A(I)=CST0
      A(JP1:MMAX)=CST0
      NEWN=NEWN+1
      IDOS=0
!cc 2096 IQ=IQI(NEWN)
!cc      IF(IP.LE.IPI(NEWN)) GO TO 2976
      JQ=IQI(NEWN)
      IF(JP.LE.IPI(NEWN)) GO TO 2976
      IDOS=3
!cc 2976 IP=IPI(NEWN)
 2976 JP=IPI(NEWN)
      GO TO 4207
!cc 2100 WRITE(6,3) SMAIC,IQO,IPO
!cc    3 FORMAT(/1H ,'MINUMUM AIC =',D12.5,' ATTAINED AT THE BEST CHOICE
!cc     AAR=',I5,'  MA=',I5)
 2100 CONTINUE
      SMAIC2(NEWN)=SMAIC
      IQO(NEWN)=JQO
      IPO(NEWN)=JPO
!C     BORDER CHECK
!cc 2111 IF(NEWL.GE.25) GO TO 2120
!cc 2112 IQM1=IQO-1
!cc      IPM1=IPO-1
      IF(NEWL.GE.NMAX) GO TO 2120
      IQM1=JQO-1
      IPM1=JPO-1
      IDOS=0
      IDO=-1
!cc      IP=IPO+1
!cc      IQ=IQO+1
      JP=JPO+1
      JQ=JQO+1
      GO TO 2150
 2109 IDO=0
!cc      IP=MAX0(IPM1,1)
!cc      IQ=MAX0(IQM1,0)
!cc      IF(IPO.LE.IP) GO TO 2150
      JP=MAX0(IPM1,1)
      JQ=MAX0(IQM1,0)
      IF(JPO.LE.JP) GO TO 2150
      IDOS=3
      GO TO 2150
 2110 IDO=1
!cc      IP=IPO
!cc      IQ=MAX0(IQM1,0)
      JP=JPO
      JQ=MAX0(IQM1,0)
      GO TO 2150
 2113 IDO=2
!cc      IQ=IQO+1
      JQ=JQO+1
      GO TO 2150
 2114 IDO=3
!cc      IQ=IQO
!cc      IP=MAX0(IPM1,1)
!cc      IF(IPO.LE.IP) GO TO 2150
      JQ=JQO
      JP=MAX0(IPM1,1)
      IF(JPO.LE.JP) GO TO 2150
      IDOS=3
      GO TO 2150
 2115 IDO=4
!cc      IP=IPO+1
      JP=JPO+1
      GO TO 2150
 2116 IDO=5
!cc      IQ=MAX0(IQM1,0)
      JQ=MAX0(IQM1,0)
      GO TO 2150
 2117 IDO=6
!cc      IQ=IQO+1
!cc      IP=MAX0(IPM1,1)
!cc      IF(IPO.LE.IP) GO TO 2150
      JQ=JQO+1
      JP=MAX0(IPM1,1)
      IF(JPO.LE.JP) GO TO 2150
      IDOS=3
 2150 DO 2151 I=1,NEWL
!cc      IDE=IABS(IQI(I)-IQ)+IABS(IPI(I)-IP)
      IDE=IABS(IQI(I)-JQ)+IABS(IPI(I)-JP)
      IF(IDE.EQ.0) GO TO 2152
 2151 CONTINUE
      GO TO 2154
 2152 IDOS=0
      IF(IDO.EQ.-1) GO TO 2109
      IF(IDO.EQ.0) GO TO 2110
      IF(IDO.EQ.1) GO TO 2113
      IF(IDO.EQ.2) GO TO 2114
      IF(IDO.EQ.3) GO TO 2115
      IF(IDO.EQ.4) GO TO 2116
      IF(IDO.EQ.5) GO TO 2117

      GO TO 2120
 2154 NEWL=NEWL+1

      IQI(NEWL)=JQ
      IPI(NEWL)=JP
      JQ=JQO
      JP=JPO
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 2155 I=1,JQO

      B(I)=OB(I)
 2155 CONTINUE
      !cc      DO 2156 I=1,IPO
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif  
      DO 2156 I=1,JPO
!cxx 2156 A(I)=OA(I)
      A(I)=OA(I)
 2156 CONTINUE
      GO TO 2085
!cc 2120 CALL FLCLS3(NFL)
 2120 CONTINUE
!cxx  999 CONTINUE
      CONTINUE
      AICM=SMAIC2(NEWN)
      KQ=IQO(NEWN)
      KP=IPO(NEWN)
!cx      IF (IFG.NE.0) CLOSE(LU)
      

    END  SUBROUTINE


    SUBROUTINE SC0GRH(X,CYY,G,CN,CXX0,IP,IQ,AL,MM,LL,ICST) !GCC$ ATTRIBUTES HOT :: SC0GRH !GCC$ ATTRIBUTES ALIGNED(32) :: SC0GRH
       use omp_lib
!C     THIS SUBROUTINE COMPUTES CXX0,GRADIENT AND HESSIAN.
!cxx      IMPLICIT REAL*8(A-H,O-Z)
!cc      COMMON /COM50/AL
     

      INTEGER(kind=4)  :: IP, IQ, MM, LL, ICST
      !INTEGER(I32P) :: XG_LEN = IP+IQ
      REAL(kind=8), dimension(IP+IQ)   :: X,G 
      REAL(kind=8), dimension(LL*2+1) :: CYY
      REAL(kind=8), dimension(MM+1)   :: CN
      REAL(kind=8), dimension(MM,MM)  :: AL
      REAL(kind=8) ::            CXX0 

      REAL(kind=8), dimension(IP)   :: A
      REAL(kind=8), dimension(IQ)   :: B 
      REAL(kind=8), dimension(IP*2) :: A2 
      REAL(kind=8), dimension(ICST) :: AI,A2B, AIB
#if defined __ICC
      !DIR$ ASSUME_ALIGNED X:64,G:64
      !DIR$ ASSUME_ALIGNED CYY:64
      !DIR$ ASSUME_ALIGNED CN:64
      !DIR$ ASSUME_ALIGNED AL:64
      !DIR$ ASSUME_ALIGNED A:64
      !DIR$ ASSUME_ALIGNED B:64
      !DIR$ ASSUME_ALIGNED A2:64
      !DIR$ ASSUME_ALIGNED AI:64,A2B:64,AIB:64
!DIR$ ATTRIBUTES ALIGN : 64 :: A,B,A2,AI,A2B,AIB
#endif
      REAL(kind=8), dimension(LL*2+1) :: Y,CXX,CXY,CYX,CUZ,CYU,CZY
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: Y,CXX,CXY,CYX,CUZ,CYU,CZY    
#endif
      REAL(kind=dp) :: CST0, CST1, DSR2, CAI1
      INTEGER(kind=4) :: ISWRO,IDOS,ISIK,IORIG,I,II,IG,IPQ1,IPM1, &
                       IJ,IK,IA,L2,M2,I2P,LXX,MXX,LYZ,MYX,IAIB, &
                       LZX,MZX,MZY,LZX,LZZ,MZZ,IQM1,LZYZ,MZYZ,  &
                       MYZ,LUX,MUX,LUY,MUY,LUU,MUU,LUYU,MUU,    &
                       MUYU,IA2B,LUZ,LUYZ,MUYZ,LYU,MYU,IST,IEN, &
                       IJ1,JJ,MXY,LXY,LZY,MUZ
      
                 
      COMMON /COM70/ISWRO
      COMMON /COM71/IDOS
      COMMON /COM72/ISIK

      CST0=0.0_8
      CST1=1.0_8
!cc      IORIG=501
      IORIG=LL+1
      DSR2=0.95_8
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))    
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif  
      DO 100 I=1,IP
!cxx  100 A(I)=X(I)
      A(I)=X(I)
  100 CONTINUE
      IF(IQ.LE.0) GO TO 420
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))      
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 110 I=1,IQ
      II=IP+I
!cxx  110 B(I)=X(II)
      B(I)=X(II)
  110 CONTINUE
  420 CONTINUE
      IG=1
      IF(ISIK.NE.0) GO TO 25
!cxx   24 IG=0
      IG=0
!C     ADJUSTMENT FOR FEASIBLE INITIAL
!C     INVERSE OF A(I) COMPUTATION
!cc   25 CALL INVERS(A,IP,B,0,AI,IA,IG)
!cx   25 CALL INVERS(A,IP,B,0,AI,IA,IG,IFG,LU)
!cxx   25 CALL INVERS(A,IP,B,0,AI,IA,ICST,IG,IFG,LU)
   25 CALL INVERS(A,IP,B,0,AI,IA,ICST,IG)
      IF(ISIK.EQ.0) GO TO 26
      IF(ISWRO.NE.0) GO TO 1900
      IF(IDOS.NE.3) GO TO 1900
   26 IF(IG.EQ.0) GO TO 1900
      CAI1=CST1
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif   
      DO 1941 I=1,IP
      CAI1=CAI1*DSR2
!cxx 1941 A(I)=A(I)*CAI1
      A(I)=A(I)*CAI1
 1941 CONTINUE
!cc      WRITE(6,1940)
!cx      IF (IFG.NE.0) WRITE(LU,1940)
!cxx 1940 FORMAT(1H ,'NON-INVERTIBLE MA PART')
      IF(ISIK.NE.0) GO TO 1899
      IG=0
 1899 GO TO 25
 1900 IF(IA.NE.0) GO TO 1901
      IA=1
      AI(1)=CST0
 1901 CONTINUE
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 2100 I=1,IP
!cxx 2100 X(I)=A(I)
      X(I)=A(I)
 2100 CONTINUE
      IF(IQ.LE.0) GO TO 2420
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
 #elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif   
      DO 2110 I=1,IQ
      II=IP+I
!cxx 2110 X(II)=B(I)
      X(II)=B(I)
 2110 CONTINUE
 2420 CONTINUE
      ISIK=1
      IPM1=IP-1
      IQM1=IQ-1
!C     AIB=(INVERSE OF A)*B
      IG=0
!cc      CALL INVERS(A,IP,B,IQ,AIB,IAIB,IG)
!cx      CALL INVERS(A,IP,B,IQ,AIB,IAIB,IG,IFG,LU)
!cxx      CALL INVERS(A,IP,B,IQ,AIB,IAIB,ICST,IG,IFG,LU)
      CALL INVERS(A,IP,B,IQ,AIB,IAIB,ICST,IG)
!C     A2B=(INVERSE OF A*A)*B
!C     A2=A*A
      Y(IORIG)=CST1
#if defined __ICC
      !DIR$ SIMD
      !DIR$ VECTOR ALIGNED
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 502 I=1,IP
      IJ=IORIG+I
      IK=IORIG-I
      A2B(I)=A(I)
      Y(IK)=A(I)
!cxx  502 Y(IJ)=CST0
      Y(IJ)=CST0
  502 CONTINUE
      IK=IORIG-IP
      DO 503 I=1,IP
      IK=IK-1
!cxx  503 Y(IK)=CST0
      Y(IK)=CST0
  503 CONTINUE
      L2=-IP-IP
      M2=-1
!cc      CALL SCONVL(Y,A2B,Y,IP,L2,M2)
      CALL SCONVL(Y,A2B,Y,IP,L2,M2,LL)
      I2P=IP+IP
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))     
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif
      DO 504 I=1,I2P
      IJ=IORIG-I
!cxx  504 A2(I)=Y(IJ)
      A2(I)=Y(IJ)
  504 CONTINUE
      IG=1
!cc      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,IG)
!cx      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,IG,IFG,LU)
!cxx      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,ICST,IG,IFG,LU)
      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,ICST,IG)
      LXX=0
!cc      MXX=50
      MXX=MM
      LXY=0
      MXY=MXX+IAIB
      LYX=-MXY
      MYX=-LXY
      LZX=-IQ
      MZX=-1
      LZY=LZX
      MZY=MZX+IAIB
      LZZ=0
      MZZ=IQM1
      LZYZ=LZZ
      MZYZ=MZZ+IA
      LZY=MIN0(LZY,LZYZ)
      MZY=MAX0(MZY,MZYZ)
      LYZ=-MZY
      MYZ=-LZY
      LUX=-IP
      MUX=-1
      LUY=-IP
      MUY=MUX+IAIB
      LUU=0
      MUU=IPM1
      LUYU=0
      MUYU=MUU+IA2B
      LUY=MIN0(LUY,LUYU)
      MUY=MAX0(MUY,MUYU)
      LUZ=-IPM1
      MUZ=IQM1
      LUYZ=LUZ
      MUYZ=MUZ+IA
      LUY=MIN0(LUY,LUYZ)
      MUY=MAX0(MUY,MUYZ)
      LYU=-MUY
      MYU=-LUY
!cc      WRITE(6,2502)
!cc 2500 WRITE(6,3000) LXX,LXY,LZX,LZY,LUX,LUU,LUZ,LUY,LUYU,LZYZ,IA,IAIB,
!cc     AIA2B
!cc 2501 WRITE(6,3000) MXX,MXY,MZX,MZY,MUX,MUU,MUZ,MUY,MUYU,MZYZ
!cx      IF (IFG.NE.0) THEN
!cx      WRITE(LU,2502)
!cx 2500	 WRITE(LU,3000) LXX,LXY,LZX,LZY,LUX,LUU,LUZ,LUY,LUYU,LZYZ,
!cx     *	 IA,IAIB,IA2B
!cx 2501	 WRITE(LU,3000) MXX,MXY,MZX,MZY,MUX,MUU,MUZ,MUY,MUYU,MZYZ
!cx      END IF
!C     CXX0 COMPUTATION
!C     CYX=CYY*AIB'
!cc	CALL SCONVL(CYY,AIB,CYX,IAIB,LYX,MYX)
      CALL SCONVL(CYY,AIB,CYX,IAIB,LYX,MYX,LL)
!C
!cc      CALL TURN(CYX,CXY,LYX,MYX)
      DO 505 I=1,LL*2+1
         CXY(I)=CXX(I)
  505 CONTINUE
      CALL TURN(CYX,CXY,LYX,MYX,LL)
!C     CXX=CXY*AIB'
!cc      CALL SCONVL(CXY,AIB,CXX,IAIB,LXX,MXX)
      CALL SCONVL(CXY,AIB,CXX,IAIB,LXX,MXX,LL)
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8)) 
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif 
      DO 506 I=1,LL*2+1
         CXX(I)=CXY(I)
  506 CONTINUE
      CXX0=CXX(IORIG)
      IST=IORIG+LXX
      IEN=IORIG+MXX
      IJ=0
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))    
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif 
      DO 510 I=IST,IEN
      IJ=IJ+1
!cxx  510 CN(IJ)=CXX(I)/CXX0
      CN(IJ)=CXX(I)/CXX0
  510 CONTINUE
!C     GA COMPUTATION
!C     CYU=CYY*A2B'
!cc      CALL SCONVL(CYY,A2B,CYU,IA2B,LYU,MYU)
!cc      CALL TURN(CYU,CUY,LYU,MYU)
!cc      CALL SCONVL(CUY,AIB,CUX,IAIB,LUX,MUX)
      CALL SCONVL(CYY,A2B,CYU,IA2B,LYU,MYU,LL)
      CALL TURN(CYU,CUZ,LYU,MYU,LL)
      CALL SCONVL(CUZ,AIB,CYX,IAIB,LUX,MUX,LL)
!C     HAA
!cc      CALL SCONVL(CUY,A2B,CUU,IA2B,LUU,MUU)
      CALL SCONVL(CUZ,A2B,CXX,IA2B,LUU,MUU,LL)
      IF(IQ.EQ.0) GO TO 550
!C     HAB
!cc      CALL SCONVL(CUY,AI,CUZ,IA,LUZ,MUZ)
      CALL SCONVL(CUZ,AI,CUZ,IA,LUZ,MUZ,LL)
!C     GB COMPUTATION
!C     CYZ=CYY*AI'
!C     IF(IQ.EQ.0) GO TO 550
!cc      CALL SCONVL(CYY,AI,CYZ,IA,LYZ,MYZ)
!cc      CALL TURN(CYZ,CZY,LYZ,MYZ)
!cc      CALL SCONVL(CZY,AIB,CZX,IAIB,LZX,MZX)
      CALL SCONVL(CYY,AI,CYU,IA,LYZ,MYZ,LL)
      CALL TURN(CYU,CZY,LYZ,MYZ,LL)
      CALL SCONVL(CZY,AIB,CYU,IAIB,LZX,MZX,LL)
!C     HBB
!cc      CALL SCONVL(CZY,AI,CZZ,IA,LZZ,MZZ)
      CALL SCONVL(CZY,AI,CZY,IA,LZZ,MZZ,LL)
!C     HESSIAN ARRANGEMENT FOR U
  550 CONTINUE
      DO 211 I=1,IP
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))   
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif    
         DO 212 J=1,I
            IJ1=IORIG+I-J
!cc      AL(I,J)=CUU(IJ1)
            AL(I,J)=CXX(IJ1)
!cxx  212 AL(J,I)=AL(I,J)
            AL(J,I)=AL(I,J)
         212 CONTINUE
  211 CONTINUE
      IF(IQ.LE.0) GO TO 4220
!C     HESSIAN ARRANGEMENT FOR V
      DO 231 I=1,IQ
      II=IP+I
      DO 232 J=1,I
      JJ=IP+J
      IJ1=IORIG+I-J
!cc      AL(II,JJ)=CZZ(IJ1)
      AL(II,JJ)=CZY(IJ1)
!cxx  232 AL(JJ,II)=AL(II,JJ)
      AL(JJ,II)=AL(II,JJ)
  232 CONTINUE
  231 CONTINUE
!C     HESSIAN ARRANGEMENT FOR -W AND -W'
      DO 251 I=1,IQ
      II=IP+I
      DO 252 J=1,IP
      IJ1=IORIG+I-J
      AL(II,J)=-CUZ(IJ1)
!cxx  252 AL(J,II)=AL(II,J)
      AL(J,II)=AL(II,J)
  252 CONTINUE
  251 CONTINUE
 4220 CONTINUE
      !C     GRADIENT ARRANGEMENT
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif  
      DO 280 I=1,IP
      I1=IORIG-I
!cc  280 G(I)=-CUX(I1)
!cxx  280 G(I)=-CYX(I1)
      G(I)=-CYX(I1)
  280 CONTINUE
      IF(IQ.LE.0) GO TO 4230
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif  
      DO 281 I=1,IQ
      II=IP+I
      I1=IORIG-I
!cc  281 G(II)=CZX(I1)
!cxx  281 G(II)=CYU(I1)
      G(II)=CYU(I1)
  281 CONTINUE
      IDOS=0
 4230 RETURN

    END SUBROUTINE
    

    SUBROUTINE SC0GR1(X,CYY,G,CXX0,IP,IQ,IG,LL,ICST) !GCC$ ATTRIBUTES HOT :: SC0GR1 !GCC$ ATTRIBUTES ALIGNED(32) :: SC0GR1
       use omp_lib
!C     THIS SUBROUTINE COMPUTES CXX0 AND GRADIENT.
#if defined __ICC
          !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: SC0GR1
#endif          
          INTEGER(kind=4) :: IP, IQ, IG, LL, ICST
          REAL(kind=8), dimension(IP+IQ) :: X,G  
          REAL(kind=8), dimension(LL*2+1) :: CYY
          REAL(kind=8) :: CXX0
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64,G:64
          !DIR$ ASSUME_ALIGNED CYY:64
#endif
          ! Locals
          REAL(kind=8), dimension(IP)   :: A
          REAL(kind=8), dimension(IQ)   :: B 
          REAL(kind=8), dimension(ICST) :: AI, A2B, AIB 
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: A,B,AI,A2B,AIB
#endif
          REAL(kind=8), dimension(IP*2) :: A2 
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: A2
#endif
          REAL(kind=8), dimension(LL*2+1) ::  Y, CXX, CYX, &
                                        CUY, CYU, CZY
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: Y,CXX,CYX,CUY,CYU,CZY
#endif
          REAL(kind=8)    ::     CST0, CST1
          INTEGER(kind=4) ::     I,IORIG,IGA2B,II,IB,IA,IPM1,IQM1,IGAIB,  &
                           IJ,IK,L2,M2,I2P,LXX,MXX,LXY,MXY,LYX,MYX, &
                           LZX,MZX,LZY,MZY,LYZ,MYZ,LUX,MUX,LUY,MUY, &
                           LYU,MYU,IAIB,I1,IPQ

         CST0=0.0_8
         CST1=1.0_8
!cc      IORIG=501
         IORIG=LL+1
         IGA2B=IG
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))  
 #elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif        
         DO 100 I=1,IP
!cxx  100 A(I)=X(I)
           A(I)=X(I)
    100 CONTINUE
           IF(IQ.LE.0) GO TO 420
#if defined __ICC
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8)) 
#elif defined __GFORTRAN__       
!$OMP SIMD LINEAR(I:1)
#endif         
        DO 110 I=1,IQ
               II=IP+I
!cxx  110 B(I)=X(II)
               B(I)=X(II)
    110 CONTINUE
    420 CONTINUE
        IB=IQ
!C     INVERSE OF A(I) COMPUTATION
!cc   24 CALL INVERS(A,IP,B,0,AI,IA,IG)
!cx   24 CALL INVERS(A,IP,B,0,AI,IA,IG,IFG,LU)
!cxx   24 CALL INVERS(A,IP,B,0,AI,IA,ICST,IG,IFG,LU)
        CALL INVERS(A,IP,B,0,AI,IA,ICST,IG)
        IF(IG.NE.1) GO TO 1900
        GO TO 1000
 1900   IF(IA.NE.0) GO TO 1901
        IA=1
        AI(1)=CST0
1901    CONTINUE
#if 
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))        
        DO 2100 I=1,IP
!cxx 2100 X(I)=A(I)
           X(I)=A(I)
 2100 CONTINUE
      IF(IQ.LE.0) GO TO 2420
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))           
       DO 2110 I=1,IQ
           II=IP+I
!cxx 2110 X(II)=B(I)
           X(II)=B(I)
 2110 CONTINUE
 2420 CONTINUE
        IPM1=IP-1
        IQM1=IQ-1
!C     AIB=(INVERSE OF A)*B
         IGAIB=0
!cc   25 CALL INVERS(A,IP,B,IQ,AIB,IAIB,IGAIB)
!cx   25 CALL INVERS(A,IP,B,IQ,AIB,IAIB,IGAIB,IFG,LU)
!cxx   25 CALL INVERS(A,IP,B,IQ,AIB,IAIB,ICST,IGAIB,IFG,LU)
        CALL INVERS(A,IP,B,IQ,AIB,IAIB,ICST,IGAIB)
!C     A2B=(INVERSE OF A*A)*B
!C     A2=A*A
        Y(IORIG)=CST1
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))        
        DO 502 I=1,IP
              IJ=IORIG+I
              IK=IORIG-I
              A2B(I)=A(I)
              Y(IK)=A(I)
!cxx  502 Y(IJ)=CST0
              Y(IJ)=CST0
  502 CONTINUE
      IK=IORIG-IP
      DO 503 I=1,IP
             IK=IK-1
!cxx  503 Y(IK)=CST0
             Y(IK)=CST0
    503 CONTINUE
        L2=-IP-IP
        M2=-1
!cc      CALL SCONVL(Y,A2B,Y,IP,L2,M2)
      CALL SCONVL(Y,A2B,Y,IP,L2,M2,LL)
      I2P=IP+IP
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))      
      DO 504 I=1,I2P
             IJ=IORIG-I
!cxx  504 A2(I)=Y(IJ)
             A2(I)=Y(IJ)
  504 CONTINUE
!cc      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,IGA2B)
!cx      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,IGA2B,IFG,LU)
!cxx      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,ICST,IGA2B,IFG,LU)
      CALL INVERS(A2,I2P,B,IQ,A2B,IA2B,ICST,IGA2B)
         LXX=0
         MXX=0
         LXY=0
         MXY=MXX+IAIB
         LYX=-MXY
         MYX=-LXY
         LZX=-IQ
         MZX=-1
         LZY=LZX
         MZY=MZX+IAIB
         LYZ=-MZY
         MYZ=-LZY
         LUX=-IP
         MUX=-1
         LUY=-IP
         MUY=MUX+IAIB
         LYU=-MUY
         MYU=-LUY
!C     CXX0 COMPUTATION
!C     CYX=CYY*AIB'
!cc      CALL SCONVL(CYY,AIB,CYX,IAIB,LYX,MYX)
!cc      CALL TURN(CYX,CXY,LYX,MYX)
        CALL SCONVL(CYY,AIB,CYX,IAIB,LYX,MYX,LL)
        CALL TURN(CYX,CXX,LYX,MYX,LL)
!C     CXX=CXY*AIB'
!cc      CALL SCONVL(CXY,AIB,CXX,IAIB,LXX,MXX)
        CALL SCONVL(CXX,AIB,CXX,IAIB,LXX,MXX,LL)
        CXX0=CXX(IORIG)
!C     GA COMPUTATION
!C     CYU=CYY*A2B'
!cc      CALL SCONVL(CYY,A2B,CYU,IA2B,LYU,MYU)
!cc      CALL TURN(CYU,CUY,LYU,MYU)
!cc      CALL SCONVL(CUY,AIB,CUX,IAIB,LUX,MUX)
        CALL SCONVL(CYY,A2B,CYU,IA2B,LYU,MYU,LL)
        CALL TURN(CYU,CUY,LYU,MYU,LL)
        CALL SCONVL(CUY,AIB,CYX,IAIB,LUX,MUX,LL)
!C     GB COMPUTATION
!C     CYZ=CYY*AI'
        IF(IQ.EQ.0) GO TO 5279
!cc      CALL SCONVL(CYY,AI,CYZ,IA,LYZ,MYZ)
!cc      CALL TURN(CYZ,CZY,LYZ,MYZ)
!cc      CALL SCONVL(CZY,AIB,CZX,IAIB,LZX,MZX)
        CALL SCONVL(CYY,AI,CYU,IA,LYZ,MYZ,LL)
        CALL TURN(CYU,CZY,LYZ,MYZ,LL)
        CALL SCONVL(CZY,AIB,CYU,IAIB,LZX,MZX,LL)
 5279   CONTINUE
        !C     GRADIENT ARRANGEMENT
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))        
        DO 5280 I=1,IP
              I1=IORIG-I
!cc 5280 G(I)=-CUX(I1)
!cxx 5280 G(I)=-CYX(I1)
              G(I)=-CYX(I1)
 5280  CONTINUE
       IF(IQ.LE.0) GO TO 5290
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))              
        DO 5281 I=1,IQ
              II=IP+I
              I1=IORIG-I
!cc 5281 G(II)=CZX(I1)
!cxx 5281 G(II)=CYU(I1)
      G(II)=CYU(I1)
 5281 CONTINUE
 5290 CONTINUE
!C     CXX0, GRADIENT PRINT OUT
      IPQ=IP+IQ
 1000 RETURN
    END  SUBROUTINE
    
!C

    SUBROUTINE SDAV1(X,CYY,CXX0,G,C,IP,IQ,N,VD,NN,LL,ICST)
!C      DADIDON'S (MINIMIZATION) PROCEDURE
          
          !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: SDAV1
     

          INTEGER(kind=4) :: IP, IQ, N, NN, LL, ICST
          REAL(kind=8), dimension(IP+IQ)  :: X, G, C 
          REAL(kind=8), dimension(LL*2+1) :: CYY
          REAL(kind=8), dimension(NN,NN) :: VD
          REAL(kind=8) :: CXX0
          !DIR$ ASSUME_ALIGNED X:64,G:64,C:64
          !DIR$ ASSUME_ALIGNED CYY:64
          !DIR$ ASSUME_ALIGNED VD:64
          REAL(kind=8), dimension(IP+IQ)  :: SX, SG, SR
!DIR$     ATTRIBUTES ALIGN : 64 :: SX,SG,SR
          REAL(kind=8) :: CST0, CST1, CST2,                                     &   
                        CST05, CONSTA, CONSTB, EPS1, EPS3, EPS4,              &
                        AIPQ, AN, PHAI, EPHAI1, T1, RO, RAM, RAMRO, RAMROT,   &
                        SUM, SRO, SROD, DGAM, DGAM1, GSR, RAMT, RAMSRO,       &
                        RAM1, CONSDR, SPHAI, OAIC, OPHAI, AIC, DAIC
         INTEGER(kind=4) :: ISWRO,ISPHAI,ITN,IPHAI,IPQ,ITNS,I,J,IG,IRAM        
         COMMON /COM70/ISWRO
         ! Locals
!C     CONSTANT
        CST0=0.0_8
        CST1=1.0_8
        CST2=2.0_8
        CST05=0.5_8
        CONSTA=0.5_8
        CONSTB=2.0_8
        EPS1=0.01_8
        EPS3=0.000001_d8
        EPS4=0.0000000001_8
        ISPHAI=0
        ITN=1
        IPHAI=1
        IPQ=IP+IQ
        AIPQ=IPQ
        AN=N
        PHAI=CXX0
  150   CONTINUE
!C     RO=G'*C COMPUTATION
        ITNS=0
!C     COMMON SUBROUTINE CALL
   40   CALL INNERP(G,C,RO,IPQ)
        IF(IPHAI.EQ.0) GO TO 101
        PHAI=CXX0
  101   OPHAI=PHAI
        EPHAI1=EPS1*PHAI
        T1=RO-CST2*PHAI
        IF(T1.LE.EPHAI1) GO TO 140
           RAM=CST2*PHAI/RO
!C     V=V+((RAM-1.0)/RO)*(C*C')
        RAMRO=(RAM-CST1)/RO
!cxx      DO 110 I=1,IPQ
        DO 111 I=1,IPQ
           RAMROT=RAMRO*C(I)
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))           
           DO 110 J=1,IPQ
!cxx  110 VD(I,J)=VD(I,J)+RAMROT*C(J)
              VD(I,J)=VD(I,J)+RAMROT*C(J)
       110 CONTINUE
    111 CONTINUE
              !C     C=RAM*C
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))              
        DO 120 I=1,IPQ
!cxx  120 C(I)=RAM*C(I)
              C(I)=RAM*C(I)
  120 CONTINUE
       IF(ITNS.GE.10) GO TO 140
         ITNS=ITNS+1
       GO TO 40
!C     SX=X-R
  140 CONTINUE
       IG=0
1210   CONTINUE
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))       
       DO 210 I=1,IPQ
!cxx  210 SX(I)=X(I)-C(I)
             SX(I)=X(I)-C(I)
  210 CONTINUE
!C     SPHAI=CXX0, SG=GRADIENT COMPUTATION
!cc      CALL SC0GR1(SX,CYY,SG,SPHAI,IP,IQ,IG,LL,ICST)
!cxx      CALL SC0GR1(SX,CYY,SG,SPHAI,IP,IQ,IG,LL,ICST,IFG,LU)
      CALL SC0GR1(SX,CYY,SG,SPHAI,IP,IQ,IG,LL,ICST)
      IF(IG.NE.1) GO TO 309
!cxx      DO 303 I=1,IPQ
      DO 304 I=1,IPQ
         C(I)=CST05*C(I)
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))         
         DO 303 J=1,IPQ
!cxx  303 VD(I,J)=CST05*VD(I,J)
            VD(I,J)=CST05*VD(I,J)
     303 CONTINUE
  304 CONTINUE
      GO TO 1210
  309 CONTINUE
!C     SR=V*SG
      DO 310 I=1,IPQ
         SUM=CST0
!DIR$      VECTOR ALIGNED
!DIR$      SIMD REDUCTION(+:SUM)      
          DO 311 J=1,IPQ
!cxx  311 SUM=SUM+VD(I,J)*SG(J)
               SUM=SUM+VD(I,J)*SG(J)
       311 CONTINUE
!cxx  310 SR(I)=SUM
          SR(I)=SUM
  310 CONTINUE
!C     SRO=(SG)'*(SR)
!C     COMMON SUBROUTINE CALL
      CALL INNERP(SG,SR,SRO,IPQ)
      SROD=SRO/PHAI
!C     DGAM=-G'*(SR)/SRO
!C     COMMON SUBROUTINE CALL
      CALL INNERP(G,SR,GSR,IPQ)
      DGAM=-GSR/SRO
      DGAM1=DGAM+CST1
      DGAM1=DABS(DGAM1)+0.1e-70_8
      RAM=DABS(DGAM)/DGAM1
!C     IF RAM . LE. CONSTA THEN RAM=CONSTA
      IF(RAM.GT.CONSTA) GO TO 430
      RAM=CONSTA
      IRAM=1
      GO TO 470
!C     IF RAM . GE. CONSTB THEN RAM=CONSTB
  430 IF(RAM.LT.CONSTB) GO TO 450
      RAM=CONSTB
      IRAM=-1
      GO TO 470
!C     RAM=RAM
  450 CONTINUE
      IRAM=0
!C     V=V+((RAM-1.0)/SRO)*(SR)*(SR)'
  470 RAMSRO=(RAM-CST1)/SRO
!cxx      DO 480 I=1,IPQ
      DO 481 I=1,IPQ
         RAMT=RAMSRO*SR(I)
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
         DO 480 J=1,IPQ
!cxx  480 VD(I,J)=VD(I,J)+RAMT*SR(J)
                 VD(I,J)=VD(I,J)+RAMT*SR(J)
      480 CONTINUE
  481 CONTINUE
      IF(PHAI.GE.SPHAI) GO TO 540
!C     SPHAI.GT.PHAI: TEST OF CORRECTION
         RAM1=RAM-CST1
      IF(DABS(RAM1).LT.EPS3) GO TO 555
      CONSDR=DGAM*RAM1
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))      
      DO 550 I=1,IPQ
!cxx  550 C(I)=C(I)-CONSDR*SR(I)
                C(I)=C(I)-CONSDR*SR(I)
  550 CONTINUE
      IPHAI=0
      IF(SROD.GT.EPS4) GO TO 900
!C     END OF ITERATION
  555 ISWRO=ISWRO+1
      GO TO 1000
      !C     SPHAI LE. PHAI: SUCCESSFUL REDUCTION
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))      
  540 DO 560 I=1,IPQ
            X(I)=SX(I)
            G(I)=SG(I)
!cxx  560 C(I)=RAM*SR(I)
            C(I)=RAM*SR(I)
  560 CONTINUE
      CXX0=SPHAI
      PHAI=SPHAI
      IPHAI=1
!cxx  800 CONTINUE
      OAIC=AN*DLOG(OPHAI)+CST2*AIPQ
      AIC=AN*DLOG(PHAI)+CST2*AIPQ
      DAIC=OAIC-AIC
      IF(IRAM.NE.0) GO TO 901
      IF(SROD.LT.EPS4) GO TO 555
!C     ITERATION CHECK
  900 IPQ2=IPQ+IPQ
      IF(ITN.GE.IPQ2) GO TO 555
      ISPHAI=(ISPHAI+(1-IPHAI))*(1-IPHAI)
      IF(ISPHAI.GT.10) GO TO 555
      ITN=ITN+1
      GO TO 150
  901 IF(SROD.LT.EPS4) GO TO 555
      GO TO 900
!C     END OF MINIMIZATION
!cxx  999 ISWRO=0
      ISWRO=0
 1000 CONTINUE
!cxx 1001 RETURN
      RETURN
    END  SUBROUTINE
    

    SUBROUTINE SCONVL(Y,A,Z,K,L,M,LL)
          !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: SCONVL
          INTEGER(kind=4) :: K, L, M, LL
          REAL(kind=8), dimension(LL*2+1) :: Y,Z 
          REAL(kind=8), dimension(K) :: A
          !DIR$ ASSUME_ALIGNED Y:64,Z:64
          !DIR$ ASSUME_ALIGNED A:64
          REAL(kind=8) :: SUM
          ! Locals
          INTEGER(kind=4) :: IORIG,I,J,IST,IEN,IJ
          IORIG=LL+1
          IST=IORIG+L
          IEN=IORIG+M
          DO 3 I=IST,IEN
             SUM=Y(I)
!DIR$      VECTOR ALIGNED
!DIR$      SIMD REDUCTION(+:SUM)         
             DO 2 J=1,K
                    IJ=I+J
!cxx    2 SUM=SUM+Y(IJ)*A(J)
                    SUM=SUM+Y(IJ)*A(J)
          2 CONTINUE
!cxx    3 Z(I)=SUM
                   Z(I)=SUM
    3 CONTINUE
    
    END  SUBROUTINE
    

    SUBROUTINE TURN(Y,Z,L,M,LL)
           !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: TURN
          INTEGER(kind=4) :: L, M, LL
          REAL(kind=8), dimension(LL+M+1) :: Y
          REAL(kind=8), dimension(LL-L+1) :: Z
          !DIR$ ASSUME_ALIGNED Y:64,Z:64
          ! Locals
          INTEGER(kind=4) :: IORIG,IST,IEN,I,IJ
          IORIG=LL+1
          IST=IORIG+L
          IEN=IORIG+M
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 1 I=IST,IEN
               IJ=IORIG-(I-IORIG)
!cxx    1 Z(IJ)=Y(I)
              Z(IJ)=Y(I)
    1 CONTINUE
     
    END  SUBROUTINE
    
    

    SUBROUTINE INVERS(A,IP,B,IQ,X,IX,ICST,IG)
        !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: INVERS
!C     X=(INVERSE OF B )*A
!C     W(I)+B(1)W(I-1)+...B(IQ)W(I-IQ)=X(I)+A(1)X(I-1)+...+A(IP)X(I-IP)
!C     INPUT W(0)=1, W(I)=0 FOR I. NE. 0
!C     OUTPUT X(I) (I=1,IX)

          INTEGER(kind=4) :: IP, IQ, IX, ICST, IG
          REAL(kind=8), dimension(IP)   :: A
          REAL(kind=8), dimension(IQ)   :: B
          REAL(kind=8), dimension(ICST) :: X
          !DIR$ ASSUME_ALIGNED A:64,B:64,X:64
          REAL(kind=8) :: CST0, GCONST, GAMMAX, SUM, GAM2
          INTEGER(kind=4) :: IPQ,I,K,LH,IH,IM1,JM,IMJ,J
          CST0=0.0_8
          IPQ=IP+IQ
          IF(IPQ.LE.0) GO TO 999
          GCONST=0.0005_8
          GAMMAX=1.0E+10_8
          K=0
          LH=6
          IH=0
          IF(IG.EQ.0) GO TO 13
             GCONST=0.01_8
          IG=0
!c!x   13 DO 10 I=1,190
   13     DO 10 I=1,ICST
                IX=I
                SUM=CST0
          IF(I.GT.IQ) GO TO 2
            SUM=B(I)
    2     IF(I.GT.IP) GO TO 3
          SUM=SUM-A(I)
    3     IM1=I-1
          JM=MIN0(IM1,IP)
          IF(JM.LE.0) GO TO 5
!DIR$      VECTOR ALIGNED
!DIR$      SIMD REDUCTION(+:SUM)      
          DO 4 J=1,JM
               IMJ=I-J
!cxx    4 SUM=SUM-X(IMJ)*A(J)
          SUM=SUM-X(IMJ)*A(J)
      4 CONTINUE
    5   X(I)=SUM
        GAM2=DABS(SUM)
        IF(GAM2.GE.GCONST) GO TO 24
        IH=IH+1
        IF(IH.LT.LH) GO TO 10
        GO TO 1000
   24   IF(GAM2.LE.GAMMAX) GO TO 26
        IG=1
!cc	WRITE(6,60)
!cx      IF (IFG.NE.0) WRITE(LU,60)
        GO TO 1000
   26   IH=0
   10   CONTINUE
        IF(IH.GE.LH) GO TO 1000
        IG=1
!cc      WRITE(6,59)
!cx      IF (IFG.NE.0) WRITE(LU,59)
        GO TO 1000
  999   IX=0
 1000   RETURN
!cxx   59 FORMAT(1H ,'INCOMPLETE CONVERGENCE OF INVERSE')
!cxx   60 FORMAT(1H ,'DIVERGENT INVERSE')
    END SUBROUTINE
    
    SUBROUTINE AUTCORF(X,N,CXX,CN,LAGH1,XMEAN)
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: AUTCORF
      
!C
!C     PROGRAM 5.1.1   AUTO CORRELATION
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM REQUIRES FOLLOWING INPUTS:
!C     N: LENGTH OF DATA
!C     LAGH: MAXIMUM LAG
!C     DFORM: INPUT FORMAT SPECIFICATION STATEMENT IN ONE CARD,
!C     FOR EXAMPLE
!C     (8F10.4)
!C     (X(I),I=1,N): ORIGINAL DATA.
!C     THE OUTPUTS ARE AUTOCOVARIANCES (CXX(I); I=0,LAGH) AND
!C     AUTO CORRELATIONS (NORMALIZED COVARIANCES).
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: AUTCORF
!C
!cxx      IMPLICIT REAL*8 (A-H,O-Z)
!c      DIMENSION X(5000),CXX(1001),CN(1001)
!c	 REAL*4 DFORM
!c      DIMENSION  DFORM(20)
!cxx      DIMENSION X(N),X1(N),CXX(LAGH1),CN(LAGH1)
          INTEGER(kind=4) :: N, LAGH1
          REAL(kind=8), dimension(N) :: X 
          REAL(kind=8), dimension(LAGHI) :: CXX,CN
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED CXX:64,CN:64
          REAL(kind=8) :: XMEAN
          REAL(kind=8), dimension(N) :: X1
!DIR$     ATTRIBUTES ALIGN : 64 :: X1
          REAL(kind=8) :: CX0
          INTEGER(kind=4) :: I
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 220 I=1,N
!cxx  220 X1(I)=X(I)
              X1(I)=X(I)
     220  CONTINUE
!C     MEAN DELETION
          CALL DMEADL(X1,N,XMEAN)
!C     AUTO COVARIANCE COMPUTATION
!c      LAGH1=LAGH+1
          CALL CROSCO(X1,X1,N,CXX,LAGH1)
!C     NORMALIZATION
          CX0=CXX(1)
          CALL CORNOM(CXX,CN,LAGH1,CX0,CX0)
!C     AUTO COVARIANCE PRINT OUT

!C     AUTO COVARIANCE PUNCH OUT

    
    END SUBROUTINE
    
!    C Reviced	M.S C85-02-19-16:46:06 BAYSEAA PAIR                                         

    SUBROUTINE BAYSEAF(Y,NDATA,FOCAST,CDATA,DMOI,TREND,SEASON,TDCMP,   &
                         IRREG,ADJUST,EST,PSDS,PSDT,AVABIC,             &
                         IPARA,PARA,ARFT,ARFS,ARFN,IART,IARS,IARN)
                                                                      
          !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: BAYSEAF
!C
!C     ---      --       -                                               
!C     BAYESIAN SEASONAL ADJUSTMENT PROCEDURE                            
!C                                                                       
!C     THIS IS VERSION(3/1/85) OF BAYSEA WHICH WAS ORIGINALLY            
!C     PUBLISHED IN                                                      
!C                                                                       
!C       AKAIKE,H. AND ISHIGURO,M. (1980)                                
!C         BAYSEA, A BAYESIAN SEASONAL ADJUSTMENT PROGRAM.               
!C         COMPUTER SCIENCE MONOGRAPHS, NO.13,                           
!C         THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO.              
!C                                                                       
!C     THIS VERSION WAS DESIGNED AND PROGRAMMED BY                       
!C     HIROTUGU AKAIKE AND MAKIO ISHIGURO, THE INSTITUTE OF STATISTICAL  
!C     MATHEMATICS, 4-6-7 MINAMI-AZABU, MINATO-KU, TOKYO, 106, JAPAN.    
!C     THE SUBROUTINES FOR OUTLIER CORRECTION WERE PREPARED BY           
!C     GENSHIRO KITAGAWA.                                                
!C                                                                       
!C     THIS PROGRAM REALIZES A DECOMPOSITION OF TIME SERIES Y            
!C     INTO THE FORM                                                     
!C     Y(I) = T(I) +S(I)+I(I)+TDC(I)+OCF(I)                              
!C     WHERE  T(I)=TREND  S(I)=SEASONAL  I(I)=IRREGULAR                  
!C            TDC(I)=TRADING DAY COMPONENT     AND                       
!C            OCF(I)=OUTLIER CORRECTION FACTOR                           
!C                                                                       
!C     THE PROCEDURE IS BASED ON A BAYESIAN MODEL AND ITS                
!C     PERFORMANCE IS CONTROLLED BY THE SELECTION OF THE PARAMETERS OF   
!C     THE PRIOR DISTRIBUTION.  THE CONSTRUCTION OF THE BASIC MODEL IS   
!C     DISCUSSED IN THE FOLLOWING PAPERS:                                
!C!                                                                       
!C       AKAIKE, H. (1980) LIKELIHOOD AND THE BAYES PROCEDURE.           
!C         BAYESIAN STATISTICS, J.M.BERNARDO, M.H.DE GROOT, D.V.LINDLEY  
!C         AND A.F.M.SMITH, EDS., UNIVERSITY PRESS, VALENCIA,            
!C         SPAIN, 143-166.                                               
!C       AKAIKE, H. (1980) SEASONAL ADJUSTMENT BY A BAYESIAN MODELING.   
!C         JOURNAL OF TIME SERIES ANALYSIS, 1, 1-13.                     
!C       AKAIKE, H. AND ISHIGURO, M. (1980) TREND ESTIMATION WITH        
!C         MISSING OBSERVATIONS. ANNALS OF THE INSTITUTE OF STATISTICAL  
!C         MATHEMATICS, 32,B, 481-488.                                   
!C       ISHIGURO, M. AND AKAIKE, H. (1980) A BAYESIAN APPROACH TO       
!C         THE TRADING-DAY ADJUSTMENT OF MONTHLY DATA.                   
!C         TIME SERIES ANALYSIS, O.D.ANDERSON AND M.R.PERRYMAN, EDS.,    
!C         NORTH-HOLLAND, AMSTERDAM, 213-226.                            
!C       ISHIGURO,M. (1984) COMPUTATIONALLY EFFICIENT IMPLEMENTATION     
!C         OF A BYAESIAN SEASONAL ADJUSTMENT PROCEDURE.                  
!C         JOURNAL OF TIME SERIES ANALYSIS (TO APPEAR).                  
!C       KITAGAWA,G. AND AKAIKE,H. (1982) A QUASI BAYESIAN APPROACH      
!C         TO OUTLIER DETECTION. ANNALS OF THE INSTITUTE OF              
!C         STATISTICAL MATHEMATICS, 34,B, 389-398.                       
!C                                                                       
!C     THE PRIOR DISTRIBUTION CONTROLS THE SMOOTHNESS OF THE TREND AND   
!C     SEASONAL COMPONENTS BY ASSUMING LOW ORDER GAUSSIAN AR-MODELS      
!C     FOR SOME DIFFERENCES OF THESE COMPONENTS. THE CHOICE OF           
!C     THE VARIANCE OF THE GAUSSIAN DISTRIBUTION IS                      
!C     REALIZED BY MAXIMIZING THE LOG LIKELIHOOD OF THE BAYESIAN MODEL.  
!C                                                                       
!C     FOR THE PURPOSE OF COMPARISON OF MODELS WITH DIFFERENT STRUCTURES 
!C     THE CRITERION ABIC IS DEFINED BY                                  
!C                                                                       
!C          ABIC = (-2)LOG MAXIMUM LIKELIHOOD OF THE MODEL.              
!C                                                                       
!C     SMALLER VALUE OF ABIC REPRESENTS BETTER FIT.                      
!C     FOR THE COMPARISON OF OVERALL PERFORMANCES OF VARIOUS             
!C     MODELS THE AVERAGED ABIC (AVABIC) IS USEFUL.                      
!C                                                                       
!C     THIS PROGRAM REQUIRES THE FOLLOWING PARAMETERS.  WITHOUT FURTHER  
!C     SPECIFICATION BY THE PROGRAM USER, THEY ARE RESPECTIVELY SET EQUAL
!C     TO THE VALUES GIVEN IN THE PARENTHESES AT THE ENDS OF THEIR       
!C     DESCRIPTIONS.                                                     
!C                                                                       
!C     PARAMETERS:                                                       
!C       LOGT:   LOG-ADDITIVE-MODEL OPTION (0)                           
!C        IF( LOGT.EQ.0) ADDITIVE MODEL                                  
!C        IF( LOGT.EQ.1) LOG-ADDITIVE-MODEL                              
!C       MT:     INPUT DEVICE SPECIFICATION (5)                          
!C       RLIM:   OUTLIER LIMIT (0.0)                                     
!C        IF( RLIM.GT.0.0) ANY DATA WHOSE VALUE IS GREATER               
!C                         THAN RLIM IS TREATED AS A MISSING OBSERVATION 
!C        IF( RLIM.LE.0.0) NO MISSING OBSERVATIONS                       
!C       PERIOD: NUMBER OF SEASONALS WITHIN A PERIOD (12)                
!C       SPAN:   NUMBER OF PERIODS TO BE PROCESSED AT ONE TIME (4)       
!C       SHIFT:  NUMBER OF PERIODS TO BE SHIFTED                         
!C               TO DEFINE THE NEW SPAN OF DATA (1)                      
!C       FOCAST: LENGTH OF FORECAST AT THE END OF DATA (0)               
!C       ORDER:  ORDER OF DIFFERENCING OF TREND (2)                      
!C       ARFT(I): I-TH PARCOR OF DIFFERENCED TREND (I LESS THAN 4)       
!C       (0.D0)                                                          
!C       SORDER: ORDER OF DIFFERENCING OF SEASONAL (1)                   
!C       ARFS(I): I*PERIOD-TH PARCOR OF DIFFERENCD SEASONAL              
!C       (I LESS THAN 4) (0.D0)                                          
!C       ARFN(I): I-TH PARCOR OF DIFFERENCD SEASONAL                     
!C       (I LESS THAN 4) (0.DO)                                          
!C       (FOR THE INITIAL CHOICES OF ARFT,ARFS,AND ARFN, USE             
!C        PARCOR (PARTIAL AUTOCORRELATION) OUTPUTS FOR THE               
!C        DEFAULT OPTION)                                                
!C               (SORDER SHOULD NOT BE GREATER THAN SPAN.)               
!C       RIGID:  CONTROLS THE RIGIDITY OF THE SEASONAL COMPONENT, MORE   
!C               RIGID SEASONAL WITH LARGER RIGID (1.0)                  
!C               (TO BE ADJUSTED ONLY AFTER THE SELECTION OF ORDER AND   
!C                SORDER)                                                
!C       YEAR:   TRADING-DAY ADJUSTMENT OPTION  (0)                      
!C        IF(YEAR .EQ. 0) WITHOUT TRADING-DAY ADJUSTMENT                 
!C        IF(YEAR .NE. 0) WITH TRADING-DAY ADJUSTMENT                    
!C         NOTE: THE SERIES IS SUPPOSED TO START AT THIS 'YEAR'          
!C       MONTH:  NUMBER OF THE MONTH IN WHICH THE SERIES STARTS (1)      
!C        IF(YEAR .EQ. 0) THIS PARAMETER IS IGNORED                      
!C       WTRD:   CONTROLS THE ADAPTIVITY OF THE TRADING-DAY-COMPONENT    
!C               MORE DATA-ADAPTIVE WITH SMALLER WTRD (1.0)              
!C       IOUTD: OUTLIER CORRECTION OPTION (0)                            
!C        IF(IOUTD .EQ. 0) WITHOUT OUTLIER DETECTION                     
!C        IF(IOUTD .EQ. 1) WITH OUTLIER DETECTION BY MARGINAL PROBABILITY
!C        IF(IOUTD .EQ. 2) WITH OUTLIER DETECTION BY MODEL SELECTION     
!C         (NOTE: OUTLIER DETECTION IS                                   
!C                EXPENSIVE. DECLARING ABNORMAL OBSERVATIONS AS MISSING  
!C                BY RLIM IS MUCH CHEAPER)                               
!C       SPEC:  SPECTRUM ESTIMATION OPTION (1)                           
!C        IF(SPEC .EQ. 0) NO SPECTRUM                                    
!C        IF(SPEC .EQ. 1) SPECTRA OF IRREGULAR AND                       
!C                         DIFFERENCED ADJUSTED                          
!C         (IF THERE ARE MISSING OBSERVATIONS, SPECTRA OF THE            
!C          INTERPOLATED DATA ARE GIVEN)                                 
!C       PUNCH:  CARD OUTPUT CONTROL (0)                                 
!C        IF(PUNCH .EQ. 0) OUTPUT SUPRESSED                              
!C        IF(PUNCH .EQ. 1) CARD OUTPUT AVAILABLE                         
!C                                                                       
!C      --- PARAMETERS BELOW THIS LINE ARE SELDOM TO BE MODIFIED ---     
!C                                                                       
!C       ZERSUM: CONTROLS THE SUM OF THE SEASONALS WITHIN A PERIOD,      
!C               CLOSER TO ZERO WITH LARGER ZERSUM (1.0)                 
!C       DELTA:  CONTROLS THE LEAP YEAR EFFECT (7.0)                     
!C       ALPHA:  CONTROLS PRIOR VARIANCE OF INITIAL TREND (0.01D0)       
!C       BETA:   CONTROLS PRIOR VARIANCE OF INITIAL SEASONAL             
!C               (0.01D0)                                                
!C       GAMMA:  CONTROLS PRIOR VARIANCE OF INITIAL SUM OF SEASONAL      
!C               (0.01D0)                                                
!C                                                                       
!C     THE FOLLOWING PROCEDURE OF PARAMETER MODIFICATION IS RECOMMENDED  
!C     FOR USUAL APPLICATIONS:                                           
!C     FIRST TRY THE COMBINATION(ORDER=2,SORDER=1). IF NECESSARY, TRY    
!C     (ORDER=2,SORDER=2). THEN TRY A REDUCED VALUE OF 'RIGID' AND CHECK 
!C     ABIC. WHEN 'RIGID' IS SUITABLY CHOSEN, USUALLY SHALLOW TROUGHS    
!C     APPEAR AT FRIQUENCIES MARKED BY '---X' ON THE CHARTS OF SPECTRA.  
!C                                                                       
!C     TO MODIFY THE PARAMETERS FOLLOW THE FOLLOWING EXAMPLE:            
!C       IF THE USER WANTS TO SET SORDER=2,RIGID=0.5 AND SO ON, AND IF   
!C       MT IS CARD READER, PLACE THE CARDS WHICH CONTAIN THE FOLLOWING  
!C       THREE TYPES OF STATEMENTS ON TOP OF THE INPUT DATA( PUNCH ONE   
!C       SPACE AT THE FIRST COLUMN OF EACH CARD) :                       
!C  &PARAM  (ON THE FIRST CARD)                                          
!C  SORDER=2, RIGID=0.5, AND SO ON, (ON THE SECOND AND LATER CARDS)      
!C  &END  (ON THE LAST CARD)                                             
!C     NOTE THE COMMA AT THE END OF EACH PARAMETER SPECIFICATION.        
!C                                                                       
!C     INPUT DATA:                                                       
!C                                                                       
!C     THE FOLLOWING DATA SET SHOULD BE FED THROUGH THE INPUT DEVICE     
!C     SPECIFIED BY MT IN THE FORMATS SHOWN IN THE PARENTHSES.           
!C                                                                       
!C     TITLE (20A4):   TITLE OF THE DATA                                 
!C     NDATA (I5):     DATA LENGTH                                       
!C     FORMAT SPECIFICATION OF DATA (20A4): FOR EXAMPLE, (4D20.10)       
!C     DATA:       Y(I);I=1,NDATA                                        
!C                                                                       
!C     NUMERICAL OUTPUTS:                                                
!C       OCF:    OUTLIER CORRECTION FACTOR                               
!C       TREND:  ESTIMATED TREND                                         
!C       SEASONAL: ESTIMATED SEASONAL                                    
!C       TDCMP: ESTIMATED TRADING-DAY COMPONENT                          
!C       IRREGULAR = 0.0        (IF OBSERVATION IS MISSING)              
!C                 = ORIGINAL DATA - TREND - SEASONAL - TDCMP - OCF      
!C                              (OTHERWISE)                              
!C       ADJUSTED = TREND + IRREGULAR                                    
!C       SMOOTHED = TREND + SEASONAL + TDCMP                             
!C                                                                       
!C     GRAPHICAL OUTPUTS:                                                
!C       ORIGINAL DATA                                                   
!C       OCF                                                             
!C       TREND                                                           
!C       SEASONAL                                                        
!C       IRREGULAR                                                       
!C       ADJUSTED                                                        
!C       SMOOTHED                                                        
!C       TDCMP                                                           
!C       MISSING OBSERVATION INTERPOLATED DATA                           
!C       SPECTRA OF IRREGULAR AND DIFFERENCED ADJUSTED                   
!C                                                                       
!C     WORKING AREA REQUIRED BY THIS PROGRAM:                            
!C     VECTORS:                                                          
!C       Y(IY)                                                           
!C       TREND(IRSLT)                                                    
!C       SEASON(IRSLT)                                                   
!C       EST(IRSLT)                                                      
!C       IRREG(IRSLT)                                                    
!C       TDCMP(IRSLT)                                                    
!C       ADJUST(IRSLT)                                                   
!C       CDATA(IRSLT)                                                    
!C       DMOI(IRSLT)                                                     
!C       FTRN(IA)                                                        
!C       FSEA(IA)                                                        
!C       YS(IA)                                                          
!C       YS1(IA)                                                         
!C       YO(IA)                                                          
!C       DC(MDC)                                                         
!C       H2(8*IA)                                                        
!C       WEEK(7*IA)                                                      
!C   WHERE                                                               
!C    IY = MAXIMUM DATA LENGTH                                           
!C    IRSLT = MAXIMUM OUTPUT LENGTH                                      
!C    IA = ( MAXIMUM DATA LENGTH WITHIN A SPAN)                          
!C                                                                       
!C   STRUCTURE OF THE PROGRAM                                            
!C                                                                       
!C   ****************00002150
!C   *              *00002160
!C   *    BAYSEA    *00002170
!C   *              *00002180
!C   ********I*******00002190
!C           I                                                           
!C           I-ARCOEF---PARTAR                                           
!C           I                                                           
!C           I----------------------------DSQRT                          
!C           I                                                           
!C           I-DATAR ------------DLOG                                    
!C           I                                                           
!C           I-------------------DLOG                                    
!C           I                                                           
!C           I-------------------COPY                                    
!C           I                                                           
!C           I-CALEND------------MOD                                     
!C           I                                                           
!C           I-SUBSEA-+-------------------DSQRT                          
!C           I        I                                                  
!C           I        I-SETDC -+-SETD  ---MIN0                           
!C           I        I        I                                         
!C           I        I        I-INIT                                    
!C           I        I        I                                         
!C           I        I        +-EXHSLD                                  
!C           I        I                                                  
!C           I        I-------------------DABS                           
!C           I        I                                                  
!C           I        I----------DLOG                                    
!C           I        I                                                  
!C           I        I-SETX  -+-HUSHLD-+-DABS                           
!C           I        I        I        I                                
!C           I        I        I        +-DSQRT                          
!C           I        I        I                                         
!C           I        I        I----------DABS                           
!C           I        I        I                                         
!C           I        I        I-DLOG                                    
!C           I        I        I                                         
!C           I        I        I-SETD  ---MIN0                           
!C           I        I        I                                         
!C           I        I        I-INIT                                    
!C           I        I        I                                         
!C           I        I        I-EXHSLD                                  
!C           I        I        I                                         
!C           I        I        +-MOD                                     
!C           I        I                                                  
!C           I        I-SOLVE                                            
!C           I        I                                                  
!C           I        I-DECODE-+-CLEAR                                   
!C           I        I        I                                         
!C           I        I        I----------DSQRT                          
!C           I        I        I                                         
!C           I        I        I-COPY                                    
!C           I        I        I                                         
!C           I        I        I-PRDCT                                   
!C           I        I        I                                         
!C           I        I        I-ADD                                     
!C           I        I        I                                         
!C           I        I        +-SBTRCT                                  
!C           I        I                                                  
!C           I        +-DEXP                                             
!C           I                                                           
!C           I-------------------SBTRCT                                  
!C           I                                                           
!C           I-OUTLIR-+-SRTMIN                                           
!C           I        I                                                  
!C           I        I----------DLOG                                    
!C           I        I                                                  
!C           I        I----------DFLOAT                                  
!C           I        I                                                  
!C           I        I----------BINARY                                  
!C           I        I                                                  
!C           I        I-LKOUT1-+-DFLOAT                                  
!C           I        I        I                                         
!C           I        I        I-DLOG                                    
!C           I        I        I                                         
!C           I        I        I-POOLAV                                  
!C           I        I        I                                         
!C           I        I        I----------DSQRT                          
!C           I        I        I                                         
!C           I        I        +-PERMUT---ISORT                          
!C           I        I                                                  
!C           I        I-DEXP                                             
!C           I        I                                                  
!C           I        I-PRPOST---BINARY                                  
!C           I        I                                                  
!C           I        +-MODIFY---BINARY                                  
!C           I                                                           
!C           I-------------------ADD                                     
!C           I                                                           
!C           I----------DEXP                                             
!C           I                                                           
!C           I-DFR1                                                      
!C           I                                                           
!C           I-GRAPH -+-LOG10                                            
!C           I        I                                                  
!C           I        I-SQRT                                             
!C           I        I                                                  
!C           I        I-------------------ABS                            
!C           I        I                                                  
!C           I        I----------MOD                                     
!C           I        I                                                  
!C           I        +-DEXP                                             
!C           I                                                           
!C           +-SPGRH -+-------------------MIN0                           
!C                    I                                                  
!C                    I-SAUTCO-+-SMEADL---SUMF                           
!C                    I        I                                         
!C                    I        I-CROSCO---DBLE                           
!C                    I        I                                         
!C                    I        +-CORNOM---DSQRT                          
!C                    I                                                  
!C                    I-------------------DSQRT                          
!C                    I                                                  
!C                    I-SICP2 -+-DLOG                                    
!C                    I        I                                         
!C                    I        +----------DSQRT                          
!C                    I                                                  
!C                    +-SNRASP-+-FOUGER-+-DCOS                           
!C                             I        I                                
!C                             I        +-DSIN                           
!C                             I                                         
!C                             I-SUBVCP                                  
!C                             I                                         
!C                             I-DLOG10                                  
!C                             I                                         
!C                             I-DSP3  -+-AMAX                           
!C                             I        I                                
!C                             I        I-ABS                            
!C                             I        I                                
!C                             I        +-AMIN                           
!C                             I                                         
!C                             +-MOD                                     
!C                                                                       

          INTEGER(kind=i4) :: NDATA, FOCAST, IART, IARS, IARN
          INTEGER(kind=4), dimension(12) :: IPARA(12) 
          REAL(kind=8), dimension(NDATA)  :: Y,CDATA,DMOI,IRREG,ADJUST
          REAL(kind=8), dimension(NDATA+FOCAST) :: TREND,SEASON,TDCMP,EST,PSDS,PSDT
          REAL(kind=8), dimension(8) :: PARA
          REAL(kind=8), dimension(3) :: ARFT,ARFS,ARFN
          !DIR$ ASSUME_ALIGNED IPARA:64
          !DIR$ ASSUME_ALIGNED Y:64, CDATA:64, DMOI:64, IRREG:64, ADJUST:64
          !DIR$ ASSUME_ALIGNED TREND:64, SEASON:64, TDCMP:64, EST:64, PSDS:64, PSDT:64
          !DIR$ ASSUME_ALIGNED PARA:64
          REAL(kind=8) :: AVABIC
    

          INTEGER(kind=4) :: ORDER, SORDER, PERIOD, SPAN, OVLAP, HEAD, SHIFT,     &
                       TAIL, YEAR, SPEC
          REAL(kind=8), dimension(NDATA+FOCAST) :: TREND0, SEAS0, TDCMP0,IRREG0,ADJ0,EST0,
                                             PSDS0,PSDT0
!DIR$ ATTRIBUTES ALIGN : 64 :: TREND0,SEAS0,TDCMP0,IRREG0,ADJ0,EST0,PSDS0,PSDT0
          REAL(kind=8), dimension(IPARA(4)+2) :: FTRN
          REAL(kind=8), dimension((IPARA(5)+3)*IPARA(1)+3) :: FSEA
          REAL(kind=8), dimension(NDATA+FOCAST+1) :: F
          REAL(kind=8), dimension(7,NDATA+FOCAST) :: WEEK
          REAL(kind=8), dimension(NDATA) :: YS,YS1,YO
!DIR$ ATTRIBUTES ALIGN : 64 :: FTRN,FSEA,F,WEEK,YS,YS1,YSO
          REAL(kind=8) ::   RLIM, RIGID,  WTRD, DD, ZERSUM, DELTA, ALPHA, BETA, GAMMA,  &
                          AP, ZER, SMTH, SMTH2, ROUT, SY, YTEM, COUNT,                &
                          ABIC,AN
          INTEGER(kind=4) :: NPF, LOGT, MONTH, NDAY, IOUTD, IDC, IS, LFTRN, LFSEA, NH, N2,  &
                           I, NF, OVLAP, LIMIT, IQ, N, IEND, ICNT1, ICNT, NEXT, LINKT,    &
                           LINKS, ITRN, IOUT, NTEM, L, LF, I1, ISTEM, I2
                                                            
          NPF = NDATA+FOCAST                                                
                                                      
          RLIM = 0.0_8                                                      
                                                       
          PERIOD=IPARA(1)
          SPAN=IPARA(2)
          SHIFT=IPARA(3)
          ORDER=IPARA(4)
          SORDER=IPARA(5)
          LOGT=IPARA(6)
          YEAR=IPARA(7)
          MONTH=IPARA(8)
          NDAY=IPARA(9)
          SPEC=IPARA(10)
          IOUTD=IPARA(11)
          IDC=IPARA(12)
          RIGID=PARA(1)
          WTRD=PARA(2)
          DD = PARA(3)
          ZERSUM=PARA(4)
          DELTA=PARA(5)
          ALPHA=PARA(6)
          BETA=PARA(7)
          GAMMA=PARA(8)

          IF(   SORDER .GT. SPAN ) SORDER = SPAN                            
                           
          IS = PERIOD*SORDER                                                
          AP=PERIOD                                                         
                                          
          LFTRN = ORDER + IART                                              
          LFSEA = (SORDER + IARS)*PERIOD + IARN                             

          NH= LFSEA + 1                                                     
          N2=1                                                              
          IF(YEAR .NE. 0) N2=8                                              
!C  ************                                                         
          ZER=ZERSUM/DSQRT(AP)*RIGID                                        
          SMTH = 1._dp/RIGID                                                 
          SMTH2=1._dp                                                        
!C  ************                                                         

          IF(IOUTD .EQ. 0) GO TO 1212                                       
          ROUT = 1.0E+60_8                                                     
          RLIM = 1.0E+50_8                                                      
          IF(LOGT .EQ. 0) GO TO 1212                                        
          ROUT = DLOG(ROUT)                                                 
          RLIM = DLOG(RLIM)                                                 
          !c-----
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 20 I=1,NDATA
!cxx   20 Y(I) = DLOG(Y(I))
                Y(I) = DLOG(Y(I))
       20 CONTINUE
!c-----
 1212   CONTINUE                                                          
                                                               
!C     INITIALIZATION                                                    
          NF=ORDER                                                          
          IF(PERIOD.GT.1.AND.NF.LT.IS) NF=IS                                 
!cc      WRITE(6,606)                                                      
!cc  606 FORMAT(1H ,'INITIALIZATION'    )                                  
!C     N=LENGTH OF A SPAN                                                
          OVLAP = SPAN - 1                                                  
          LIMIT = NDATA - OVLAP*PERIOD                                      
          SY = 0._8                                                        
!c-----
          IQ = 0
!c-----
          DO 2468 I=1,NDATA                                                 
                  YTEM = Y(I)                                                       
                  IF(RLIM .LE. 0._8) GO TO 4681                                     
                  IF(YTEM .GE. RLIM) GO TO 2468                                     
 4681             IQ = IQ + 1                   
                  SY = SY + YTEM                                                    
                  IF(IQ .GE. PERIOD) GO TO 4680                                     
   2468    CONTINUE                                                          
 4680 CONTINUE                                                          
           YTEM = SY / AP
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))                  
          DO 8  I=1,LFTRN                                                   
!cxx    8 FTRN(I) = YTEM                                                    
                FTRN(I) = YTEM
       8 CONTINUE
         IF(LFSEA .EQ. 0) GO TO 998                                        
!cxx      DO 9  I=1,LFSEA                                                   
!cxx    9 FSEA(I) = 0.D0
          FSEA(1:LFSEA) = 0._8                                                  
     998 CONTINUE                                                          
          N = (SPAN*2-1)*PERIOD                                             
          AVABIC  = 0._8                                               
          COUNT   = 0._8                                                      
          IEND = 0                                                          
!C                                                                       
!C     ***************                                                   
!C     **           **                                                   
!C     ** MAIN LOOP **                                                   
!C     **           **                                                   
!C     ***************                                                   
!C     ICNT0: ITERATION CONTROL FOR THE 0-TH SPAN                        
          !C
#if (LOOP_DISTRIBUTE_POINT) == 1
          !DIR$ DISTRIBUTE POINT
#endif
          DO 1000  ICNT1=1,1000                                             
!C                                                                       
!C     MANIPULATION OF THE ICNT-TH SPAN                                  
!C                                                                       
                   ICNT = ICNT1-1                                                    
!C                                                                       
!C     DATA END DETECTION                                                
!C                                                                       
!C     --------------------                                              
                   HEAD = 1 + (ICNT1-2)*SHIFT*PERIOD+SPAN*PERIOD                     
                   IF(ICNT1 .EQ. 1) HEAD=1                                           
                   IF( ICNT . LE. 0 )   GO TO 2345                                   
!C     --------------------                                              
!C     HEAD: INITIAL POINT OF THE NEW SPAN                               
                   IF(HEAD.LE.LIMIT)   GO TO 2345                                    
                   GO TO 1234                                                        
!C     NEW SPAN                                                          
 2345      CONTINUE                                                          
!C     TAIL: END POINT OF THE NEW SPAN                                   
                   TAIL = HEAD+N-1                                                   
                   IF( TAIL .GT. NDATA )   N = NDATA-HEAD+1                          
                   TAIL = HEAD + N-1                                                 
!C     --------------------                                              
                   IF( TAIL .EQ. NDATA )   IEND = 1                                  
!C     IEND=1: LAST SPAN IN NORMAL ITERATION                             
!C      --------------------                                             

                   CALL BCOPY(YO     ,N,1,1,1,Y     ,N,1,HEAD,1)
!C                                                                       
!C     INITIALIZATION FOR THE INNER LOOP SUBSEA                          
!C                                                                       
!cxx 6789 CONTINUE                                                          
                   IF(YEAR .NE. 0) CALL CALEND(WEEK,YEAR,MONTH+HEAD-1,N+FOCAST)      
               
                   NEXT = HEAD + N                                                   
                   IF( IEND .EQ. 0 ) NEXT = NEXT - OVLAP*PERIOD                      
                   LINKT = NEXT - LFTRN                                              
                   LINKS = NEXT - LFSEA                                              
!C     --------------------                                              
!C     DO SEARCH CONTROL                                                 
                   ITRN = ICNT1                                                      
!C     --------------------                                              
                   IOUT=0                                                            

                   CALL BCOPY(YS,N,1,1,1,YO, N,1,1,1)
 9700       CONTINUE                                                          
!C     SEASONAL DECOMPOSITION OF ICN-TH LOCAL SPAN                       
                  CALL SUBSEA(ABIC,SEAS0,TREND0,EST0,ADJ0,IRREG0,TDCMP0,                             &      
                              FSEA,LFSEA,FTRN,YS,N,FOCAST,RLIM,WEEK,IDC,NH,F,N2,ITRN,                &
                              IARS,ARFS,IART,ARFT,IARN,ARFN,PSDT0,PSDS0,NPF,                         &
                              PERIOD,ORDER,SORDER,YEAR,NDAY,LOGT,                                    &
                              ALPHA,BETA,GAMMA,ZER,SMTH,SMTH2,DD,WTRD,DELTA)                                                                
                         
                  IF(IOUTD .EQ. 0) GO TO 9600
                  IF(IOUT  .GE. 2)  GO TO 9600
                  CALL SBTRCT(IRREG0,N,YO,N,EST0,N)                                 
!cc      CALL OUTLIR(IRREG0,N,10,2,1,YS1,RLIM) 
                  CALL OUTLIR(IRREG0,N,10,2,1,YS1,RLIM,IOUTD,ROUT)
                  IOUT=IOUT+1                                                       
                  CALL ADD(YS,N,EST0,N,YS1,N)                                       
!cc      IF(IOUT .EQ. 2) CALL COPY(YS1,N,1,N,1,1, YS,N,1,N,1,1)     
!cxx      IF(IOUT .EQ. 2) CALL BCOPY(YS1,N,1,N,1,1, YS,N,1,N,1,1)
                  IF(IOUT .EQ. 2) CALL BCOPY(YS1,N,1,1,1, YS,N,1,1,1)
                  IF(IOUT .NE. 1) GO TO 9700                                        
                  NTEM = N+1                                                        
                  DO 9702 I=1,ORDER                                                 
                          NTEM=NTEM-1                                                       
!cxx 9702 YS(NTEM)=ROUT                                                     
                          YS(NTEM)=ROUT
    9702          CONTINUE
                  GO TO 9700                                                        
 9600      CONTINUE                                                          
!C                                                                       
!C                                                                       
!C     RECORDING THE BEST RESULT                                         
!C                                                                       
                  L=NEXT - HEAD                                                     
                  LF=L+FOCAST                                                       

                  CALL BCOPY(PSDT,LF,1,HEAD,1,PSDT0,LF,1,1,1)
                  CALL BCOPY(PSDS,LF,1,HEAD,1,PSDS0,LF,1,1,1)
                  CALL BCOPY(SEASON,LF,1,HEAD,1,SEAS0,LF,1,1,1)
                  CALL BCOPY(TREND,LF,1,HEAD,1,TREND0,LF,1,1,1)
                  CALL BCOPY(EST,LF,1,HEAD,1,EST0,LF,1,1,1)
                  CALL BCOPY(ADJUST,L,1,HEAD,1,ADJ0,L,1,1,1)
                  CALL BCOPY(IRREG,L,1,HEAD,1,IRREG0,L,1,1,1)
                  CALL BCOPY(TDCMP,LF,1,HEAD,1,TDCMP0,LF,1,1,1)
                  CALL BCOPY(CDATA,L,1,HEAD,1,YS1,L,1,1,1)
                  AN = N                                                            
                  AVABIC = AVABIC + ABIC                                            
                  COUNT = COUNT + AN                                                
!C                                                                       
!C                                                                       
!C     INITIAL VALUES FOR THE NEXT SPAN                                  
!C                                                                       
                  IF(IEND .EQ. 1) GO TO 1234                                        
                                                        
                  CALL  BCOPY( FTRN,LFTRN,1,1,1,TREND,LFTRN,1,LINKT,1)                                                         
                  ISTEM = LFSEA                                                     
                  IF(LINKS .GE. 1) GO TO 1111                                       
                  LINKS=1-LINKS                                                     
                  ISTEM=ISTEM-LINKS                                                 
                  I1=LFSEA+1                                                        
                  DO 2222 I=1,LINKS                                                 
                          I1=I1-1                                                           
                          I2=I1-ISTEM                                                       
!cxx 2222 FSEA(I1)=FSEA(I2)                                                 
                          FSEA(I1)=FSEA(I2)
 2222        CONTINUE
                   LINKS=1                                                           
 1111   CONTINUE                                                          
!cc      CALL COPY(FSEA,ISTEM,1,ISTEM,1,1,SEASON,ISTEM,1,IOUT,LINKS,1)     
!cxx      CALL BCOPY(FSEA,ISTEM,1,ISTEM,1,1,SEASON,ISTEM,1,IOUT,LINKS,1)
                  CALL BCOPY(FSEA,ISTEM,1,1,1,SEASON,ISTEM,1,LINKS,1)
                  IF(ICNT1 .GT. 1) GO TO 1000                                       
                  ALPHA = 1._dp                                                   
                  BETA = 1._dp                                                       
                  GAMMA = 1._dp                                                      
                  N = SPAN*PERIOD                                                   
                  IF(N .GT. NDATA) N=NDATA                                          
                  OVLAP = SPAN-SHIFT                                                
                  LIMIT = NDATA-OVLAP*PERIOD                                        
 1000 CONTINUE                                                          
!C     ************************                                          
!C     *                      *                                          
!C     * END OF THE MAIN LOOP *                                          
!C     *                      *                                          
!C     ************************                                          
!C                                                                       
 1234 CONTINUE                                                          
!C                                                                       
!C     NUMERICAL OUTPUTS                                                 
!C                                                                       
           DO 4444 I=1,NDATA                                                 
                      CDATA(I)=Y(I) - CDATA(I)                                          
                      DMOI(I) = Y(I)                                                    
                      IF(RLIM .LE. 0._8) GO TO 4444                                     
                      IF(Y(I) .LT. RLIM.AND.IOUTD.EQ.0) GO TO 4444                      
                      IF(IOUTD .NE. 0 .AND. Y(I) .GT. RLIM) GO TO 4442                  
                      IF(IOUTD.NE.0.AND.-CDATA(I).LT.RLIM)GO TO 4443                    
 4442     CONTINUE                                                          
                      ADJUST(I)=TREND(I)                                                
                      DMOI(I)=EST(I)                                                    
                      IRREG(I)=0._8                                                  
 4443                 CDATA(I) = Y(I) - DMOI(I)                                         
 4444 CONTINUE                                                          
!cc      NPF = NDATA+FOCAST                                                
            IF(LOGT .EQ. 0) GO TO 1250                                        
            DO 1240 I=1,NPF                                                   
                    TREND(I) = DEXP(TREND(I))                                         
                    SEASON(I) = DEXP(SEASON(I))                                       
                    EST(I) = DEXP(EST(I))                                             
                    TDCMP(I) = DEXP(TDCMP(I))                                         
                    IF(I .GT. NDATA) GO TO 1240                                       
                    IRREG(I) = DEXP(IRREG(I))                                         
                    Y(I) = DEXP(Y(I))                                                 
                    ADJUST(I) = DEXP(ADJUST(I))                                       
                    CDATA(I) = DEXP(CDATA(I))                                         
                    DMOI(I) = DEXP(DMOI(I))                                           
 1240      CONTINUE                                                          
           IF(RLIM .GT. 0.0_8) RLIM = DEXP(RLIM)                              
 1250      CONTINUE                                                          
                                                          
           AVABIC = AVABIC/COUNT                                             
           AVABIC = AVABIC*NDATA                                             
              
    END  SUBROUTINE
                         
    SUBROUTINE  ADD(X,MX,Y,MY,Z,MZ) 
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: ADD
!C     THIS SUBROUTINE COMPUTES                                          
!C          X = Y + Z.                                                   
!C     INPUTS:                                                           
!C       X:     MX-VECTOR                                                
!C       Y:     MY-VECTOR                                                
!C       Z:     MZ-VECTOR                                                
!C                                                                       
                                      
          INTEGER(kind=4) :: MX, MY, MZ
          REAL(kind=8) :: TEM
          REAL(kind=8), dimension(MX) :: X
          REAL(kind=8), dimension(MY) :: Y
          REAL(kind=8), dimension(MZ) :: Z
          !DIR$ ASSUME_ALIGNED X:64, Y:64, Z:64
      ! Locals
          INTEGER(kind=int4) :: I
      ! Exec code ....
          DO 100 I=1,MX                                                     
             TEM = 0._8                            
             IF( I .LE. MY )  TEM = Y(I)                                       
             IF( I .LE. MZ )  TEM = TEM + Z(I)                                 
!cxx  100 X(I) = TEM
             X(I) = TEM
  100 CONTINUE                                                        
                                                              
    END   SUBROUTINE
    
    SUBROUTINE CLEAR(X,M,N,MJ,I0,J0)   
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: CLEAR
!C                                                                       
!C     THIS SUBROUTINE CLEARS MATRIX X.                                  
!C     INPUTS:                                                           
!C       X:     M*N MATRIX                                               
!C       MJ:    ABSOLUTE DIMENSION OF X                                  
!C       I0:    ABSOLUTE POSITION OF THE FIRST ROW OF X                  
!C       J0:    ABSOLUTE POSITION OF THE FIRST COLUMN OF X               
!C                                                                       
                                              
          INTEGER(kind=4) :: N, MJ, I0, J0, M
          REAL(kind=8), dimension(MJ,I0+N-1) :: X
          !DIR$ ASSUME_ALIGNED X:64
          ! Locals
          INTEGER(kind=dp) :: I0M1,J0M1,J,I
          I0M1 = I0 - 1                                                     
          J0M1 = J0 - 1                                                     

          DO 20 J=1,N
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))             
             DO 10 I=1,M                                                       

                X(I0M1+I,J0M1+J) = 0.0_8
          10 CONTINUE
   20 CONTINUE
                                                             
    END    SUBROUTINE
    

    SUBROUTINE BCOPY(X,MX,NX,IX,JX,Y,MY,NY,IY,JY)
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: BCOPY
!C     THIS SUBROUTINE COPIES Y INTO X.                                  
!C     INPUTS:                                                           
!C       X:     MX*NX MATRIX                                             
!C       MMX:   ABSOLUTE DIMENSION OF X                                  
!C       IX:    ABSOLUTE POSITION OF THE FIRST ROW OF X                  
!C       JX:    ABSOLUTE POSITION OF THE FIRST COLUMN OF X               
!C       Y:     MY*NY MATRIX                                             
!C       MMY:   ABSOLUTE DIMENSION OF Y                                  
!C       IY:    ABSOLUTE POSITION OF THE FIRST ROW OF Y                  
!C       JY:    ABSOLUTE POSITION OF THE FIRST COLUMN OF Y               
!C                                                                       

          INTEGER(kind=4) :: MX, NX, IX, JX, MY, NY, IY, JY
          REAL(kind=8) :: TEM
          REAL(kind=8), dimension(MX+IX-1,JX+NX-1) :: X 
          REAL(kind=8), dimension(MY+IY-1,NY+JY-1) :: Y
          !DIR$ ASSUME_ALIGNED X:64, Y:64
          ! Locals
          INTEGER(kind=int4) :: IXM1,IYM1,JYM1,JXM1,J,I
          IXM1 = IX-1                                                       
          JXM1 = JX - 1                                                     
          IYM1 = IY - 1                                                     
          JYM1 = JY - 1                                                   
                                                            
          DO 100 J=1,NX  
             DO 60 I=1,MX                                                      
                      TEM = 0._8                                                     
                      IF( I .GT. MY ) GO TO 50                                          
                      IF( J .GT. NY ) GO TO 50                                          
                      TEM = Y(IYM1+I,JYM1+J)                                            
    50                X(IXM1+I,JXM1+J) = TEM
            60 CONTINUE                            
  100 CONTINUE                                                          
                                                               
    END  SUBROUTINE
    
    SUBROUTINE DECODE(SEAS0,TREND0,EST0,ADJ0,IRREG0,TDC0,W,    &       
                         A,Y,NN,NF,WEEK,ERR,PSDS,PSDT,SQE, IP,YEAR,NDAY)      
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: DECODE
!C   THIS SUBROUTINE COMPUTES                                            
!C       TREND0                                                          
!C       SEAS0                                                           
!C       EST0=TREND0 + SEAS                                              
!C       ADJ0=Y - SEAS0                                                  
!C       IRREG0=Y - EST0                                                 
!C                                                                       

          INTEGER(kind=4) :: NN, NF, IP, YEAR, NDAY
          REAL(kind=8) ::  SQE, SD2
          REAL(kind=8), dimension(NN+NF) :: SEAS0, TREND0, EST0, ADJ0, IRREG0, TDC0, PSDS, PSDT
          REAL(kind=8), dimension(NDAY+6) :: W
          REAL(kind=8), dimension(2*(NN+NF)+NDAY+6) :: A
          REAL(kind=8), dimension(NN) :: Y
          REAL(kind=8), dimension(7,NN+NF) :: WEEK
          REAL(kind=8), dimension(2*(NN+NF)) :: ERR
          !DIR$ ASSUME_ALIGNED SEAS0:64
          !DIR$ ASSUME_ALIGNED TREND0:64
          !DIR$ ASSUME_ALIGNED EST0:64
          !DIR$ ASSUME_ALIGNED ADJ0:64
          !DIR$ ASSUME_ALIGNED IRREG0:64
          !DIR$ ASSUME_ALIGNED TDC0:64
          !DIR$ ASSUME_ALIGNED PSDS:64
          !DIR$ ASSUME_ALIGNED PSDT:64
          !DIR$ ASSUME_ALIGNED W:64
          !DIR$ ASSUME_ALIGNED A:64
          !DIR$ ASSUME_ALIGNED Y:64
          !DIR$ ASSUME_ALIGNED WEEK:64
          !DIR$ ASSUME_ALIGNED ERR
          ! Locals
          INTEGER(kind=4) :: N,NR,I,I1,I2,NTEM,N7
                                                                       
          N=NN+NF                                                           
          NR = 2                                                            
          IF( IP .EQ. 1 )   NR = 1                                          
          CALL  CLEAR( SEAS0,N,1,N,1,1 )                                    
          CALL  CLEAR( PSDS,N,1,N,1,1)                                      
          SD2 = DSQRT(SQE) * 2._8                                       
          DO 10 I=1,N                                                       
                  I1=NR*(I-1)+1                                                     
                  I2=NR*I                                                           
                  TREND0(I)=A(I1)                                                   
                  PSDT(I)=DSQRT(ERR(I1))*SD2                                        
                  IF(IP .LE. 1) GO TO 10                                            
                  SEAS0(I)=A(I2)                                                    
                  PSDS(I)=DSQRT(ERR(I2))*SD2                                        
   10     CONTINUE                                                          
          IF(YEAR .EQ. 0) GO TO 20                                          
          NTEM = N*2+1                                                      
          N7 = 6 + NDAY                                                     

          CALL BCOPY(W,N7,1,1,1,A,N7,1,NTEM,1)
          CALL PRDCT(TDC0,1,N,1,W,1,N7,1,WEEK,N7,N,7)                      
   20     CONTINUE                                                          
          CALL ADD(EST0,N,TREND0,N,SEAS0,N)                                 
          IF(YEAR .NE. 0) CALL ADD(EST0,N,EST0,N,TDC0,N)
!cxx      CALL SBTRCT(ADJ0,N,Y,N,SEAS0,N)
          CALL SBTRCT(ADJ0,N,Y,NN,SEAS0,N)
          IF(YEAR .NE. 0) CALL SBTRCT(ADJ0,N,ADJ0,N,TDC0,N)                 
!cxx      CALL SBTRCT(IRREG0,N,Y,N,EST0,N)                                  
          CALL SBTRCT(IRREG0,N,Y,NN,EST0,N)                                  
                                                         
    END  SUBROUTINE
                         
                            
    SUBROUTINE  BHUSHLD( X,N,K,MJ1,ICNT )
          !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: BHUSHLD
!C                                                                       
!C                                                                       
!C     THIS SUBROUTINE  TRANSFORMS MATRIX X INTO AN UPPER TRIANGULAR FORM
!C     BY HOUSEHOLDER TRANSFORMATION.                                    
!C                                                                       
!C       INPUTS:                                                         
!C          X:     ORIGINAL N*K DATA MATRIX                              
!C          MJ1:   ABSOLUTE DIMENSION OF X                               
!C          N:  NUMBER OF ROWS OF X, NOT GREATER THAN MJ1                
!C          K:     NUMBER OF COLUMNS OF X. NOT GREATER THAN MJ1          
!C          ICNT:  =0  WHEN X IS A FULL N*K MATRIX                       
!C                 =L (L.NE.0) WHEN X IS COMPOSED OF TWO UPPER TRIANGULAR
!C                             MATRICES. L SHOULD BE EQUAL TO THE NUMBER 
!C                             OF NON ZERO ROWS OF THE SECOND MATRIX.    
!C                             SECOND MATRIX MUST BE ROTATED AND STORED  
!C                             AT THE BOTTOM LEFT PART OF THE FIRST      
!C                             MATRIX.                                   
!C       OUTPUT:                                                         
!C          X:     IN UPPER TRIANGULAR FORM                              
!C                                                                       

          INTEGER(kind=4) :: N, K, MJ1, ICNT
          REAL(kind=8), dimension(MJ1,K) :: X
          !DIR$ ASSUME_ALIGNED X:64
          ! Locals
          INTEGER(kind=4) :: MNK,I,II,IIOTEM,IITEM,II1,KTEM,II10,JTEM
          REAL(kind=8) :: TOL, DIIO, H, ABSLD, F, G, S
          REAL(kind=8), dimension(N) :: D 
!DIR$     ATTRIBUTES ALIGN : 64 :: DC   
          
          TOL=1.0E-38_8                                                       
          DIIO=0.0_8
                                                                       
          MNK=K                                                             
          IF(N.LE.K) MNK=N-1                                                
                                                 
          DO 101 II=1,MNK 
                 H = 0.0_dp                                                     
                 IIOTEM = II                                                       
                 IITEM = II                                                        
                 IF( ICNT .LE. 0 )   GO TO 5                                       
                 H = X(II,II)*X(II,II)                                             
                 IITEM  = K+1-II                                                    
                 IIOTEM = N+1-II                                                   
           IF( IIOTEM .LE. N-ICNT )   IIOTEM = N-ICNT+1                      
5          CONTINUE
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))           
          DO 10  I=IIOTEM,N                                                 
                D(I) = X(I,IITEM)                                                 
                ABSLD=DABS(D(I))                                                  
                IF(ABSLD.LE.TOL) D(I)=0.0_8                                    
!cxx   10       H = H + D(I)*D(I)                                           
                H = H + D(I)*D(I)
   10       CONTINUE
          IF( H .GT. TOL )  GO TO 20                                     
          G = 0.0_8                                                  
          GO TO 100                                                      
   20     G = DSQRT( H )                                                 
          F=X(II,II)                                                        
          IF( F .GE. 0.0_8 )   G = -G                                   
          IF( ICNT .LE. 0 )   D(II) = F-G                                   
          IF( ICNT .GT. 0 )   DIIO = F-G                                    
          H = H - F*G                                                    
!C                                                                       
!C          FORM  (I - D*D'/H) * X, WHERE H = D'D/2                      
!C                                                                       
          II1 = IITEM+1                                                  
          KTEM = K                                                       
          IF( ICNT .LE. 0 )   GO TO 25                                   
          II1 = 1                                                        
          KTEM = IITEM-1                                                 
   25     CONTINUE                                                       
          II10 = II1                                                        
          IF( ICNT .GT. 0 )   II10 = IIOTEM
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 30 I=II10,N                                                    
!cxx   30 X(I,IITEM) = 0.D0                                                 
                X(I,IITEM) = 0._8
   30    CONTINUE
         IF( II .EQ. K )  GO TO 100                                     
         DO 60  J=II1,KTEM                                              
                S = 0.0_8                                                
                JTEM = K+1-J                                                   
                IF(ICNT .GT. 0 ) S = DIIO*X(II,JTEM)
!DIR$ SIMD REDUCTION(+:S)                
                DO 40  I=IIOTEM,N
                   
!cxx   40 S = S + D(I)*X(I,J)                                               
                   S = S + D(I)*X(I,J)
   40    CONTINUE
                S = S/H                                                     
                IF(ICNT .GT. 0) X(II,JTEM) = X(II,JTEM) - DIIO*S
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))                
          DO 50  I=IIOTEM,N                                                 
!cxx   50 X(I,J) = X(I,J) - D(I)*S
                 X(I,J) = X(I,J) - D(I)*S
     50  CONTINUE
   60 CONTINUE                                                       
  100    X(II,II) = G
  101 CONTINUE                                                      
                                                                       
    END SUBROUTINE
    
                                                                       
                                                                  
    SUBROUTINE  PRDCT(X,MX,NX,MMX,Y,MY,NY,MMY,Z,MZ,NZ,MMZ)  
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: PRDCT
!C     THIS SUBROUTINE COMPUTES                                          
!C          X = Y * Z                                                    
!C     INPUTS:                                                           
!C       X:     MX*NX MATRIX                                             
!C       MMX:   ABSOLUTE DIMENSION OF X                                  
!C       Y:     MY*NY MATRIX                                             
!C       MMY:   ABSOLUTE DIMENSION OF Y                                  
!C       Z:     MZ*NZ MATRIX                                             
!C       MMZ:   ABSOLUTE DIMENSION OF Z                                  
!C                                                                       

          INTEGER(kind=4) :: MX, NX, MMX, MY, NY, MMY, MZ, NZ, MMZ
          REAL(kind=8), dimension(MMX,NX) :: X 
          REAL(kind=8), dimension(MMY,NY) :: Y  
          REAL(kind=8), dimension(MMZ,NZ) :: Z
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED Y:64
          !DIR$ ASSUME_ALIGNED Z:64
          ! Locals
        
          INTEGER(kind=4) :: KK,I,J,K
          REAL(kind=8)    :: SUM
          
          KK = NY                                                           
          IF( KK .GT. MZ ) KK = MZ                                          
          DO 100 J=1,NX                                                     
!cxx      DO 50 I=1,MX
              DO 51 I=1,MX
                    SUM = 0._8                                                        
                    IF(I .GT. MY) GO TO 50                                            
                    IF( J .GT. NZ ) GO TO 50 
!DIR$  SIMD REDUCTION(+:SUM)
                    DO 20 K=1,KK                                                      
!cxx   20 SUM = SUM + Y(I,K)*Z(K,J)
                          SUM = SUM + Y(I,K)*Z(K,J)                             
                20 CONTINUE
          50 X(I,J) = SUM
      51 CONTINUE                                                      
  100 CONTINUE                                                          
                                                              
    END  SUBROUTINE
    
    SUBROUTINE  SBTRCT(X,MX,Y,MY,Z,MZ)   
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: SBTRCT
!C     THIS SUBROUTINE COMPUTES                                          
!C          X = Y - Z                                                    
!C     INPUTS:                                                           
!C       X:     MX-VECTOR                                                
!C       Y:     MY-VECTOR                                                
!C       Z:     MZ-VECTOR                                                
!C                                                                       

          INTEGER(kind=4) :: MX, MY, MZ
          REAL(kind=8), dimension(MX) :: X  
          REAL(kind=8), dimension(MY) :: Y 
          REAL(kind=8), dimension(MZ) :: Z
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED Y:64
          !DIR$ ASSUME-ALIGNED Z:64
          ! Locals
          INTEGER(kind=4) :: I
          REAL(kind=8) :: TEM
          ! Exec code .....
          !DIR$ VECTOR ALWAYS
          DO 100 I=1,MX                                                     
                 TEM = 0._8                                                     
                 IF( I .LE. MY )  TEM = Y(I)                                       
                 IF( I .LE. MZ )  TEM = TEM - Z(I)                                 
                 X(I) = TEM
     
  100 CONTINUE
                                                               
    END SUBROUTINE
    
    
    SUBROUTINE SUBSEA(  ABICM,SEASON,TREND,EST,ADJ,IRREG,TDC,                         & 
                        FSEA,LFSEA,FTRN,YS,N,NF,RLIM,WEEK,IDC,NH,F,N2,ITRN,IARS,ARFS, &
                        IART,ARFT,IARN,ARFN,PSDT,PSDS,NPF,PERIOD,IORD,ISOD,YEAR,NDAY, &
                        LOGT,ALPHA,BETA,GAMMA,ZER,SMTH,SMTH2,DD,WTRD,DELTA)
          !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: SUBSEA
!C     SEASONAL DECOMPOSITION PROCEDURE                                  
!C     FOR THE DEFINITIONS OF THE VARIABLES APPEARING IN THE ARGUMENTS,  
!C     SEE THE COMMENTS IN THE MAIN ROUTINE                              
      
          INTEGER(kind=4) :: LFSEA, N, NF, IDC, NH, N2, ITRN, IARS, IART, IARN, NPF, &
                            PERIOD, IORD, ISOD, YEAR, NDAY, LOGT
          REAL(kind=8) :: ABICM 
          REAL(kind=8), dimension(NPF) :: SEASON, TREND, EST, ADJ, IRREG, TDC, PSDT, PSDS
          REAL(kind=8), dimension(LFSEA) :: FSEA
          REAL(kind=8), dimension(IORD+3) :: FTRN
          REAL(kind=8), dimension(N) :: YS
          REAL(kind=8), dimension(7,1) :: WEEK
          REAL(kind=8), dimension(NPF+1) :: F
          REAL(kind=8), dimension(3) :: ARFS,ARFT,ARFN
          !DIR$ ASSUME_ALIGNED SEASON:64
          !DIR$ ASSUME_ALIGNED TREND:64
          !DIR$ ASSUME_ALIGNED EST:64
          !DIR$ ASSUME_ALIGNED ADJ:64
          !DIR$ ASSUME_ALIGNED IRREG:64
          !DIR$ ASSUME_ALIGNED TDC:64
          !DIR$ ASSUME_ALIGNED PSDT:64
          !DIR$ ASSUME_ALIGNED PSDS:64
          !DIR$ ASSUME_ALIGNED FSEA:64
          !DIR$ ASSUME_ALIGNED FTRN:64
          !DIR$ ASSUME_ALIGNED YS:64
          !DIR$ ASSUME_ALIGNED WEEK:64
          !DIR$ ASSUME_ALIGNED F:64
          REAL(kind=8) :: RLIM ,ALPHA, BETA, GAMMA, &
                        ZER, SMTH, SMTH2, DD, WTRD, DELTA
          ! LOcals
          INTEGER(kind=4) ::   IFLAG,MODE,ND,N7,ITRN0,IIII,I,M1,ICOUNT,K,N2M1,J, &
                             NMJ,IPM1
          REAL(kind=8)    ::   DMAX0, DMIN0, RO, DMIN, APRD,                             &
                             AN, ANN, ALNDTD, ALNDT0, WT, TEM, ALNDN, ALSQE,     &
                             SQE, ABIC, AJACOB, SSTR, SSEA, SSIR, SSAS, SAS
          REAL(kind=8), dimension(IDC,2*NPF+N2)    :: DC
          REAL(kind=8), dimension(NH,NPF)          :: H
          REAL(kind=8), dimension(N2,2*NPF+N2)     :: H2 
          REAL(kind=8), dimension(7)               :: WEEK0,WEEK1
          REAL(kind=8), dimension(2*(N+NF)+NDAY+7) :: ERR,A
          REAL(kind=8), dimension(NPF) :: DTRN,DSEAS
!DIR$     ATTRIBUTES ALIGN : 64 :: DC,H,H2,ERR,A,DTRN,DSEAS         
                                      
          IFLAG=0                                                           
          DMAX0 = 1000._8                                                   
          DMIN0 = 1._8
          MODE = 0                                                          
          RO = 1.41421_8                                                    
          IF(ITRN .NE. 0) RO = DSQRT(RO)                                    
          ND=(N+NF)*2                                                       
          IF(PERIOD .EQ. 1) ND=N+NF                                         
          N7 = NDAY + 6                                                     
          IF(YEAR .NE. 0) ND=ND+N7                                          
          ABICM = 1.0E+50_8                                                    
!c-----
          DMIN = DMIN0
          ANN = ND
!c-----                                                     
!C                                                                       
          ALNDT0=0._8                                                      
          ITRN0 = 30                                                        
          DD=DMIN
          IF(ITRN.EQ.1) DD=5._8                                           
          DO 9999  IIII=1,ITRN0                                             
!C                                                                       
!C     BASIC ROUTINE : SEASONAL ADJUSTMENT UNDER GIVEN PRIOR DISTRIBUTION
!C                                                                       
!C                                                                       
!C      CONSTRUCTION AND HOUSEHOLDER TRANSFORMATION OF MATRIX DC         
!C                                                                       
                  WT=DD*SMTH                                                        
                  IF(IIII.GT.1)GO TO 8888                                           
                  IF(PERIOD.EQ.1)GO TO 8888                                         

                  CALL SETDC(H,NH,F,M1,FSEA,N+NF,SMTH2,ZER,IARS,ARFS,IARN,ARFN,     &
                             BETA,GAMMA,PERIOD,ISOD,NPF)
           
                 ALNDT0=0._8
                 !DIR$ VECTOR ALWAYS
                 DO 2233 I=1,M1                                                    
                         TEM=DABS(H(1,I))                                                  
!cxx 2233 ALNDT0=ALNDT0+DLOG(TEM)                                           
                         ALNDT0=ALNDT0+DLOG(TEM)
            2233 CONTINUE
      8888 CONTINUE                                                          
!C                                                                       
!C     CALCULATION OF LOG(DET(DC'DC))*0.5                                
!C                                                                       
!C     --------------------                                              
                                                                        
                  ALNDTD=(N+NF)*DLOG(WT)+IORD*DLOG(ALPHA)+ALNDT0                    
                  IF(PERIOD.NE.1)ALNDTD=ALNDTD+(N+NF)*DLOG(DD)                      
!C     --------------------                                              
!C                                                                       
!C     CONSTRUCTION AND HOUSEHOLDER TRANSFORMATION OF MATRIX DCX         
!C                                                                       
!cxx 4567 CONTINUE                                                          
          
                 CALL SETX(  DC,IDC,H2,N2,M1,ICOUNT,FTRN,N+NF,H,NH,WT,   &
                             YS,N,RLIM,WEEK,N7,ALNDTD,F,DD,IART,ARFT,ALPHA,     &
                             WTRD,DELTA,PERIOD,IORD,YEAR,NPF)
      
!C                                                                       
!C     LEAST SQUARES COMPUTATION                                         
!C                                                                       
                K=M1 + N2                                                         
                SQE = H2(N2,K)**2                                                 
!C                                                                       
!C     INTERPRETATION OF THE SOLUTION                                    
!C                                                                       
!C     ****                                                              
!C                                                                       
!C                                                                       
!C     ABIC COMPUTATION                                                  
!C                                                                       
                 AN = ICOUNT                                                      
                 ANN = ICOUNT + ND                                                 
                 ALNDN=0._8
                 !DIR$ VECTOR ALWAYS
                 DO 3344 I=1,M1                                                    
                         TEM=DABS(DC(1,I))                                                
!cxx 3344 ALNDN=ALNDN + DLOG(TEM)                                           
                         ALNDN=ALNDN + DLOG(TEM)
           3344 CONTINUE
                IF(N2 .EQ. 1) GO TO 3346                                          
                N2M1=N2-1
                !DIR$ VECTOR ALWAYS
                DO 3345 I=1,N2M1                                                  
                        TEM=DABS(H2(I,M1+I))                                              
!cxx 3345 ALNDN=ALNDN+DLOG(TEM)                                             
                        ALNDN=ALNDN+DLOG(TEM)
           3345 CONTINUE
      3346 CONTINUE                                                          
                ALSQE=AN*DLOG(SQE/AN)                                             
                ABIC=ALSQE + 2._8*(ALNDN-ALNDTD)                                  
                IF(YEAR .NE. 0 .AND. WTRD .LE. 0._dp) ABIC=ABIC+N7*2._8           
!cc      WRITE( 6,3 )    DD, ABIC, ALSQE, ALNDN, ALNDTD                    
!C                                                                       
!C     END OF BASIC ROUTINE                                              
!C                                                                       
!C                                                                       
!C     MINIMUM ABIC PROCEDURE                                            
!C                                                                       
                 IF(ABIC.GE.ABICM) GO TO 9000                                      
                 IF(ABICM-ABIC .LT. 0.0001_8) GO TO 9000                           
                 ABICM = ABIC                                                      
                 DMIN = DD                                                         
                 DD=RO*DD                                                          
                 IF(IIII .EQ. 2) MODE = 1                                          
!cxx 5678 CONTINUE                                                          
                 GO TO 2345                                                        
            9000 IF(MODE .EQ. 1) GO TO 6000                                        
            9001 MODE = 1                                                          
                 RO = 1._8/RO                                                      
                 DD = DD*RO*RO                                                     
           2345  IF(DD .LE. DMAX0) GO TO 1234                                      
                 IF(MODE .EQ. 0) GO TO 9001                                        
                 DD = DMAX0                                                        
                 IFLAG=1                                                           
                 GO TO 6000                                                        
           1234  CONTINUE                                                          
                 IF(DD .GE. DMIN0) GO TO 9999                                      
                 DD = DMIN0                                                        
                 IFLAG=-1                                                          
                 GO TO 6000                                                        
 9999 CONTINUE                                                          
!C                                                                       
          6000 CONTINUE                                                          
          DD=DMIN                                                           
          WT = DD*SMTH                                                      
           
          CALL SETX( DC,IDC,H2,N2,M1,ICOUNT,FTRN,N+NF,H,NH,WT,      &
                     YS,N,RLIM,WEEK,N7,ALNDTD,F,DD,IART,ARFT,ALPHA, &
                     WTRD,DELTA,PERIOD,IORD,YEAR,NPF)
       
          NDTEM=ND + 1                                                      
                      
          CALL BSOLVE(DC,IDC,H2,N2,A,M1,SQE,NDTEM,ERR)
          SQE=SQE/ANN
          CALL DECODE(SEASON,TREND,EST,ADJ,IRREG,TDC,WEEK0,       &          
                      A,YS,N,NF,WEEK,ERR,PSDS,PSDT,SQE,PERIOD,YEAR,NDAY)
                 
          IF(LOGT .EQ. 0) GO TO 6200                                        
          AJACOB=0._8
          
          DO 6100 I=1,N                                                     
   
                 IF(YS(I) .LT. RLIM .OR. RLIM .LE. 0.0_8) AJACOB=AJACOB+YS(I)
     6100 CONTINUE
          AJACOB=AJACOB+AJACOB                                              
          ABICM=ABICM+AJACOB                                                
     6200 CONTINUE                                                          
          DO 6300 I=1,7                                                     
                  WEEK1(I) = WEEK0(I)                                               
                  IF(LOGT .NE. 0 .AND. YEAR .NE. 0) WEEK1(I) = DEXP(WEEK1(I))       
  6300    CONTINUE                                                          
                  !DIR$ SIMD
                  !DIR$ VECTOR ALIGNED
          DO 3320 I=1,N                                                     
                  DTRN(I)=TREND(I)                                                  
!cxx 3320 DSEAS(I)=SEASON(I)
                  DSEAS(I)=SEASON(I)
     3320 CONTINUE
          IF(IORD .EQ. 0) GO TO 3323                                        

          DO 3322 J=1,IORD
                  NMJ=N-J                                                           
                  DO 3321 I=1,NMJ                                                   

                          DTRN(I)=DTRN(I+1)-DTRN(I)
               3321 CONTINUE
       3322 CONTINUE
       3323 IF(ISOD .EQ. 0) GO TO 3325                                        
                                               
            DO 3327 J=1,ISOD
                    NMJ=N-J*PERIOD                                                    
                    DO 3324 I=1,NMJ                                                   

                       DSEAS(I)=DSEAS(I+PERIOD)-DSEAS(I)
              3324 CONTINUE
       3327 CONTINUE
 3325     SSTR=0._8                                                       
          SSEA=0._8                                                         
          SSIR=0._8                                                         
          SSAS=0._8                                                         
          SAS=0._8                                                         
          IPM1=PERIOD-1
          
          DO 3326 I=1,IPM1                                                  

                   SAS=SAS+SEASON(I)
     3326 CONTINUE
          DO 3400 I=1,N                                                     
                  IF(RLIM .GT. 0.D0 .AND. IRREG(I) .GT. RLIM) GO TO 3400            
                   SSIR=SSIR+IRREG(I)**2                                             
     3400 CONTINUE                                                          
          NMJ=N-IORD
!DIR$      VECTOR ALIGNED
!DIR$      SIMD REDUCTION(+:SSTR)                 
          DO 3410 I=1,NMJ                                                   
                                            
              SSTR=SSTR+DTRN(I)**2
    3410 CONTINUE
          NMJ=N-ISOD*PERIOD                                                 
          DO 3420 I=1,NMJ                                                   
             SAS=SAS+SEASON(I+IPM1)                                            
             SSAS=SSAS+SAS**2                                                  
             SAS=SAS-SEASON(I)                                                 
!cxx 3420 SSEA=SSEA+DSEAS(I)**2                                             
             SSEA=SSEA+DSEAS(I)**2
     3420 CONTINUE
          APRD=PERIOD                                                       
          SSAS=SSAS/APRD                                                    
                                                            
                                                               
                                      
    END SUBROUTINE
                        
                        
    SUBROUTINE CALEND(WEEK,YEAR0,MONTH0,N)  
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: CALEND
!C      THIS SUBROUTINE COMPUTES THE DAYS-OF-WEEK DISTRIBUTION OF        
!C     N SUCCESSIVE MONTHS STARTING AT MONTH0 OF YEAR0                   
!C     NOTE:  THIS SUBROUTINE WORKS FOR YEARS                            
!C              AD.1901 - AD.2099                                        
!C                                                                       

           INTEGER(kind=4) :: YEAR0, MONTH0, N
           REAL(kind=8), dimension(7,N) :: WEEK
           ! Locals
           INTEGER(kind=4) :: DYEAR, YEAR, LEAP, Y, L, D, DAY, MONTH, DIFF, WDAY,I,J
           REAL(kind=8), dimension(8) :: W0
                                                                      
           DYEAR=(MONTH0-1)/12                                               
           IF(MONTH0 .GE. 1) GO TO 20                                        
           DYEAR=-MONTH0                                                     
           DYEAR=DYEAR/12+1                                                  
           DYEAR=-DYEAR                                                      
   20      CONTINUE                                                          
           MONTH=MONTH0-12*DYEAR                                             
           YEAR=YEAR0+DYEAR                                                  
           LEAP=MOD(YEAR,4)                                                  
!C  DAY-OF-WEEK OF THE FIRST DAY OF 'YEAR'                               
           Y = YEAR-1901                                                     
           L=Y/4                                                             
           D=Y+L+2                                                           
           DAY=MOD(D,7) + 1                                                  
                                                         
           IF (MONTH .EQ. 1 .OR. MONTH .EQ. 10) GO TO 200
           IF (MONTH .EQ. 5) THEN
               DAY=DAY+1                                                         
           ELSE IF (MONTH .EQ. 8) THEN
               DAY=DAY+2                                                         
           ELSE IF (MONTH .EQ. 6) THEN
               DAY=DAY+4                                                         
           ELSE IF (MONTH .EQ. 9 .OR. MONTH .EQ. 12) THEN
               DAY=DAY+5                                                         
           ELSE IF (MONTH .EQ. 7 .OR. MONTH .EQ. 4) THEN
               DAY=DAY+6                                                         
           ELSE
               DAY=DAY+3   
           END IF                                                        
     
  200 IF(LEAP .EQ. 0 .AND. MONTH .GE. 3) DAY=DAY+1                      
      IF(DAY .GT. 7) DAY=DAY-7                                          
!C  ITERATION                                                            
      DO 100 I=1,N                                                      
!cxx      DO 10 J=1,7                                                       
!cxx   10 W0(J) = 4.D0
          W0(1:7) = 4._dp
!cxx      GO TO (331,328,331,330,331,330,331,331,330,331,330,331), MONTH    
          IF (MONTH .EQ. 2) GO TO 328
          IF (MONTH .EQ. 4 .OR. MONTH .EQ. 6 .OR.     &
              MONTH .EQ. 9 .OR. MONTH .EQ. 11) GO TO 330
!C    IF (MONTH .EQ. 1 .OR. MONTH .EQ. 3 .OR. MONTH .EQ. 5 .OR. MONTH .EQ. 7
!C        .OR. MONTH .EQ. 8 .OR. MONTH .EQ. 10 .OR. MONTH .EQ. 12) GO TO 331
!cxx  331 DIFF=3                                                            
           DIFF=3                                                            
           W0(8)=31._8                                                    
           GO TO 300                                                         
       330 DIFF=2                                                            
           W0(8)=30._8                                                       
           GO TO 300                                                         
       328 DIFF=0                                                            
           W0(8)=28._8                                                      
           IF(LEAP .NE. 0) GO TO 50                                          
           DIFF=1                                                            
           W0(8)=29._8                                                      
       300 WDAY=8-DAY                                                        
           DO 400 J=1,DIFF                                                   
                  W0(WDAY) = 5.0_8                                                   
                  IF(J .EQ. DIFF) GO TO 50                                          
                  WDAY=WDAY-1                                                       
!cxx  400 IF(WDAY .EQ. 0) WDAY=7
                 IF(WDAY .EQ. 0) WDAY=7
      400 CONTINUE
   50 CONTINUE                                                          
          DO 410 J=1,7                                                      
!cxx  410 WEEK(J,I)=W0(J)-30.4375D0/7.D0
                  WEEK(J,I)=W0(J)-30.43567_8/7.0_8
       410 CONTINUE
           IF(I .EQ. N) GO TO 900                                            
           DAY = DAY + DIFF                                                  
           IF(DAY .GT. 7) DAY = DAY - 7                                      
           MONTH=MONTH+1                                                     
           IF(MONTH .LE. 12) GO TO 100                                       
           MONTH=1                                                           
           YEAR=YEAR+1                                                       
           LEAP=MOD(YEAR,4)                                                  
  100 CONTINUE                                                          
  900 RETURN                                                            
    END SUBROUTINE
    
    
                                            
    real(kind=dp) FUNCTION AMAX(A,N)
!C     COMMON SUBROUTINE                                                 
!C     MAXIMUM OF A(I)(I=1,N) SEARCH   
      real(kind=8), dimension(N) :: A                                  
      !DIR$ ASSUME_ALIGNED A:64                                              
      AMAX=A(1)                                                         
      DO 10 I=2,N                                                       
      IF(AMAX.LT.A(I)) AMAX=A(I)                                        
   10 CONTINUE                                                          
      RETURN                                                            
      END                                                               
!C                                                                       
!CC      FUNCTION AMIN(A,N)                                                
    real(kind=dp) FUNCTION AMIN(A,N)
!C     COMMON SUBROUTINE                                                 
!C     MINIMUM OF A(I)(I=1,N) SEARCH  
       real(kind=8), dimension(N) :: A                                 
       !DIR$ ASSUME_ALIGNED A:64                                                 
       AMIN=A(1)                                                         
       DO 10 I=2,N                                                       
       IF(AMIN.GT.A(I)) AMIN=A(I)                                        
   10  CONTINUE                                                          
       RETURN                                                            
       END                                                               
!C                                                                       
    SUBROUTINE  POOLAV( Z,K,X,SD1 ) 
         !DIR$ ATTRIBUTE CODE_ALIGN : 32 :: POOLAV
!C                                                                       
!C     THIS SUBROUTINE SEARCHES FOR THE MINIMUM OF                       
!C          F(X;Z) = (Z(1)-X(1))**2 + ... + (Z(K)-X(K))**2               
!C     SUBJECT TO X(1)<X(2)< ... < X(K), BY THE POOL-ADJACENT-VIOLALORS  
!C     ALGORITHM.                                                        
!C                                                                       
!C     INPUTS:                                                           
!C        (Z(I),I=1,K): DATA                                             
!C        K:            NUMBER OF DATA                                   
!C     OUTPUTS:                                                          
!C        (X(I),I=1,K): VECTOR OF MINIMIZING SOLUTION                    
!C        SD1:          MINIMUM OF F(X;Z)                                
!C                                                                       
                                  
          INTEGER(kind=4) :: K
          REAL(kind=8), dimension(K)  :: Z, X
          !DIR$ ASSUME_ALIGNED Z:64,X:64
          REAL(kind=8) :: SD1
          ! Locals
          INTEGER(kind=4) :: I,N0,I0,IFG
          REAL(kind=8)    :: SUM
          REAL(kind=8), dimension(K) :: Y 
          !DIR$     ATTRIBUTES ALIGN : 64 :: Y
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 10  I=1,K                                                      
                                                    
                 X(I) = Z(I)
       10 CONTINUE
!C                                                                       
    100 DO 20  I=2,K                                                      
!cxx   20 IF( X(I-1) .GT. X(I) )  GO TO 30
              IF( X(I-1) .GT. X(I) )  GO TO 30
     20 CONTINUE
        GO TO 300                                                         
!C                                                                       
30      IFG = 0
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))        
        DO 40  I=1,K                                                      
!cxx   40 Y(I) = X(I)                                                       
               Y(I) = X(I)
   40 CONTINUE

      N0=1                                                                       
      DO 200  I=1,K-1
              I0 = I
                                                                       
              IF( X(I) .LT. X(I+1) )  GO TO 110                                 
              IF( I .EQ. K-1  .AND.  IFG .NE. 0 )  GO TO 90                     
              IF( IFG .NE. 0 )  GO TO 200                                       
              IFG = 1                                                           
              N0 = I                                                            
              IF( I .EQ. K-1 )  GO TO 90                                        
              GO TO 200                                                         
!CC   90 I = K
              90 I0 = K
              GO TO 115                                                         
!C                                                                       
          110 IF( IFG .EQ. 0 )  GO TO 200                                       
              IFG = 0                                                           
  115         CONTINUE                                                          
              SUM = 0._dp                                                       
!CC      DO 120  J=N0,I
!DIR$    SIMD REDUCTION(+:SUM)
              DO 120 J=N0,I0
!cxx  120 SUM = SUM + Y(J)                                                  
                 SUM = SUM + Y(J)
         120 CONTINUE
!CC      SUM = SUM/(I-N0+1)
              SUM = SUM/(I0-N0+1)
!CC      DO 130  J=N0,I
             DO 130  J=N0,I0                                             
!cxx  130 Y(J) = SUM                                                        
                 Y(J) = SUM
        130 CONTINUE
!C                                                                       
     200 CONTINUE                                                          
                 !C
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))                 
      DO 210  I=1,K                                                     
!cxx  210 X(I) = Y(I)                                                       
              X(I) = Y(I)
  210 CONTINUE
      GO TO 100                                                         
300   SD1 = 0._8
!DIR$      VECTOR ALIGNED
!DIR$      SIMD REDUCTION(+:SD1)   
      DO 310  I=1,K                                                     
!cxx  310 SD1 = SD1 + (X(I) - Z(I))**2                                      
                SD1 = SD1 + (X(I) - Z(I))**2
    310 CONTINUE
!cxx    2 FORMAT( 1H ,10F13.5 )                                             
                                                              
    END SUBROUTINE
    
    
    SUBROUTINE  LKOUT1( X,N,IND,JSW,F,W )
          implicit none
!C                                                                       
!C     THIS SUBROUTINE COMPUTES THE LIKELIHOOD OF THE MODEL THAT (X(I);  
!C     IND(I)=1) ARE THE OUTLIERS.  (MEAN SLIPPAGE TYPE MODEL)           
!C                                                                       
!C     INPUTS:                                                           
!C        (X(I),I=1,N): OBSERVATIONS                                     
!C        N:            NUMBER OF OBSERVATIONS                           
!C        (IND(I),I=1,N): = 0 ; IF X(I) IS A "NORMAL" OBSERVATION.       
!C                        = 1 ; IF X(I) IS AN OUTLIER.                   
!C        JSW:   =0;    WHOLE MODELS ARE EVALUATED                       
!C               =1;    ONLY THE NATURALLY ORDERED MODEL IS EVALUATED    
!C                      (SIMPLIFIED ALGORITHM)                           
!C                                                                       
!C     OUTPUTS:                                                          
!C        F:            LIKELIHOOD OF THE MODEL                          
!C        W:                                                             
!C                                                                       
      
          INTEGER(kind=4)               :: N, JSW
          INTEGER(kind=4), dimension(N) :: IND
          REAL(kind=8), dimension(N)    :: X
          !DIR$ ASSUME_ALIGNED IND:64
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=8)                  :: F, W
          ! Locals
          INTEGER(kind=4) :: L,I,K,IFG
          REAL(kind=8)    ::  SUM, XMEAN, SIG2, SD
          INTEGER(kind=4), dimension(N) :: JND
          REAL(kind=8), dimension(N) :: Y, Z, ZE 
!DIR$     ATTRIBUTES ALIGN : 64 :: JND,Y,Z,ZE                                                                       
          L = 0                                                             
          SUM = 0._8                                                      
          DO 10  I=1,N                                                      
                 IF( IND(I) .EQ. 1 )   GO TO 10                                    
                 L = L + 1                                                         
                 SUM = SUM+X(I)                                                    
       10 CONTINUE                                                          
          XMEAN = SUM/DFLOAT(L)                                             
          K = N-L                                                           
                                                                       
          SUM = 0._8                                                     
          DO 20  I=1,N                                                      
             !cxx   20 IF( IND(I) .EQ. 0 )   SUM = SUM+(X(I)-XMEAN)**2
!DIR$      VECTOR ALIGNED
!DIR$      SIMD  REDUCTION(+:SUM)             
                 IF( IND(I) .EQ. 0 )   SUM = SUM+(X(I)-XMEAN)**2
      20  CONTINUE
          SIG2 = SUM/N                                                      
          W = 1._8                                                         
          F = -0.5_8*N*DLOG(SIG2)                                           
                                                                       
          IF( JSW .EQ.1 )   RETURN                                          
          IF( K .LE. 1 )   RETURN                                           
                                                                       
          J = 0                                                             
          DO 30  I=1,N                                                      
                IF( IND(I) .EQ. 0 )   GO TO 30                                    
                J = J+1                                                           
                Y(J) = X(I)                                                       
   30     CONTINUE                                                          
                                                                       
           W = 0._8
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 40  I=1,K                                                      
!cxx   40 JND(I) = I                                                        
               JND(I) = I
      40  CONTINUE
!C                                                                       
    50    DO 60  I=1,K                                                      
              J = JND(I)                                                        
!cxx   60 Z(I) = Y(J)                                                       
              Z(I) = Y(J)
   60     CONTINUE
          CALL  POOLAV( Z,K,ZE,SD )                                         
                                                                       
          W = W + 1.0_8/DSQRT(1.0_8+SD/SUM)**N                                
                                                                       
          CALL  PERMUT( JND,K,IFG )                                         
          IF( IFG .EQ. 0 )   GO TO 50                                       
    END SUBROUTINE
    
                        
                                                                 
!cc      SUBROUTINE  PRPOST( POST,X,IND,JND,KND,IC,N,L)                    
    SUBROUTINE  PRPOST( POST,X,IND,JND,KND,IC,N,L)
         
!C                                                                       
!C     THIS SUBROUTINE ARRANGES POST(I), JND(I) AND KND(I) (I=1,IC) IN   
!C     DECREASING ORDER OF POST(I), AND DRAWS POSTERIOR PROBABILITY AND  
!C     THE ASSUMED OUTLIERS OF THE MODEL WITH POSTERIOR PROBABILITY      
!C     GREATER THAN EPS.                                                 
!C                                                                       
!C     INPUTS:                                                           
!C        (POST(I),I=1,IC):   POSTERIOR PROBABILITIES OF THE MODELS      
!C        (X(I),I=1,N):       ORIGINAL DATA                              
!C        (IND(I),I=1,N):     WORK AREA                                  
!C        (JND(I),I=1,IC):    SPECIFICATION OF THE OUTLIERS IN LOW SIDE  
!C                            (CODED IN DECIMAL)                         
!C        (KND(I),I=1,IC):    SPECIFICATION OF THE OUTLIERS IN HIGH SIDE 
!C                            (CODED IN DECIMAL)                         
!C        IC:                 NUMBER OF RECORDED MODELS                  
!C        N:                  NUMBER OF ORIGINAL DATA                    
!C        L:                  NUMBER OF POSSIBLE OUTLIERS IN BOTH SIDES  
!C        EPS:                LOWEST LIMIT OF POSTERIOR PROBABILITY TO BE
!C                            PRINTED                                    
!C                                                                       

          INTEGER(kind=4), dimension(N)  :: IND
          INTEGER(kind=4), dimension(IC) :: JND, KND 
          INTEGER(kind=4)                :: IC, N, L
          REAL(kind=8), dimension(IC) :: POST 
          REAL(kind=8), dimension(N)  :: X
          !DIR$ ASSUME_ALIGNED IND:64
          !DIR$ ASSUME_ALIGNED JND:64
          !DIR$ ASSUME_ALIGNED KND:64
          !DIR$ ASSUME_ALIGNED POST:64
          !DIR$ ASSUME_ALIGNED X:64
          ! Locals
          INTEGER(kind=4) :: I,J,IMAX,JJ,KK,IC1,NML1,ID
          REAL(kind=8) :: PMAX
          REAL(kind=8), dimension(N) :: Y
!DIR$     ATTRIBUTES ALIGN : 64 :: Y
          ! Exec code ...                                                             
          DO 20  I=1,IC                                                     
                 IMAX = I                                                          
                 PMAX = POST(I)                                                    
                 DO 10  J=I,IC                                                     
                        IF( POST(J) .LE. PMAX )   GO TO 10                                
                           IMAX = J                                                          
                        PMAX = POST(J)                                                    
             10 CONTINUE                                                          
                 IF( IMAX .EQ. I )   GO TO 20                                      
                 POST(IMAX) = POST(I)                                              
                 POST(I) = PMAX                                                    
                 JJ = JND(I)                                                       
                 KK = KND(I)                                                       
                 JND(I) = JND(IMAX)                                                
                 KND(I) = KND(IMAX)                                                
                 JND(IMAX) = JJ                                                    
                 KND(IMAX) = KK                                                    
   20     CONTINUE                                                          
!cxx   30 IC1 = IC                                                          
          IC1 = IC                                                          
          NML1 = N-L+1
!DIR$      VECTOR ALIGNED
!DIR$      SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 40  I=1,N                                                      
!cxx   40 IND(I) = 0                                                        
                 IND(I) = 0
   40     CONTINUE
!C                                                                       
!cc      IF(ISPRSS .EQ. 0) WRITE( 6,4 )                                    
          DO 100  J=1,IC1                                                   
                  CALL  BINARY( JND(J),L,IND )                                      
                  CALL  BINARY( KND(J),L,IND(NML1) )                                
          ID = 0                                                            
          DO 50  I=1,N                                                      
                 IF( IND(I) .EQ. 0 )    GO TO 50                                   
                 ID = ID+1                                                         
                 Y(ID) = X(I)                                                      
   50     CONTINUE                                                          
!cc      IF(ISPRSS .NE. 0) GO TO 100                                       
!cc      IF( ID .GE. 1 )   WRITE( 6,5 )   J, POST(J), (Y(I),I=1,ID)        
!cc      IF( ID .EQ. 0 )   WRITE( 6,6 )   J, POST(J)                       
  100 CONTINUE                                                          
    END SUBROUTINE
    
    
    SUBROUTINE PERMUT( IND,K,IFG ) 
         
!C                                                                       
!C     THIS SUBROUTINE SEQUENTIALLY SPECIFIES K] CONFIGURATIONS (IND(1), 
!C     ...,IND(K)) OBTAINED BY PERMUTING (1,...,K)                       
!C                                                                       
!C     INPUTS:                                                           
!C        (IND(I),I=1,K): FORMER CONFIGURATION                           
!C        K:              NUMBER OF ELEMENTS TO BE PERMUTED              
!C                                                                       
!C     OUTPUTS:                                                          
!C        (IND(I),I=1,K): NEW CONFIGURATION                              
!C        IFG:            = 0 ; IF THE NEW CONFIGURATION IS OBTAINED     
!C                        = 1 ; SEARCH FOR THE CONFIGURATION COMPLETED.  
!C                                                                       

          INTEGER(kind=4), dimension(K)  ::  IND 
          INTEGER(kind=4)                :: K, IFG
          !DIR$ ASSUME_ALIGNED IND:64
          ! Locals
          INTEGER(kind=4) :: I1,I2,I0,IMAX,IFG,I2M1
!C                                                                       
          I1 = 1                                                            
          I2 = 2                                                            
          I0 = 1                                                            
          IMAX = IND(1)                                                     
          IFG = 0                                                           
!C                                                                       
      10  IF( IND(I1) .LT. IND(I2) )   GO TO 100                            
          IF( I2 .EQ. I1+1 )   GO TO 20                                     
          I1 = I1+1                                                         
          GO TO 10                                                          
!C                                                                       
   20     I2 = I2+1                                                         
          IF( I2 .GT. K )   GO TO 200                                       
!C                                                                       
          I2M1 = I2-1                                                       
          DO 30  I=1,I2M1                                                   
!cxx   30 IF( IND(I) .LE. IND(I2) )   GO TO 40                              
                IF( IND(I) .LE. IND(I2) )   GO TO 40
   30     CONTINUE
          GO TO 20                                                          
                                                                      
      40  IMAX = 0                                                          
          DO 50  I=1,I2M1                                                   
          IF( IND(I) .GT. IND(I2) )   GO TO 50                              
          IF( IND(I) .LT. IMAX )   GO TO 50                                 
          IMAX = IND(I)                                                     
          I0 = I                                                            
   50     CONTINUE                                                          
                                                                      
  100     IND(I0) = IND(I2)                                                 
          IND(I2) = IMAX                                                    
          I2M1 = I2-1                                                       
          IF( I2 .GT. 2 )   CALL  ISORT( IND,I2M1 )                         
          RETURN                                                            
                                                                      
  200     IFG = 1                                                           
    END SUBROUTINE
    
    
                                                          
    SUBROUTINE  ISORT( IND,N )  
          implicit none
!C                                                                       
!C     THIS SUBROUTINE ARRANGES IND(I) (I=1,N) IN ORDER OF INCREASING    
!C     MAGNITUDE                                                         
!C                                                                       
!C     INPUTS:                                                           
!C        (IND(I),I=1,N): ORIGINAL DATA                                  
!C        N:              NUMBER OF DATA                                 
!C                                                                       
!C     OUTPUT:                                                           
!C        (IND(I),I=1,N): REORDERED DATA                                 
!C                                                                       
                                             
          INTEGER(kind=4), dimension(N) :: IND
          !DIR$ ASSUME_ALIGNED IND:64
          INTEGER(kind=4) :: N
          
          ! Locals
          INTEGER(kind=4) :: NM1,II,MINI,IMIN,J
          ! Exec code ....                                                           
          NM1 = N-1                                                         
          DO 20  II=1,NM1                                                   
                  MINI = IND(II)                                                    
                  IMIN = II                                                         
                  DO 10  I=II,N                                                     
                         IF( MINI .LE. IND(I) )   GO TO 10                                 
                         MINI = IND(I)                                                     
                         IMIN = I                                                          
              10 CONTINUE                                                          
                 IF( IMIN .EQ. II )   GO TO 20                                     
                 J = IND(II)                                                       
                 IND(II) = MINI                                                    
                 IND(IMIN) = J                                                     
   20      CONTINUE                                                          
    END SUBROUTINE
    
                                                                
    SUBROUTINE  BINARY( M,K,MB )    
         
!C                                                                       
!C       DECIMAL TO BINARY CONVERSION                                    
!C                                                                       
!C       INPUTS:                                                         
!C          M:     NUMBER IN DECIMAL REPRESENTATION                      
!C          K:     NUMBER OF BITS USED FOR THE BINARY REPRESENTATION     
!C                                                                       
!C       OUTPUT:                                                         
!C          MB:    NUMBER IN BINARY REPRESENTATION                       
!C                                                                       

          INTEGER(kind=4) :: M, K 
          INTEGER(kind=4), dimension(K) :: MB
          !DIR$ ASSUME_ALIGNED MB:64
          ! Locals
          INTEGER(kind=4) :: N,I,L
          N = M                                                             
          DO 10  I=1,K                                                      
                 L = N / 2                                                       
                 MB(I) = N - L*2                                                 
!cxx   10 N = L
                 N = L
   10    CONTINUE                                                             
    END SUBROUTINE
    
                                                                       
                                                               
                               
    SUBROUTINE  BSRTMIN( X,N,IX )
        
!C                                                                       
!C       THIS SUBROUTINE ARRANGES X(I) (I=1,N) IN ORDER OF INCREASING    
!C       MAGNITUDE OF X(I)                                               
!C                                                                       
!C       INPUTS:                                                         
!C          X:   VECTOR                                                  
!C          N:   DIMENSION OF THE VECTOR                                 
!C       OUTPUTS:                                                        
!C          X:   ARRANGED VECTOR                                         
!C          IND: INDEX OF ARRANGED VECTOR                                
!C                                                                       

          INTEGER(kind=4) :: N
          INTEGER(kind=4), dimension(N) :: IX
          REAL(kind=8), dimension(N) :: X
          !DIR$ ASSUME_ALIGNED IX:64,X:64
          ! Locals
          INTEGER(kind=4) :: NM1,II,XMIN,MIN,IT
          REAL(kind=8) :: XMIN, XT
          ! Exec code ....                                                            
          NM1 = N - 1                                                       
          DO  20 II=1,NM1                                               
                    XMIN = X(II)                                                      
                    MIN = II                                                          
              DO  10 I=II,N                                                 
                     IF( XMIN .LT. X(I) )     GO TO 10                                 
                     XMIN = X(I)                                                       
                     MIN = I                                                           
          10 CONTINUE                                                          
                   IF( XMIN .EQ. X(II) )     GO TO 20                                
                   XT = X(II)                                                        
                   X(II) = X(MIN)                                                    
                   X(MIN) = XT                                                       
                   IT = IX(II)                                                       
                   IX(II) = IX(MIN)                                                  
                   IX(MIN) = IT                                                      
      20 CONTINUE                                                          
    END SUBROUTINE
    
                                                                 
                     
    SUBROUTINE OUTLIR( Z,NN,K,ISW,JSW,Y,RLIM,IOUTD,ROUT )
         
!C     REVISED  MAY 30, 1980                                             
!C                                                                       
!C     INPUTS:                                                           
!C        (Z(I),I=1,N):   ORIGINAL DATA                                  
!C        NN:             NUMBER OF DATA                                 
!C        K:              MAXIMUM OF THE NUMBER OF OUTLIERS              
!C        L:              NUMBER OF POSSIBLE OUTLIERS IN BOTH SIDES.     
!C        ISW   =0:       MODIFIED DATA ARE NOT GIVEN                    
!C              =2:       THE OBSERVATIONS JUDGED AS OUTLIERS ARE        
!C                        REPLACED BY A CONSTANT.                        
!C        JSW   =0:       WHOLE MODELS ARE EVALUATED                     
!C              =1:       ONLY THE NATURALLY ORDERED MODEL IS EVALUATED  
!C                        (SIMPLIFIED ALGORITHM)                         
!C        RLIM:           ORIGINAL DATA WHOSE VALUES ARE GREATER         
!C                        THAN OR EQUAL TO RLIM ARE TREATEDAS            
!C                        MISSING OBSERVATIONS.                          
!C     OUTPUTS:                                                          
!C        (IX(I),I=1,N):  SUBSCRIPT INDICATING THE ORDER OF THE MAGNITUDE
!C                        OF ORIGINAL DATA.                              
!C                        I.E.,  Z(IX(1))<Z(IX(2))< ... <Z(IX(N)).       
!C                        NOTE THAT Z(IX(I))=X(I).                       
!C        (PM(I),I=1,N):  MARGINAL POSTRIOR PROBABILITY THAT X(I) IS AN O
!C        (POST(I),I=1,IC):   POSTERIOR PROBABILITIES OF THE MODELS      
!C        (JND(I),I=1,IC):    SPECIFICATION OF THE OUTLIERS IN LOW SIDE  
!C                            (CODED IN DECIMAL)                         
!C        (KND(I),I=1,IC):    SPECIFICATION OF THE OUTLIERS IN HIGH SIDE 
!C                            (CODED IN DECIMAL)                         
!C        IC:                 NUMBER OF RECORDED MODELS                  
!C                                                                       
                    
          INTEGER(kind=4) :: NN, K, ISW, JSW, IOUTD
          REAL(kind=8), dimension(NN) :: Z, Y
          !DIR$ ASSUME_ALIGNED Z:64,Y:64
          REAL(kind=8) :: RLIM, ROUT
          ! Locals
          INTEGER(kind=4) :: ISPRSS,N,I,L,K,NML1,IL,IC,II,II1,K1,JJ,JJ1, &
                           K2
          REAL(kind=8) ::  EPS,DI, SUMF, DLK0, F0, TEM, FF, EXPF, W
          INTEGER(kind=4), dimension(NN) :: IX,IND
          INTEGER(kind=4), dimension(2**K) :: JND,KND
!DIR$     ATTRIBUTES ALIGN : 64 :: IX,IND,JND,KND
          REAL(kind=8), dimension(NN) :: X,PM
          REAL(kind=8), dimension(NN+1) :: F
          REAL(kind=8), dimension(K+1) :: C
          REAL(kind=8), dimension(2**K) :: POST
!DIR$     ATTRIBUTES ALIGN : 64 :: X,PM,F,C,POST     
          ! Exec code ....
                                         
          ISPRSS = 1                                                        
                                                                      
          N=0                                                               
          DO 5 I=1,NN                                                       
          IF(RLIM .LE. 0._dp) GO TO 6                                        
          IF(Z(I) .GE. RLIM) GO TO 7                                        
    6     N=N+1                                                             
          X(N)=Z(I)                                                         
          IX(N)=I                                                           
    7     Y(I)=Z(I)                                                         
    5     CONTINUE                                                          
          L=K                                                               
                                           
          CALL  BSRTMIN( X,N,IX )
          EPS = 0.001_8                                                   
          NML1 = N-L+1                                                      
          F(1) = 0._dp                                                       
          DO 10  I=1,N                                                      
                 IND(I) = 0                                                        
                 PM(I) = 0._8                                                    
                 DI = I                                                            
!cxx   10 F(I+1) = F(I)+DLOG(DI)                                            
                 F(I+1) = F(I)+DLOG(DI)
       10 CONTINUE
          C(1) = DFLOAT(N*2)/DFLOAT(N-3)                                    
          DO 20  I=1,K                                                      
!cxx   20 C(I+1) = DFLOAT(N*(I+2))/DFLOAT(N-I-3)+F(N+1)-F(N-I+1)            
                  C(I+1) = DFLOAT(N*(I+2))/DFLOAT(N-I-3)+F(N+1)-F(N-I+1)
      20  CONTINUE
                                                                       
          IL = 2**L                                                         
          IF(JSW.EQ.1)  IL=K+1                                              
          IC = 0                                                            
          SUMF = 0._8                                                      
          DLK0 = 0._8
                                                                      
          DO 101  II1 = 1,IL                                                
                  II = II1-1                                                        
                  IF(JSW.EQ.1)  II=2**II-1                                          
                  CALL  BINARY( II,L,IND )                                          
                  K1 = 0                                                            
                  DO 30  I=1,L                                                      
!cxx   30 K1 = K1+IND(I)                                                    
                         K1 = K1+IND(I)
               30 CONTINUE
                  IF( K1 .GT. K )   GO TO 101                                       
                                                                      
                  DO 100  JJ1=1,IL                                                  
                          JJ = JJ1-1                                                        
                          IF(JSW.EQ.1)   JJ=2**K-2**JJ                                      
                          CALL  BINARY( JJ,L,IND(NML1) )                                    
                          K2 = K1                                                           
                          DO 40  I=NML1,N                                                   
!cxx   40 K2 = K2+IND(I)                                                    
                                 K2 = K2+IND(I)
                       40 CONTINUE
                  IF( K2 .GT. K )   GO TO 100                                       
                                                                       
                  CALL  LKOUT1( X,N,IND,JSW,FF,W )                                  
                  IF( IC.EQ.0 ) DLK0=FF-C(K2+1)                                     
                                                                     
                  F0 = FF-C(K2+1)-DLK0                                              
                  IF( F0 .LT. -20._dp )  GO TO 100                                   
                  IF(F0.LT.20._dp)GO TO 45                                           
                  DLK0=F0                                                           
                  TEM=DEXP(-F0)                                                     
                  SUMF=SUMF*TEM  
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                  DO 46 I=1,N                                                       
!cxx   46 PM(I)=PM(I)*TEM                                                   
                        PM(I)=PM(I)*TEM
             46   CONTINUE
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                  DO 47 I=1,IC                                                      
!cxx   47 POST(I)=POST(I)*TEM                                               
                        POST(I)=POST(I)*TEM
              47 CONTINUE
                 F0=0._8                                                        
              45 CONTINUE                                                          
                 EXPF = DEXP( F0 )*W                                               
                 SUMF = SUMF+EXPF    
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                
                 DO 50  I=1,N                                                      
!cxx   50 PM(I) = PM(I) + IND(I)*EXPF                                       
                        PM(I) = PM(I) + IND(I)*EXPF
              50 CONTINUE
                 IF( EXPF/SUMF .LT. EPS )   GO TO 100                              
                                                                       
                 IC = IC+1                                                         
                 JND(IC) = II                                                      
                 KND(IC) = JJ                                                      
                 POST(IC) = EXPF                                                   
                                                                       
            100 CONTINUE                                                          
                                                                       
101       CONTINUE  
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))          
               DO 110  I=1,N                                                     
!cxx  110 PM(I) = PM(I)/SUMF                                                
                      PM(I) = PM(I)/SUMF
           110 CONTINUE
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                       
           DO 120  I=1,IC                                                    
!cxx  120 POST(I) = POST(I)/SUMF                                            
                   POST(I) = POST(I)/SUMF
        120 CONTINUE
                                                                      
            CALL  PRPOST( POST,X,IND,JND,KND,IC,N,L)                          
       
            IF( ISW .GE. 1 )  CALL MODIFY( N,L,IX,PM,JND,KND,Y,IC,IOUTD,ROUT )
    END SUBROUTINE
    
                                                                 
                
    SUBROUTINE  MODIFY( N,L,IX,POST,JND,KND,Y,IC,IOUTD,CONST )
        
!C     REVISED  MAY 29, 1980                                             
!C                                                                       
!C     THIS SUBROUTINE MODIFIES THE ORIGINAL DATA BY USING THE OUTPUTS   
!C     FROM SUBROUTINE OUTLIR.                                           
!C                                                                       
!C     INPUTS:                                                           
!C        (X(I),I=1,N):   ORIGINAL DATA                                  
!C        N:              NUMBER OF ORIGINAL DATA                        
!C        L:              NUMBER OF POSSIBLE OUTLIERS IN BOTH SIDES      
!C        (IX(I),I=1,N):                                                 
!C        (POST(I),I=1,N): MARGINAL POSTERIOR PROBABILITIES THAT X(IX(I))
!C                        IS AN OUTLIER                                  
!C        IOUTD:          =1  X(IX(I)) IS JUDGED AS AN OUTLIER           
!C                            WHEN POST(I) IS GREATER THAN 0.01          
!C                        =2  X(IX(I)) IS JUDGED AS AN OUTLIER           
!C                            WHEN AT LEAST ONE MODEL, WHOSE             
!C                            POSTERIOR PROBABILITY IS GREATER THAN      
!C                            THAT OF NO-OUTLIER MODEL, SPECIFIES IT     
!C                            AS AN OUTLIER                              
!C                                                                       
!C     OUTPUT:                                                           
!C        (Y(I),I=1,N):   MODIFIED DATA                                  
!C                                                                       
             
          INTEGER(kind=4) :: N, L, IC ,IOUTD 
          INTEGER(kind=4), dimension(N)  :: IX 
          INTEGER(kind=4), dimension(IC) :: JND, KND
          REAL(kind=8), dimension(N) :: POST, Y
          !DIR$ ASSUME_ALIGNED IX:64
          !DIR$ ASSUME_ALIGNED JND:64,KND:64
          !DIR$ ASSUME_ALIGNED POST:64,Y:64
          REAL(kind=8) :: CONST 
          ! Locals
          INTEGER(kind=4) :: ICTEM,NML1,K,ICHK,J
          INTEGER(kind=4), dimension(N) :: IND
          !DIR$ ATTRIBUTES ALIGN : 64 :: IND
          ! Exec code ....                 
          ICTEM = IC                                                        
          IF(IOUTD .EQ. 1) ICTEM=1                                          
                                                     
          IND(1:N) = 0
          NML1 = N-L+1                                                      
          DO 200 K=1,ICTEM                                                  
                 CALL  BINARY( JND(K),L,IND )                                      
                 CALL  BINARY( KND(K),L,IND(NML1) )                                
                                                                     
                 ICHK = 0                                                          
                 DO 120  I=1,N                                                     
                         J = IX(I)                                                         
                         IF(IOUTD .EQ. 1 .AND. POST(I) .LE. 0.01_dp) GO TO 120              
                         IF(IOUTD .EQ. 2 .AND. IND(I) .EQ. 0) GO TO 120                    
                         ICHK=1                                                            
                         Y(J) = CONST                                                      
            120 CONTINUE                                                          
                IF(ICHK .EQ. 0) GO TO 201                                         
       200 CONTINUE                                                          
  201 CONTINUE                                                          
    END SUBROUTINE
    
    SUBROUTINE SETD(W,IP,ID,C,IAR,AR)                                 
         
          INTEGER(kind=4) :: IP, ID, IAR
          REAL(kind=4) :: C
          REAL(kind=8), dimension(IP,ID+IAR+1) :: W
          REAL(kind=8), dimension(1) :: AR
          !DIR$ ASSUME_ALIGNED W:64,AR:64
          ! Locals
          INTEGER(kind=4) :: IDAR,IDP1,J,I,K,JLX,JY
          REAL(kind=8), dimension(ID+IAR+1) :: WW
!DIR$     ATTRIBUTES ALIGN : 64 :: WW
          ! eXEC CODE ...
          IDAR = ID + IAR                                                   
          IDP1 = IDAR + 1                                                   
          W(1,IDP1) = C                                                     
          WW(IDP1) = C                                                      
          IF(IDAR .EQ. 0) GO TO 998                                         

          WW(1:IDAR)=0._8
          W(1:IP,1:IDAR) = 0._8
          IF(ID .EQ. 0) GO TO 997                                           
!cxx      DO 50 J=1,ID                                                      
          DO 51 J=1,ID
                I = IDP1 - J - 1                                                  
                DO 50 K=1,J                                                       
                      I = I + 1                                                         
!cxx   50 WW(I) = WW(I) - WW(I+1)
                      WW(I) = WW(I) - WW(I+1)
              50 CONTINUE
          51 CONTINUE
     997 CONTINUE                                                          
         DO 500 J=1,IDAR                                                   
                W(1,J) = WW(J)                                                    
                JLX = MIN0(IAR,IDP1 - J)                                          
                IF(IAR .EQ. 0) GO TO 500                                          
                DO 400 JY=1,JLX                                                   
!cxx  400 W(1,J) = W(1,J) - AR(JY)*WW(J+JY)                                 
                       W(1,J) = W(1,J) - AR(JY)*WW(J+JY)
            400 CONTINUE
       500 CONTINUE                                                          
  998 CONTINUE                                                          
    END SUBROUTINE
    
                                                               
    SUBROUTINE  INIT(W,LENGTH,DOP,ISTEP)                              
         
          INTEGER(kind=4) :: LENGTH, ISTEP
          REAL(kind=8), dimension(LENGTH) :: W 
          REAL(kind=8), dimension((LENGTH-1)*ISTEP+1) :: DOP
          !DIR$ ASSUME_ALIGNED W:64,DOP:64
          ! Locals
          INTEGER(kind=4) :: J,ITEM,K
          REAL(kind=8) :: SUM
          REAL(kind=8) :: DDOP(LENGTH)
!DIR$     ATTRIBUTES ALIGN : 64 :: DDOP
          J=1                                                               
          DO 1 I=1,LENGTH                                                   
                DDOP(I)=DOP(J)                                                    
!cxx    1 J=J+ISTEP
                J=J+ISTEP
       1  CONTINUE
          DO 20 J=1,LENGTH                                                  
                SUM = 0.0_8                                                        
                ITEM = 0
                !DIR$ VECTOR ALIGNED
                !DIR$ SIMD REDUCTION(+:SUM)
                DO 10 K=J,LENGTH                                                  
                      ITEM=ITEM+1                                                       
!cxx   10 SUM=SUM-W(K)*DDOP(ITEM)
                      SUM=SUM-W(K)*DDOP(ITEM)
             10 CONTINUE
!cxx   20 W(J)=SUM
                W(J)=SUM
         20 CONTINUE
    END SUBROUTINE
    
                                                                   
                                                                       
    SUBROUTINE  EXHSLD(H1,N1,H2,N2,H3,N3,H4,M1,IPOS)                  
                        
          INTEGER(kind=4) :: N1, N2, N3, M1, IPOS
          REAL(kind=8), dimension(N1,IPOS)    :: H1
          REAL(kind=8), dimension(N2,N2+IPOS) :: H2
          REAL(kind=8), dimension(N3)         :: H3 
          REAL(kind=8), dimension(N2)         :: H4
          !DIR$ ASSUME_ALIGNED H1:64,H2:64,H3:64,H4:64
          ! Locals
          INTEGER(kind=4) :: M0,J,MM,JP1,M,K
          REAL(kind=8) :: EPS, SQD, C, D, F
          DATA EPS/1.0E-30_8/                                                  
          IF(IPOS .LE. M1) GO TO 30                                         
          M1 = IPOS                                                         

         H1(1:N1,M1) = 0._8
         H2(1:N2,M1+N2) = 0._8
      30 CONTINUE                                                          
         IF(N3 .LT. 0) RETURN                                              
         M0 = IPOS - N3                                                    
         DO 100 J=1,N3                                                     
                MM = M0 + J                                                       
                IF(DABS(H3(J)).LT.EPS)GO TO 100                                   
                D = H1(1,MM)**2 + H3(J)**2                                        
                SQD = DSQRT(D)                                                    
                IF(H1(1,MM).GT.0._dp) SQD=-SQD                                     
                C = D - SQD*H1(1,MM)                                              
                D = H1(1,MM) - SQD                                                
                H1(1,MM) = SQD                                                    
                JP1=J+1                                                           
                IF(JP1.GT.N3)GO TO 60                                             
                M = 1                                                             
                DO 50 K=JP1,N3                                                    
                      M = M + 1                                                         
                      IF(M .GT. N1) GO TO 60                                            
                      F = D*H1(M,MM) + H3(J)*H3(K)                                      
                      F = F/C                                                           
                      H1(M,MM) = H1(M,MM) - D*F                                         
!cxx   50 H3(K) = H3(K) - H3(J)*F                                           
                      H3(K) = H3(K) - H3(J)*F
              50 CONTINUE
60               CONTINUE 
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                 
           DO 70 K=1,N2                                                      
                 F = D*H2(K,MM) + H3(J)*H4(K)                                      
                 F = F/C                                                           
                 H2(K,MM) = H2(K,MM) - D*F                                         
!cxx   70 H4(K) = H4(K) - H3(J)*F                                           
                 H4(K) = H4(K) - H3(J)*F
           70 CONTINUE
      100 CONTINUE                                                          
          DO 200 J=1,N2                                                     
                 MM = M1 + J                                                       
                 IF(DABS(H4(J)).LT.EPS)GO TO 200                                   
                 D = H2(J,MM)**2 + H4(J)**2                                        
                 SQD = DSQRT(D)                                                    
                 IF(H2(J,MM).GT.0.D0) SQD=-SQD                                     
                 C = D - SQD*H2(J,MM)                                              
                 D = H2(J,MM) - SQD                                                
                 H2(J,MM) = SQD                                                    
                 IF(J .GE. N2) GO TO 200                                           
                 JP1 = J + 1 
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                     
                 DO 150 K=JP1,N2                                                   
                        F = D*H2(K,MM) + H4(J)*H4(K)                                      
                        F = F/C                                                           
                        H2(K,MM) = H2(K,MM) - D*F                                         
!cxx  150 H4(K) = H4(K) - H4(J)*F                                           
                        H4(K) = H4(K) - H4(J)*F
               150 CONTINUE
         200 CONTINUE                                                          
    END SUBROUTINE
    
                
    SUBROUTINE SETX(H1,N1,H2,N2,M1,ICOUNT,FTRN,N,H,NH,WT,Y,          &
                    NDATA,RLIM,WEEK,IY,ALNDTD,F,DD,IART,ARFT,        &
                    ALPHA,WTRD,DELTA,IP,ID,YEAR,NPF              )
                  

          INTEGER(kind=4) :: N1, N2, M1, ICOUNT, N, NH, NDATA, IY, IART,   &
                           IP, ID, YEAR, NPF
          REAL(kind=8), dimension(N1,1)    ::  H1 
          REAL(kind=8), dimension(N2,N+8)  ::  H2
          REAL(kind=8), dimension(ID+3)    ::  FTRN 
          REAL(kind=8), dimension(NH,N)    ::  H 
          REAL(kind=8), dimension(ID+IART) ::  TI
          REAL(kind=8) :: WT
          REAL(kind=8), dimension(NDATA)   :: Y
          REAL(kind=8) :: RLIM
          REAL(kind=8), dimension(IY,N)    :: WEEK
          REAL(kind=8) :: ALNDTD
          REAL(kind=8), dimension(NPF+1)   :: F
          REAL(kind=8) :: DD
          REAL(kind=8), dimension(3)       :: ARFT
          REAL(kind=8) :: ALPHA, WTRD, DELTA
          !DIR$ ASSUME_ALIGNED H1:64,H2:64
          !DIR$ ASSUME_ALIGNED FTRN:64,H:64
          !DIR$ ASSUME_ALIGNED H:64,TI:64
          !DIR$ ASSUME_ALIGNED Y:64,WEEK:64,F:64
          ! Locals
          INTEGER(kind=4) :: J,I,N2M1,N2,ITEM,IDAR,ID0,IPOS,K,  &
                           JTEM,J0,NMK,KP1
          REAL(kind=8) :: TEM,TEMO
          REAL(kind=8), dimension(N1)            ::  H3 
          REAL(kind=8), dimension(N2)            ::  H4 
          REAL(kind=8), dimension(2*(ID+IART+1)) ::  T0
!DIR$     ATTRIBUTES ALIGN : 64 :: H3,H4,T0
          ! Exec code ...
          H2(1:N2,N2)=0._8
          IF(YEAR .EQ. 0) GO TO 200                                         
          TEMO=WTRD                                                         
          TEM=-TEMO/7._8                                                  
          DO 300 J=1,7 
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
             DO 400 I=1,7                                                      
!cxx  400 H2(I,J)=TEM                                                       
                    H2(I,J)=TEM
         400 CONTINUE
             H2(8,J)=TEM*DELTA                                                 
!cxx  300 H2(J,J)=H2(J,J)+TEMO                                              
             H2(J,J)=H2(J,J)+TEMO
     300  CONTINUE
!cc      CALL HUSHLD(H2,8,8,8,0)                                           
          CALL BHUSHLD(H2,8,8,8,0)
!cxx      DO 500 I=1,N2                                                     
          DO 501 I=1,N2
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
             DO 500 J=1,I                                                      
                    TEM=H2(I,J)                                                       
                    H2(I,J)=H2(J,I)                                                   
!cxx  500 H2(J,I)=TEM                                                       
                    H2(J,I)=TEM
           500 CONTINUE
    501   CONTINUE
          N2M1=N2-1
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:ALNDTD)          
          DO 550 J=1,N2M1                                                   
                   TEM=DABS(H2(J,J))                                                 
!cxx  550 ALNDTD=ALNDTD+DLOG(TEM)                                           
                   ALNDTD=ALNDTD+DLOG(TEM)
     550  CONTINUE
     200  CONTINUE                                                          
          ITEM=2                                                            
          IF(IP.EQ.1)ITEM=1                                                 
          CALL SETD(T0,ITEM,ID,WT,IART,ARFT)                                
          IDAR = ID + IART
!DIR$ VECTOR ALIGNED          
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))         
          DO 10 I=1,IDAR                                                    
!cxx   10 TI(I) = FTRN(I)*ALPHA
               TI(I) = FTRN(I)*ALPHA
     10   CONTINUE
          CALL INIT(TI,IDAR,T0,ITEM)                                        
          ICOUNT=0                                                          
          M1=0                                                              
          ID0=IDAR*ITEM+1                                                   
          IPOS=0                                                            
          K=0                                                               
          DO 100 I=1,N                                                      
                 IPOS = IPOS + 1                                                   
                 N3 = IPOS                                                         
                 IF(N3 .GT. ID0) N3 = ID0                                          
                 JTEM = ID0 - N3                                                   
                 DO 110 J=1,N3                                                     
                        JTEM = JTEM + 1                                                   
!cxx  110 H3(J) = T0(JTEM)                                                  
                        H3(J) = T0(JTEM)
             110 CONTINUE
!cxx      DO 120 J=1,N2                                                     
!cxx  120 H4(J) = 0.D0                                                      
          H4(1:N2) = 0._8
          IF(I .GT. IDAR) GO TO 125                                         
          H4(N2)=TI(I)
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 121 J=1,N3                                                     
!cxx  121 H3(J)=H3(J)*ALPHA
                 H3(J)=H3(J)*ALPHA
       121 CONTINUE
       125 CONTINUE                                                          
           CALL EXHSLD(H1,N1,H2,N2,H3,N3,H4,M1,IPOS)                         
           N3 = -1                                                           
           IF(IP .GT. 1) IPOS=IPOS+1                                         
           IF(I .GT. NDATA) GO TO 90                                         
           IF(Y(I) .GT. RLIM .AND. RLIM .GT. 0._dp) GO TO 90                  
           ICOUNT=ICOUNT+1                                                   
           N3 = ITEM                                                         
           H3(1) = 1._8                                                     
           IF(IP.NE.1) H3(2) = 1._dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))           
           DO 30 J=1,N2                                                      
                   IF(J .LT. N2) H4(J) = WEEK(J,I)                                   
                   IF(J .EQ. N2) H4(J) = Y(I)                                        
        30 CONTINUE                                                          
        90 CALL EXHSLD(H1,N1,H2,N2,H3,N3,H4,M1,IPOS)                         
           IF(IP .EQ. 1) GO TO 100                                           
           IF(IPOS .LE. N1) GO TO 100                                        
           K=K+1                                                             
           J0=0                                                              
           DO 91 J=1,N1                                                      
                 IF(MOD(J,2) .EQ. 0) GO TO 911                                     
                 J0=J0+1                                                           
                 H3(J)=H(J0,K)*DD                                                  
                 GO TO 91                                                          
             911 H3(J)=0._8                                                      
        91 CONTINUE                                                          
!cxx      DO 92 J=1,N2                                                      
!cxx   92 H4(J)=0.D0                                                        
          H4(1:N2)=0._8
          H4(N2)=F(K)*DD                                                    
          CALL EXHSLD(H1,N1,H2,N2,H3,N1,H4,M1,IPOS)                         
      100 CONTINUE                                                          
          IF(IP .EQ. 1) RETURN                                              
          NMK=N1                                                            
          KP1=K+1                                                           
          DO 95 K=KP1,N                                                     
                NMK=NMK-2                                                         
                J0=0                                                              
                DO 96 J=1,NMK                                                     
                      IF(MOD(J,2).EQ.0)GO TO 93                                         
                      J0=J0+1                                                           
                      H3(J)=H(J0,K)*DD                                                  
                      GO TO 96                                                          
             93 H3(J)=0.0_8                                                       
             96 CONTINUE                                                          
!cxx      DO 97 L=1,N2                                                      
!cxx   97 H4(L)=0.D0
                H4(1:N2)=0._8
                H4(N2)=F(K)*DD                                                    
!cxx   95 CALL EXHSLD(H1,N1,H2,N2,H3,NMK,H4,M1,M1)                          
                CALL EXHSLD(H1,N1,H2,N2,H3,NMK,H4,M1,M1)
         95 CONTINUE
    END SUBROUTINE
                    

      SUBROUTINE SETDC(H1,N1,H2,M1,FSEAS,N,WS,WZ,IARS,ARFS,IARN,      &
                        ARFN,BETA,GAMMA,IP,IS,NPF                   )
                       
          
          INTEGER(kind=4) :: N1, M1, N, IARS, IARN, IP, IS, NPF
          REAL(kind=8), dimension(N1,1)  :: H1 
          REAL(kind=8), dimension(NPF+1) :: H2 
          REAL(kind=8), dimension((IS+IARS)*IP + IARN) :: FSEAS  
          REAL(kind=8) :: WS, WZ
          REAL(kind=8), dimension(3) :: ARFS,ARFN
          REAL(kind=8) :: BETA, GAMMA
          !DIR$ ASSUME_ALIGNED H1:64
          !DIR$ ASSUME_ALIGNED H2:64
          !DIR$ ASSUME_ALIGNED FSEAS:64
          ! Locals
          INTEGER(kind=4) :: IPIS, IPM1, ITEM, I, LENGTH, LTEM,  &
                           J, IS0, IZ0, IPOS, N3
          REAL(kind=8) :: SUM, DT
          REAL(kind=8), dimension((IS+IARS)*IP+IARN+1)   :: H3
          REAL(kind=8), dimension(1)                     :: h4 
          REAL(kind=8), dimension(IP)                    :: Z0,ZI
          REAL(kind=8), dimension((IS+IARS+1)*IP+IARN+1) :: S0
          REAL(kind=8), dimension((IS+IARS)*IP+IARN)     :: SI
!DIR$     ATTRIBUTES ALIGN : 64 :: H3,Z0,ZI,S0,SI    
          ! Exec code ....                           
          IPIS = (IS+IARS)*IP + IARN                                        
          IPM1 =IP - 1                                                      
          ITEM = IP*(IS-1) + 1
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 30 I=1,IPM1                                                    
                ITEM = ITEM + 1                                                   
!cxx   30 ZI(I) = FSEAS(ITEM)*WZ*GAMMA                                      
                ZI(I) = FSEAS(ITEM)*WZ*GAMMA
      30  CONTINUE
          SUM = 0._8                                                      
          ITEM = IP
!DIR$    VECTOR ALIGNED          
!DIR$    SIMD REDUCTION(+:SUM) 
          DO 40 I=1,IPM1                                                    
                 ITEM = ITEM - 1                                                   
                 SUM = SUM - ZI(ITEM)                                              
!cxx   40 ZI(ITEM) = SUM                                                    
                 ZI(ITEM) = SUM 
     40   CONTINUE
          CALL SETD(S0,IP,IS,WS,IARS,ARFS)                                  
          IF(IARN .EQ. 0) GO TO 49                                          
          LENGTH = IPIS + 1                                                 
          LTEM = LENGTH - IARN                                              
          DO 41 I=1,LTEM                                                    
                  S0(LENGTH)=S0(LENGTH - IARN)                                      
!cxx   41 LENGTH = LENGTH - 1                                               
                  LENGTH = LENGTH - 1 
       41 CONTINUE
!cxx      DO 42 I=1,IARN                                                    
!cxx   42 S0(I)=0.D0
          S0(1:IARN)=0._8
          LENGTH = IPIS + 1                                                 
          DO 400 I=1,LENGTH                                                 
                   DT=S0(I)                                                          
                   DO 410 J=1,IARN                                                   
!cxx  410 IF(I+J .LE. LENGTH) DT=DT-ARFN(J)*S0(I+J)                         
                           IF(I+J .LE. LENGTH) DT=DT-ARFN(J)*S0(I+J)
               410 CONTINUE
!cxx  400 S0(I)=DT                                                          
                  S0(I)=DT
     400  CONTINUE
      49  CONTINUE                                                          
          IF(IPIS .EQ. 0) GO TO 998
!DIR$  VECTOR ALIGNED                  
!DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 20 I=1,IPIS                                                    
!cxx   20 SI(I) = FSEAS(I)*BETA                                             
               SI(I) = FSEAS(I)*BETA
      20  CONTINUE
          CALL INIT(SI,IPIS,S0,1)
!DIR$  VECTOR ALIGNED               
!DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
  998     DO 50 I=1,IP                                                      
              Z0(I)=WZ                                                          
      50  CONTINUE                                                          
!cxx   55 CONTINUE                                                          
          IS0 = IPIS + 1                                                    
          IZ0 = IP                                                          
          M1 = 0                                                            
          IPOS=0                                                            
          H2(1) = 0._8                                                    
          DO 100 I=1,N                                                      
                IPOS = I                                                          
                N3 = IPOS                                                         
                IF(N3 .GT. IS0) N3 = IS0                                          
                ITEM = IS0 - N3                                                   
                DO 130 J=1,N3                                                     
                       ITEM = ITEM + 1                                                   
!cxx  130 H3(J) = S0(ITEM)                                                  
                       H3(J) = S0(ITEM)
            130 CONTINUE
                H4(1) = 0._8                                                   
                IF(I .GT. IPIS) GO TO 145                                         
                H4(1)=SI(I)
!DIR$  VECTOR ALIGNED                
!DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))                
                DO 141 J=1,N3                                                     
!cxx  141 H3(J)=H3(J)*BETA
                  H3(J)=H3(J)*BETA
            141 CONTINUE
    145   CONTINUE                                                          
          CALL EXHSLD(H1,N1,H2,1,H3,N3,H4,M1,IPOS)                          
          N3 = IPOS                                                         
          IF(N3 .GT. IZ0) N3 =IZ0                                           
          ITEM = IZ0 - N3                                                   
          DO 150 J=1,N3                                                     
                 ITEM = ITEM + 1                                                   
!cxx  150 H3(J) = Z0(ITEM)                                                  
                 H3(J) = Z0(ITEM)
      150 CONTINUE
                 H4(1) = 0._8                                                    
          IF(I .GE. IP) GO TO 165                                           
          H4(1)=ZI(I)
!DIR$  VECTOR ALIGNED          
!DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 161 J=1,N3                                                     
!cxx  161 H3(J)=H3(J)*GAMMA                                                 
                  H3(J)=H3(J)*GAMMA
        161 CONTINUE
     165  CONTINUE                                                          
          CALL EXHSLD(H1,N1,H2,1,H3,N3,H4,M1,IPOS)                          
     100 CONTINUE                                                          
    END SUBROUTINE
                        
    SUBROUTINE PARTAR(R,A,M)                                          
!C **** PARCOR R TO AR ********                                          
                                          
          INTEGER(kind=4) :: M
          REAL(kind=8), dimension(M)   ::  R
          REAL(kind=8), dimension(M,M) ::  A
          !DIR$ ASSUME_ALIGNED R:64,A:64
          ! Locals
          INTEGER(I32P) :: I,J,IM1
          DO 20 I=1,M
!DIR$  VECTOR ALIGNED             
!DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))              
             DO 10 J=1,I                                                       
!cxx   10 A(I,J)=0.D0
                A(I,J)=0._8
10              CONTINUE
      20  CONTINUE
          A(1,1)=R(1)                                                       
          IF(M.LE.1) RETURN                                                 
          DO 40 I=2,M                                                       
                A(I,I)=R(I)                                                       
                IM1=I-1                                                           
                DO 30 J=1,IM1                                                     
!cxx   30 A(I,J)=A(I-1,J)-R(I)*A(I-1,I-J)                                   
                      A(I,J)=A(I-1,J)-R(I)*A(I-1,I-J)
               30 CONTINUE
      40 CONTINUE                                                          
    END SUBROUTINE
    
                
    SUBROUTINE BSOLVE(H1,N1,H2,N2,A,M1,SQE,NANS,ERR)
         
      INTEGER(kind=4) :: N1, N2, M1 ,NANS
      REAL(kind=8), dimension(N1,N2+M1) ::  H1 
      REAL(kind=8), dimension(N2,N2+M1) ::  H2 
      REAL(kind=8), dimension(NANS)     ::  A,ERR SQE
      !DIR$ ASSUME_ALIGNED H1:64,H2:64
      !DIR$ ASSUME_ALIGNED A:64,ERR:64,SQE:64
      REAL(kind=8) :: SQE
      ! Locals
      INTEGER(kind=4) :: LER,K,JJ,KA,KAM1,KKA,J,KCOPY,KM1,LTEM,KATEM, &
                       N2MJ,L
      REAL(kind=8) :: AKA

      ERR(1:NANS)=0.0_8
      DO 100 LER = 1, NANS                                              
         K = M1 + N2                                                    
         KA = NANS                                                      
         JJ = NANS - 1                                                  
         IF( LER.EQ.NANS )  GO TO 44                                    
            SQE = 0._8                                               
            KAM1 = KA - 1                                               
!cxx            DO 40 KKA = 1, KAM1                                         
!cxx   40       A(KKA) = 0.D0
            A(1:KAM1) = 0._8                                               
            A(LER) = 1._8                                              
            GO TO 48                                                    
   44    CONTINUE                                                       
            SQE = H2(N2,K)**2                                           
            KKA = KA                                                    
            KK  = K                                                     
            DO 46 J = 1, JJ                                             
               KK = KK - 1                                              
               KKA = KKA - 1                                            
               A(KKA) = H2(N2,KK)                                       
   46       CONTINUE                                                    
   48    CONTINUE                                                       
!C                                                                       
         KCOPY = K                                                      
         DO 50 J = 1, JJ                                                
            KA = KA - 1                                                 
            IF( A(KA).EQ.0._8 )  GO TO 50                               
            K = KCOPY - J                                               
            IF( J.GE.N2 )  GO TO 20                                     
!C                                                                       
            A(KA) = A(KA)/H2(N2-J,K)                                    
            IF( LER.LT.NANS )  ERR(KA) = ERR(KA) + A(KA)**2             
            KM1 = KA - 1                                                
            IF( KM1.LE.0 )  GO TO 50                                    
            LTEM = K                                                    
            KATEM = KA                                                  
            AKA = A(KA)                                                 
            N2MJ = N2-J                                                 
            DO 10 L = 1, KM1                                            
               KATEM = KATEM - 1                                        
               LTEM = LTEM - 1                                          
               A(KATEM) = A(KATEM) - AKA*H2(N2MJ,LTEM)                  
   10       CONTINUE                                                    
            GO TO 50                                                    
!C                                                                       
   20      A(KA) = A(KA)/H1(1,K)                                        
            IF( LER.LT.NANS )  ERR(KA) = ERR(KA) + A(KA)**2             
            LTEM = K                                                    
            L = KA                                                      
            IF( N1.LT.2 )  GO TO 50                                     
            DO 25 I = 2, N1                                             
               L = L - 1                                                
               LTEM = LTEM - 1                                          
               IF( L.LE.0 )  GO TO 50                                   
               A(L) = A(L) - A(KA)*H1(I,LTEM)                           
   25       CONTINUE                                                    
   50    CONTINUE                                                       
  100 CONTINUE                                                          
!C                                                                       
    END SUBROUTINE
    
    SUBROUTINE BISPECF(N,MH,CC0,C0,P1,P2,Q,A,BR,BI,RAT)

         
!C
!cc	   PROGRAM BISPEC
!C     PROGRAM 74.6.2.
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(2
!C         BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C         NO.6 MARCH 1976, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C-----------------------------------------------------------------------
!C      THIS PROGRAM COMPUTES BISPECTRUM USING THE DIRECT FOURIER TRANSFOR
!C      OF SAMPLE THIRD ORDER MOMENTS.
!C      THIS PROGRAM REQUIRES THE FOLLOWING INPUTS;
!C      OUTPUTS OF THE PROGRAM THIRMO:
!C      N; DATA LENGTH,
!C      MH; MAXIMUM LAG,
!C      CC(I); AUTOCOVARIANCES,
!C      C(I,J); THIRD ORDER MOMENTS.
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: BISPECF
!C

          INTEGER(kind=4) :: N, MH
          REAL(kind=8), dimension(MH+1)      :: CC0, P1, P2, Q 
          REAL(kind=8), dimension(MH+1,MH+1) :: C0, A, BR, BI
          !DIR$ ASSUME_ALIGNED CC0:64
          !DIR$ ASSUME_ALIGNED P1:64
          !DIR$ ASSUME_ALIGNED P2:64
          !DIR$ ASSUME_ALIGNED Q:64
          !DIR$ ASSUME_ALIGNED C0:64
          !DIR$ ASSUME_ALIGNED A:64
          !DIR$ ASSUME_ALIGNED BR:64
          !DIR$ ASSUME_ALIGNED BI:64
          REAL(kind=8) :: RAT
          ! Locals
          INTEGER(kind=4) :: MH1,MJ1,L1,I,J,I2H,IS,ID,IR,   &
                           MMS1,NS1,MS,MC1,MC2,MC3,IRL,   &
                           MD,MS,MR,MDR,MDS,MSR,MSD,MRD,  &
                           MRS,NS,MMS
          REAL(kind=8) ::   CST0, CST1, CST2, CST6, CST2I, CST6I, H, PI, PP, AI,  &
                          T, C00, SL0, TC1, TC2, TC3, TS1, TS3, CN0, SN0
          REAL(kind=8), dimension(MH+1,MH+1) :: C, CL, SL, CA1, CA2 
          REAL(kind=8), dimension((MH+1)*2)  :: C1,S1
          REAL(kind=8)  dimension(MH+1)      :: CC
!DIR$     ATTRIBUTES ALIGN : 64 :: C,CL,SL,CA1,CA2
!DIR$     ATTRIBUTES ALIGN : 64 :: C1,S1,CC
          ! Exec code ...
          MH1 = MH+1
          A(1:MH1,1:MH1)  = 0.0_8
          BR(1:MH1,1:MH1) = 0.0_8
          BI(1:MH1,1:MH1) = 0.0_8
          CL(1:MH1,1:MH1) = 0.0_8
          SL(1:MH1,1:MH1) = 0.0_8

          CST0 =0.0_8
          CST1 =1.0_8
          CST2 =2.0_8
          CST6 =6.0_8
          CST2I=1.0_8/CST2
          CST6I=1.0_8/CST6
!C     INITIAL LOADING
!C     AUTOCOVARIANCE AND THIRD ORDER MOMENT INPUT

          L1=MH+1

          H=MH

         DO 11 I=1,L1
!cc   10 READ(5,2) (C(I,J),J=1,I)
                CC(I)=CC0(I)
!DIR$  VECTOR ALIGNED
!DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 10 J=1,I
                      C(I,J)=C0(I,J)
             10 CONTINUE
       11 CONTINUE

!C     AUTOCOVARIANCES PRINT OUT

!C     POWER SPECTRUM COMPUTATION

          CALL SAUSP1(CC,P1,P2,Q,N,L1,L1)
!C     THIRD ORDER MOMENTS PRINT OUT

          C(1,1)=C(1,1)*CST6I
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 112 I=2,L1
                 C(I,1) =C(I,1)*CST2I
                 C(I,I)=C(I,I)*CST2I
!cxx  112 C(L1,I)=C(L1,I)*CST2I
                 C(L1,I)=C(L1,I)*CST2I
      112 CONTINUE
          C(L1,1) =C(L1,1)*CST2I
!C     FOURIER TRANSFORMATION
          PI=3.141592653_8
          PP=PI/H
          I2H=MH+MH
          DO 115 I=1,I2H
                 AI=I
                 T=PP*AI
                 C1(I)=DCOS(T)
!cxx  115 S1(I)=DSIN(T)
                 S1(I)=DSIN(T)
     115  CONTINUE
!C     CL(0,0) COMPUTATION
          C00 =CST6*C(1,1)
          SL0 =CST0
          IS=0
          ID=0
          IR=0
          TC1 =CST0
          DO 600 MMS1=1,L1
                 TC2=CST0
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:TC2)
                 DO 610 NS1=1,MMS1
!cxx  610 TC2=TC2+C(MMS1,NS1)
                        TC2=TC2+C(MMS1,NS1)
             610 CONTINUE
           TC1=TC1+TC2
       600 CONTINUE
           CL(1,1)=CST6*TC1
!C     CL(IS,0) COMPUTATION
           DO 120 IS=1,MH
                  ID=IS
                  TC3=CST0
                  MS=0
                  DO 122 MMS=1,MH
                         MS=MS+IS
                         IF(MS.LE.I2H) GO TO 461
                         MS=MS-I2H
                     461 MC1=MS
                         MC2=MS
                         MC3=0
                         TC2 =C(MMS+1,1)*(C1(MC1)+C1(MC2)+CST1)
                         TC1 =CST0
                         DO 123 NS=1,MMS
                                MC2=MC2-IS
                                MC3=MC3+IS
                                IF(MC2.GT.0) GO TO 561
                                MC2=MC2+I2H
                            561 IF(MC3.LE.I2H) GO TO 562
                                MC3=MC3-I2H
                            562 TC1=TC1+C(MMS+1,NS+1)*(C1(MC1)+C1(MC2)+C1(MC3))
                    123 CONTINUE
                        TC3=TC3+TC2+TC1
             122 CONTINUE
          IS1=IS+1
          CL(IS1,1)=C00+TC3+TC3
          CL(1,IS1)=CL(IS1,1)
          SL(IS1,1) =CST0
          SL(1,IS1)=SL(IS1,1)
  120     CONTINUE
!C     CL(ID,IR),SL(ID,IR) COMPUTATION
          DO 20 IS=2,MH
                IRL=IS/2
                DO 21 IR=1,IRL
                      TC3=CST0
                      TS3 =CST0
                      ID=IS-IR
                      MD=0
                      MS=0
                      MR=0
                      DO 22 MMS=1,MH
                            MD=MD+ID
                            MS=MS-IS
                            MR=MR+IR
                            IF(MD.LE.I2H) GO TO 401
                            MD=MD-I2H
                        401 IF(MS.GT.0) GO TO 412
                            MS=MS+I2H
                        412 IF(MR.LE.I2H) GO TO 413
                            MR=MR-I2H
                        413 MDR=MD
                            MDS=MDR
                            MSR=MS
                            MSD=MSR
                            MRD=MR
                            MRS=MRD
                            CN0=C(MMS+1,1)*(C1(MDR)+C1(MDS)+C1(MSR)+C1(MSD)+C1(MRD)+C1(MRS))
                            SN0=C(MMS+1,1)*(S1(MDR)+S1(MDS)+S1(MSR)+S1(MSD)+S1(MRD)+S1(MRS))
                            TC1 =CST0
                            TS1=CST0
                            DO 23 NS=1,MMS
                                  MSD=MSD+ID
                                  MRD=MRD+ID
                                  MDR=MDR+IR
                                  MSR=MSR+IR
                                  MDS=MDS-IS
                                  MRS=MRS-IS
                                  IF(MSD.LE.I2H) GO TO 501
                                  MSD=MSD-I2H
                              501 IF(MRD.LE.I2H) GO TO 511
                                  MRD=MRD-I2H
                              511 IF(MDR.LE.I2H) GO TO 521
                                  MDR=MDR-I2H
                              521 IF(MSR.LE.I2H) GO TO 531
                                  MSR=MSR-I2H
                              531 IF(MDS.GT.0) GO TO 542
                                  MDS=MDS+I2H
                              542 IF(MRS.GT.0) GO TO 552
                                  MRS=MRS+I2H
                              552 TC1=TC1+C(MMS+1,NS+1)*(C1(MSD)+C1(MRD)+C1(MDR)+C1(MSR)+C1(MDS)+C1(AMRS))
     
                                  TS1=TS1+C(MMS+1,NS+1)*(S1(MSD)+S1(MRD)+S1(MDR)+S1(MSR)+S1(MDS)+S1( AMRS))
    
                           23 CONTINUE
                        TC3=TC3+CN0+TC1
                        TS3=TS3+SN0+TS1
                     22 CONTINUE
                    IR1=IR+1
                    ID1=ID+1
                    CL(ID1,IR1)=C00+TC3
                    SL(ID1,IR1)=TS3
                    CL(IR1,ID1)=CL(ID1,IR1)
                    SL(IR1,ID1)=SL(ID1,IR1)
                21 CONTINUE
          20 CONTINUE
!C     SMOOTHING OF THE RAW ESTIMATES
!C     ROWWISE SMOOTHING
             CALL SUBCA(CL,CA1,MH,0)
             CALL SUBCA(SL,CA2,MH,1)
!C     COLUMNWISE SMOOTHING
             CALL SUBCB(CA1,CL,MH)
             CALL SUBCB(CA2,SL,MH)

             CALL SUBCD(CL,CA1,MH,BR)
             CALL SUBCD(SL,CA2,MH,BI)
             CALL SUBQ1(CA1,CA2,P1,N,MH,A,RAT)
    END SUBROUTINE
    
     

    SUBROUTINE SUBCA(CL,CA,MH,ISW)
         
!C     ROWWISE SMOOTHING
!C     CA(I,J)=
!C              (CL(I-1,J)+2.0*CL(I,J)+CL(I+1,J))/4.0
!C     ISW=0: COS
!C     ISW=1: SIN

          INTEGER(kind=4) :: MH, ISW
          REAL(kind=8), dimension(MH+1,MH+1) :: CL, CA
          !DIR$ ASSUME_ALIGNED CL:64,CA:64
          ! Locals
          INTEGER(kind=4) :: L1,JJL,JJ,J,IJ,IL,II,J1,J2,I3,I
          REAL(kind=8) :: CST2, CST4, CST4I
          ! Exec code ....
          CST2=2.0_8
          CST4=4.0_8
          CST4I=1.0_8/CST4
          L1=MH+1
!C     ON AND ABOVE X-AXIS COMPUTATION
          JJL=MH/2+1
          DO 10 JJ=1,JJL
                J=JJ-1
                IF(J.LE.1) GO TO 11
                IJ=J
                GO TO 12
             11 IJ=2
             12 IL=MH-J
                DO 20 II=IJ,IL
                     CA(II,JJ)=       &
                     (CL(II-1,JJ)+CST2*CL(II,JJ)+CL(II+1,JJ))*CST4I
                     I=II-1
             20 CONTINUE
          10 CONTINUE
!C     BELOW X-AXIS
          DO 40 J1=1,2
                JJ=MH/2+J1+1
                J2=J1+2
                DO 41 II=J2,MH
                      I3=II-J1
                      IF(ISW.EQ.1) GO TO 42
                      CA(II,JJ)=CA(I3,J1+1)
                      I=II-1
                      J=-J1
                      GO TO 41
                   42 CA(II,JJ)=-CA(I3,J1+1)
                      I=II-1
                      J=-J1
             41 CONTINUE
          40 CONTINUE
    END SUBROUTINE
    
     

    SUBROUTINE SUBCB(CA,CB,MH)
        
!C     COLUMNWISE SMOOTHING
!C     CB(I,J)=
!C             (CA(I,J-1)+2.0*CA(I,J)+CA(I,J+1))/4.0

          INTEGER(kind=4) :: MH
          REAL(kind=8), dimension(MH+1,MH+1) :: CA, CB
          !DIR$ ASSUME_ALIGNED CA:64,CB:64
          INTEGER(kind=4) :: L1,MHJ,J,MHI,I,IM1,JMI,JJ,JC,JJ1
          REAL(kind=8) :: CST2, CST4, CST4I
          ! Exec code ....
!C     ON AND ABOVE 1-AXIS
          CST2=2.0_8
          CST4=4.0_8
          CST4I=1.0_8/CST4
          L1=MH+1
          MHJ=MH/2
          DO 10 J=2,MHJ
                MHI=MH-J
                DO 11 I=J,MHI
                      CB(I,J)=    &
                          (CA(I,J-1)+CST2*CA(I,J)+CA(I,J+1))*CST4I
                      IM1=I-1
                      JM1=J-1
             11 CONTINUE
       10 CONTINUE
!C     ON 0-AXIS
          MH1=MH-1
          JJ=MH/2+2
          DO 12 I=3,MH1
                CB(I,1)=    &
                   (CA(I,JJ)+CST2*CA(I,1)+CA(I,2))*CST4I
                IM1=I-1
                JC=0
       12 CONTINUE
!C     ON (-1)-AXIS
          JJ1=MHJ+1
          DO 14 I=4,MH
               CB(I,JJ1)=  &
                  (CA(I,JJ+1)+CST2*CA(I,JJ)+CA(I,1))*CST4I
               IM1=I-1
               JC=-1
       14 CONTINUE
    END SUBROUTINE
    


    SUBROUTINE SUBCD(CB,CD,MH,B)
         
!C     OBLIQUE SMOOTHING
!C     CD(I,J)=
!C             (CB(I-1,J-1)+2.0*CB(I,J)+CB(I+1,J+1))/4.0

          INTEGER(kind=4) :: MH
          REAL(kind=8), dimension(MH+1,MH+1) :: CB, CD
          REAL(kind=8), dimension(0:MH,0:MH) :: B
          !DIR$ ASSUME_ALIGNED CB:64,CD:64
          !DIR$ ASSUME_ALIGNED B:64
          ! Loals
          INTEGER(kind=4) :: L1,JL,J,IL,I,IM1,JM1,MH4,JC,MH3,JJ1
          REAL(kind=8) :: CST2, CST4, CST4I, CZ
          ! Exec code ....
          CST2=2.0_8
          CST4=4.0_8
          CST4I=1.0_8/CST4
          CZ=0.0_8
!cc      CALL BISPPR (KANA1,0,CZ,0)
          L1=MH+1
!C     ON AND ABOVE 2-AXIS
          JL=MH/2-1
          DO 10 J=3,JL
                IL=MH-2-J
                DO 11 I=J,IL
                      CD(I,J)=   &
                      (CB(I-1,J-1)+CST2*CB(I,J)+CB(I+1,J+1))*CST4I
                      IM1=I-1
                      JM1=J-1
                      CZ=CD(I,J)
!cc      CALL BISPPR (IM1,JM1,CZ,1)
                      B(IM1,JM1)=CZ
             11 CONTINUE
       10 CONTINUE
!C     ON 1-AXIS
          MH4=MH-4
          DO 12 I=4,MH4
                CD(I,2)=    &
                (CB(I-1,1)+CST2*CB(I,2)+CB(I+1,3))*CST4I
                IM1=I-1
                JC=1
                CZ=CD(I,2)
!cc      CALL BISPPR(IM1,JC,CZ,1)
                B(IM1,JC)=CZ
       12 CONTINUE
!C     ON 0-AXIS
          MH3=MH-3
          JJ1=MH/2+1
          DO 14 I=5,MH3
                CD(I,1)=  &
                (CB(I-1,JJ1)+CST2*CB(I,1)+CB(I+1,2))*CST4I
                IM1=I-1
                JC=0
                CZ=CD(I,1)
!cc      CALL BISPPR (IM1,JC,CZ,1)
                B(IM1,JC)=CZ
       14 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE SUBQ1(CL,SL,P,N,MH,A,RAT)
         
!C     A MEASURE OF COHERENCE BETWEEN X(I)X(J) AND X(I+J) IS GIVEN BY Q1(
!C     WHICH IS DEFINED BY
!C     Q1(I,J)=(CL(I,J)**2+SL(I,J)**2)/(P(I)P(J)P(I+J)MH).

          INTEGER(kind=4) :: N, MH
          REAL(kind=8), dimension(MH+1,MH+1) :: CL, SL
          REAL(kind=8), dimension(MH+1)      ::  P
          REAL(kind=8), dimension(0:MH,0:MH) :: A
          !DIR$ ASSUME_ALIGNED CL:64,SL:64
          !DIR$ ASSUME_ALIGNED P:64,A:64
          REAL(kind=8) :: RAT
          ! Locals
          INTEGER(kind=4) :: L1,JL,J,I4,I,IL,MH3,IM1,JM1,JC,MH4,JJ1
          REAL(kind=8) :: H, CZ, AN, AS3, CST075

          L1=MH+1
          H = MH
          CZ = 0.0_8

!C     ON AND ABOVE 2-AXIS
          JL=MH/2-1
!cxx       DO 10 J=3,JL
          DO 11 J=3,JL
             IL=MH-2-J
!DIR$ VECTOR ALIGNED             
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 10 I=J,IL
                      I4=I+J-1
                      CL(I,J)=(CL(I,J)*CL(I,J)+SL(I,J)*SL(I,J))/P(I)/P(J)/P(I4)/H
                      IM1=I-1
                      JM1=J-1
                      CZ=CL(I,J)
!cc      CALL BISPPR (IM1,JM1,CZ,1)
                      A(IM1,JM1)=CZ
               10 CONTINUE
       11 CONTINUE
!C     ON 1-AXIS
          MH4=MH-4
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 12 I=4,MH4
                I4=I+1
                CL(I,2)=(CL(I,2)*CL(I,2)+SL(I,2)*SL(I,2))/P(I)/P(2)/P(I4)/H
                IM1=I-1
                JC=1
                CZ=CL(I,2)
!cc      CALL BISPPR (IM1,JC,CZ,1)
                A(IM1,JC)=CZ
       12 CONTINUE
!C     ON 0-AXIS
          MH3=MH-3
          JJ1=MH/2+1
          DO 14 I=5,MH3
                IM1=I-1
                CL(I,1)=(CL(I,1)*CL(I,1)+SL(I,1)*SL(I,1))/P(I)/P(I)/P(1)/H
                JC=0
                CZ=CL(I,1)
!cc      CALL BISPPR (IM1,JC,CZ,1)
                A(IM1,JC)=CZ
       14 CONTINUE
          AN=N
          AS3 =3.0_8
          CST075=0.75_8
          RAT=(H/AN)*CST075*CST075/DSQRT(AS3)
!cc      WRITE(6,186) RAT
    END SUBROUTINE
    

    SUBROUTINE SAUSP1(CXX,P1,P2,Q,N,LAGH3,LAGH1)
      
!C     THIS SUBROUTINE COMPUTES POWER SPECTRUM.

          INTEGER(kind=4) :: N, LAGH3, LAGH1
          REAL(kind=8), dimension(LAGH1) :: CXX, P1, P2, Q
          !DIR$ ASSUME_ALIGNED CXX:64,P1:64,P2:64,Q:64
          INTEGER(kind=4) :: MLA1,MLA2,LAGH0,I
          REAL(kind=8), dimension(LAGH1) :: FC
          !DIR$ ATTRIBUTES ALIGN : 64 :: FC
          REAL(kind=8), dimension(2)     :: A1 
          REAL(kind=8), dimension(3)     :: A2
!C     WINDOW W1 DEFINITION
          MLA1=2
          A1(1)=0.5_8
          A1(2) =0.25_8
!C     WINDOW W2 DEFINITION
          MLA2=3
          A2(1)=0.625_8
          A2(2)=0.25_8
          A2(3)=-0.0625_8
          LAGH=LAGH1-1
          LAGH0=LAGH3-1
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 10 I=2,LAGH
!cxx   10 CXX(I)=CXX(I)+CXX(I)
                  CXX(I)=CXX(I)+CXX(I)
       10 CONTINUE
!C     F-COS TRANSFORMATION
!C     COMMON SUBROUTINE CALL
          CALL FGERCO(CXX,LAGH1,FC,LAGH1)
!C     SPECTRUM SMOOTHING BY WINDOW W1
!C     COMMON SUBROUTINE CALL
          CALL AUSP(FC,P1,LAGH1,A1,MLA1)
!C     SPECTRUM SMOOTHING BY WINDOW W2
!C     COMMON SUBROUTINE CALL
          CALL AUSP(FC,P2,LAGH1,A2,MLA2)
!C     TEST STATISTICS COMPUTATION
!C     COMMON SUBROUTINE CALL
          CALL SIGNIF(P1,P2,Q,LAGH1,N)
!C     AUTO SPECTRUM AND TEST STATISTICS PRINT OUT

    END SUBROUTINE
    
    
    SUBROUTINE BLOCARF( ZS,N,LAG,NS0,KMAX,ZMEAN,SUM,AIC,C,B,A,SD,NP,    &
                        NE,SXX )

        
!C
!cc      PROGRAM  BLOCAR                                                   
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.3.2.                                                    
!C     _                  ___                __                          
!!C     BAYESIAN METHOD OF LOCALLY STATIONARY AR MODEL FITTING; SCALAR CAS
!C                                                                       
!C     THIS PROGRAM LOCALLY FITS AUTOREGRESSIVE MODELS TO NON-STATIONARY 
!C     SERIES BY A BAYESIAN PROCEDURE.  POWER SPECTRA FOR STATIONARY SPAN
!C     ARE GRAPHICALLY PRINTED OUT.  (THIS PROGRAM IS TENTATIVE.)        
!C                                                                       
!C     INPUTS REQUIRED:                                                  
!C             MT:       INPUT DEVICE FOR ORIGINAL DATA (MT=5 : CARD READ
!C             LAG:      UPPER LIMIT OF THE ORDER OF AR MODEL, MUST BE LE
!C                       OR EQUAL TO 50.                                 
!C             NS:       LENGTH OF BASIC LOCAL SPAN                      
!C             KSW:      =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESS
!C                       =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REG
!C                                                                       
!C               -- THE FOLLOWING INPUTS ARE REQUESTED BY SUBROUTINE REDA
!C             TITLE:    SPECIFICATION OF DATA                           
!C             N:        DATA LENGTH, MUST BE LESS THAN OR EQUAL TO 10000
!C             DFORM:    INPUT DATA SPECIFICATION STATEMENT.             
!C                       -- EXAMPLE  --     (8F10.5)                     
!C             (Z(I),I=1,N):  ORIGINAL DATA                              
!C               --------------------------------------------------------
!C                                                                       
!C                                                                       
!C     AT EACH STAGE OF MODELLING OF LOCAL AR MODEL, A TWO-STEP BAYESIAN 
!C     PROCEDURE IS APPLIED                                              
!C        1.   AVERAGING OF THE MODELS WITH DIFFERENT ORDERS FITTED TO TH
!C             NEWLY OBTAINED DATA (BY SUBROUTINE ARBAYS).               
!C        2.   AVERAGING OF THE MODELS FITTED TO THE PRESENT AND PRECEDIN
!C             (AS FAR AS KMAX(<21)) SPANS.                              
!C     AS TO THE AVERAGING 1, SEE THE COMMENTS OF PROGRAM UNIBAR.        
!C                                                                       
!C     AIC OF THE MODEL FITTED TO THE NEW SPAN IS DEFINED BY             
!C                                                                       
!C          AIC = NS * LOG( SD ) + 2 * EK,                               
!C     WHERE                                                             
!C          NS:     LENGTH OF NEW DATA                                   
!C          SD:     INNOVATION VARIANCE                                  
!C          EK:     EQUIVALENT NUMBER OF PARAMETERS, DEFINED AS THE SUM O
!C                  SQUARES OF THE BAYESIAN WEIGHTS                      
!C                                                                       
!C     AIC OF THE MODELS FITTED TO THE PRECEDING SPANS ARE DEFINED BY    
!C                                                                       
!C          AIC(J+1) = NS * LOG( SD(J) ) + 2     (J=1,KC)                
!C     WHERE                                                             
!C          SD(J):  PREDICTION ERROR VARIANCE BY THE MODEL FITTED TO J   
!C                  PERIODS FORMER SPAN.                                 
!C       --------------------------------------------------------------- 
!C       REFERENCES:                                                     
!C          G.KITAGAWA AND H.AKAIKE(1978), "A PROCEDURE FOR THE MODELING 
!C          OF NON-STATIONARY TIME SERIES.",  ANN. INST. STATIST. MATH., 
!C          30,B,351-363.                                                
!C                                                                       
!C          H.AKAIKE(1978), "A BAYESIAN EXTENSION OF THE MINIMUM AIC     
!C          PROCEDURE OF AUTOREGRESSIVE MODEL FITTING.",  RESEARCH MEMO. 
!C          NO. 126, THE INSTITUTE OF STATISTICAL MATHEMATICS; TOKYO.    
!C       --------------------------------------------------------------- 
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:  
!C             REDATA                                                    
!C             NONSTB                                                    
!C             PRINTA                                                    
!C             NRASPE                                                    
!C       --------------------------------------------------------------- 
!C                                                                       
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: BLOCARF

          INTEGER(kind=4) :: N, LAG, NS0, KMAX 
          INTEGER(kind=4), dimension(KMAX)   :: NP, NE
          REAL(kind=8),      dimension(N)          :: ZS
          !DIR$ ASSUME_ALIGNED NP:64,NE:64
          !DIR$ ASSUME_ALIGNED ZS:64
          REAL(kind=8) :: ZMEAN, SUM 
          REAL(kind=8), dimension(KMAX,KMAX) :: AIC, C
          REAL(kind=8), dimension(LAG,KMAX)  :: B,A
          REAL(kind=8), dimension(KMAX)      ::  SD
          REAL(kind=8), dimension(121,KMAX)  :: SXX
          !DIR$ ASSUME_ALIGNED AIC:64,C:64
          !DIR$ ASSUME_ALIGNED B:64,A:64
          !DIR$ ASSUME_ALIGNED SD:64
          !DIR$ ASSUME_ALIGNED SXX:64
          ! Locals
          INTEGER(kind=4) :: KSW,MJ1,ISW,NS,LAG1,N0,K,K3,NR,KC
          REAL(kind=8) :: BB
          REAL(kind=8), dimension(N) :: Z
          REAL(kind=8), dimension(NS0,LAG+1) :: X
          REAL(kind=8), dimension(LAG,KMAX)  :: F 
!DIR$ ATTRIBUTES ALIGN : 64 :: Z,X,F
          EXTERNAL  SETX1

          KSW = 0                                                           
                                                       
          MJ1 = NS0
          ISW = 0                                                           
                                         
          NS = NS0
                                
!C          ---------------------                                        
!C          ORIGINAL DATA LOADING                                        
!C          ---------------------                                        
!C                                                                       
!                            
          CALL  REDATA( ZS,Z,N,ZMEAN,SUM )
                                                                     
!C     ---  INITIAL SETTING  ---                                         
          LAG1 = LAG+1                                                      
          N0 = 0                                                            
          K = LAG + KSW                                                     
          K3 = K*3                                                          
                                                                      
          NR = 0
          KC = 0
       10 CONTINUE                                                          
          NR = NR+1
!C                                                                       
!C          -----------------------------------                          
!C          LOCALLY STATIONARY AR-MODEL FITTING                          
!C          -----------------------------------                          
!C                                                                       

          CALL  NONSTB( SETX1,Z,N,X,LAG,N0,NS,KMAX,KSW,ISW,MJ1,KC,F,      &
                  AIC(1,NR),C(1,NR),B(1,NR),A(1,NR),SD(NR) )
                     
          NP(NR) = N0 + LAG + 1                                             
          NE(NR) = NP(NR)+NS-1                                              
!C                                                                       
!C     ---  SPECTRUM DISPLAY  ---                                        
                          
          CALL  NRASPE( SD(NR),A(1,NR),BB,K,0,120,SXX(1,NR) )
!C                                                                       
!C                                                                       
!C     ---  PREPARATION FOR THE NEXT STEP  ---                           
          N0 = N0 + NS                                                      
          IF(N0+NS+LAG1.GT.N)      NS = N-N0-LAG1                           
          IF(N-N0-NS-LAG1.LT.K3)   NS = N-N0-LAG1                           
          IF( N0+LAG1 .LT. N )     GO TO 10                                 
    END SUBROUTINE
                        

                                                                   

    SUBROUTINE  NONSTB( SETX,Z,N,X,LAG,N0,NS,KMAX1,KSW,ISW,MJ1,KC,F,  &
                          AIC,C,B,A,SD )  
        
!C                                                                       
!C     BAYESIAN TYPE NON-STATIONARY AUTOREGRESSIVE MODEL FITTING PROCEDUR
!C                                                                       
!C     THIS SUBROUTINE FIRST FITS AN AUTOREGRESSIVE MODEL TO THE NEWLY OB
!C     DATA SPAN AND THEN PRODUCES A BAYESIAN MODEL BY AVERAGING THE MODE
!C     FITTED TO THE PRESENT AND PRECEDING SPANS.                        
!C                                                                       
!C     BAYESIAN WEIGHT OF THE MODEL FITTED TO I PERIODS FORMER SPAN IS   
!C     DEFINED BY                                                        
!C          C(I)  =  CONST * P(I) / (I+1)                                
!C     WHERE                                                             
!C          CONST  =  NORMALIZING CONSTANT                               
!C          P(I)  =  EXP( -0.5*AIC(I) )                                  
!C          AIC(I)  =  AIC WITH RESPECT TO THE PRESENT DATA.             
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             DMIN                                                      
!C             ARBAYS                                                    
!C             ARCOEF                                                    
!C             BAYSWT                                                    
!C             REDUCT                                                    
!C             SDCOMP                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C     INPUTS:                                                           
!C        SETX:  EXTERNAL SUBROUTINE DESIGNATION                         
!C        Z:     ORIGINAL DATA, OUTPUT OF SUBROUTINE REDATA              
!C        X:     WORKING AREA                                            
!C        D:     WORKING AREA                                            
!C        LAG:   UPPER LIMIT OF ORDER OF AR-MODEL                        
!C        N0:    INDEX OF THE END POINT OF THE FORMER SPAN               
!C        NS:    LENGTH OF BASIC LOCAL SPAN                              
!C        KMAX:  MAXIMUM NUMBER OF PRECEDING MODELS STORED               
!C        KSW:   =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR      
!C               =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSOR  
!C        ISW:   PRINT OUT CONTROL                                       
!C        TITLE: TITLE OF DATA                                           
!C        MJ1:   ABSOLUTE DIMENSION OF X                                 
!C                                                                       
!C     OUTPUTS:                                                          
!C        A:     AR-COEFFICIENTS OF THE CURRENT MODEL                    
!C        SD:    INNOVATION VARIANCE OF THE CURRENT MODEL                
!C                                                                       

          INTEGER(kind=4) :: N, LAG, N0, NS, KMAX1, KSW, ISW, MJ1, KC
          REAL(kind=8), dimension(N)             :: Z
          REAL(kind=8), dimension(MJ1,1)         :: X 
          REAL(kind=8), dimension(LAG+KSW,KMAX1) :: F 
          REAL(kind=8), dimension(KMAX1)         :: AIC,C
          REAL(kind=8), dimension(LAG+KSW)       ::  B,A
          !DIR$ ASSUME_ALIGNED Z:64
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED F:64
          !DIR$ ASSUME_ALIGNED AIC:64
          !DIR$ ASSUME_ALIGNED C:64
          !DIR$ ASSUME_ALIGNED B:64
          !DIR$ ASSUME_ALIGNED A:64
          REAL(kind=8) :: SD
          ! Locals
          INTEGER(kind=4) ::   K,KMAX,J,I,KC1,II
          REAL(kind=8)    ::   AICB, AICM, SDMIN, PN
          REAL(kind=8), dimension(LAG+KSW+1) :: D, SDD, AICC,  &
                                              DIC, W
          REAL(kind=8), dimension(LAG+KSW) :: B1   
!DIR$     ATTRIBUTES ALIGN : 64 :: D,SDD,AICC,DIC,W,B1                                                  
          EXTERNAL  SETX
                                                                       
          K = LAG + KSW                                                     
          KMAX = KMAX1-1
!C                                                                       
!C     ---  HOUSEHOLDER REDUCTION  ---                                   
                  
          CALL  REDUCT( SETX,Z,NS,N0,K,MJ1,LAG,X )                        

          CALL ARBAYS( X,D,K,NS,ISW,MJ1,SDD,AICC,DIC,AICM,SDMIN,IMIN,   &
                       A,B1,B,W,SD,PN,AICB )
                                                                       
          IF( KC .EQ. 0 )  GO TO 110                                        
!C                                                                       
!C                                                                       
!C     ---  PREDICTION ERROR VARIANCE AND AIC OF THE FORMER MODELS  ---  
          AIC(1) = AICB                                                     
          DO 30  J=1,KC                                                     
                 DO 20  I=1,K                                                   
!cxx   20    D(I) = F(I,J)                                                  
                         D(I) = F(I,J)
           20    CONTINUE
                 CALL  ARCOEF( D,K,A )                                           
                            
                 CALL  SDCOMP( X,A,NS,K,MJ1,SD )                               
                           
                AIC(J+1) = NS*DLOG( SD ) + 2._8
       30 CONTINUE
!C                                                                       
!C                                                                       
!C     ---  BAYESIAN WEIGHTS OF THE MODEL  ---                           
!c-------------------------------   06/11/01
!ccx      AICM = DMIN( AIC,KC )                                             
           AICM = AIC(1)
           DO 33  I=1,KC
!cxx   33 IF( AIC(I) .LT. AICM )  AICM = AIC(I)
                  IF( AIC(I) .LT. AICM )  AICM = AIC(I)
       33 CONTINUE
!c-------------------------------
          CALL  BAYSWT( AIC,AICM,KC,2,C )                                   
!C                                                                       
          KC1 = KC+1                                                        
                                                                  
          !C     ---  AVERAGING OF THE MODELS  ---
!DIR$     VECTOR ALIGNED
!DIR$     SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 40  I=1,K                                                      
!cxx   40 B(I) = B(I)*C(1)                                                  
                 B(I) = B(I)*C(1) 
       40 CONTINUE
             DO 70  J=1,KC
!DIR$     VECTOR ALIGNED                    
!DIR$     SIMD VECTORLENGTHFOR(REAL(KIND=8))              
                 DO 50  I=1,K                                                   
!cxx   50    A(I) = F(I,J)                                                  
                       A(I) = F(I,J)
          50    CONTINUE
                DO 60  I=1,K                                                   
!cxx   60    B(I) = B(I) + C(J+1)*A(I) 
         B(I) = B(I) + C(J+1)*A(I)
         60    CONTINUE                                     
       70 CONTINUE                                                          
                                                                       
!C     ---  AR-COEFFICIENTS OF THE CURRENT BAYESIAN MODEL  ---           
          CALL  ARCOEF( B,K,A )                                             
                                                                      
!C     ---  "PARCOR'S" STORED  ---                                       
                                            
          DO 101  J=1,KC
                  II = KC1-J                                                     
                  DO 100  I=1,K                                                  

                        F(I,II+1) = F(I,II)
           100    CONTINUE
     101  CONTINUE                                               
110       CONTINUE
!DIR$     VECTOR ALIGNED                        
!DIR$     SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 120  I=1,K                                                     
                                                  
                  F(I,1) = B(I)
      120 CONTINUE
          KC = MIN0( KC+1,KMAX )                                            
                                                                       
!C     ---  PREDICTION ERROR VARIANCE COMPUTED  ---                      
                         
          CALL  SDCOMP( X,A,NS,K,MJ1,SD )                                 
    END SUBROUTINE
                          
    SUBROUTINE  BLOMARF( ZS,N,ID,C,LAG,NS0,KMAX,ZMEAN,ZVARI,BW,AIC,A,     &
                            E,AICB,LKS,LKE,M )
      
      implicit none
        
   
!C
!cc      PROGRAM  BLOMAR                                                   
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.3.4.                                                    
!C     _                  __                 _            __             
!C     BAYESIAN METHOD OF LOCALLY STATIONARY MULTIVARIATE AR MODEL FITTIN
!C                                                                       
!C     THIS PROGRAM LOCALLY FITS MULTI-VARIATE AUTOREGRESSIVE MODELS TO  
!C     NON-STATIONARY TIME SERIES BY A BAYESIAN PROCEDURE.               
!C                                                                       
!C       --------------------------------------------------------------- 
!C       REFERENCES:                                                     
!C          G.KITAGAWA AND H.AKAIKE(1978), "A PROCEDURE FOR THE MODELING 
!C          OF NON-STATIONARY TIME SERIES.",  ANN. INST. STATIST. MATH., 
!C          30,B,351-363.                                                
!C          H.AKAIKE(1978), "A BAYESIAN EXTENSION OF THE MINIMUM AIC     
!C          PROCEDURE OF AUTOREGRESSIVE MODEL FITTING.",  RESEARCH MEMO. 
!C          NO. 126, THE INSTITUTE OF STATISTICAL MATHEMATICS; TOKYO.    
!C       --------------------------------------------------------------- 
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:  
!C             MRDATA                                                    
!C             MNONSB                                                    
!C       --------------------------------------------------------------- 
!C       INPUTS REQUIRED;                                                
!C          MT:    INPUT DEVICE FOR ORIGINAL DATA (MT=5: CARD READER).   
!C          LAG:   UPPER LIMIT OF THE ORDER OF AR-MODEL, MUST BE LESS THA
!C                 OR EQUAL TO 50.                                       
!C          NS:    LENGTH OF BASIC LOCAL SPAN.                           
!C          KSW:   =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR    
!C                 =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSOR
!C                                                                       
!C            -- THE FOLLOWING INPUTS ARE REQUESTED BY SUBROUTINE MRDATA 
!C          TITLE: SPECIFICATION OF DATA                                 
!C          N:     DATA LENGTH, MUST BE LESS THAN OR EQUAL TO 1000.      
!C          ID:    DIMENSION OF DATA,  MUST BE LESS THAN 6               
!C                       < ID*(LAG+1)+KSW MUST BE LESS THAN 101 >        
!C          IFM:   INPUT FORMAT                                          
!C          FORM:  INPUT DATA FORMAT SPECIFICATION STATEMENT.            
!C                 -- EXAMPLE --     (8F10.5)                            
!C          C(J):  CALIBRATION CONSTANT FOR CHANNEL J (J=1,ID)           
!C          Z(I,J): ORIGINAL DATA                                        
!C            -----------------------------------------------------------

          INTEGER(kind=4) :: N, ID, LAG, NS0, KMAX, M
          INTEGER(kind=4), dimension(KMAX)        :: LKS, LKE
          REAL(kind=8), dimension(N,ID)           :: ZS
          REAL(kind=8), dimension(ID)             :: C, ZMEAN, ZVARI
          REAL(kind=8), dimension(KMAX,KMAX)      :: BW,AIC
          REAL(kind=8), dimension(ID,ID,LAG,KMAX) ::  A
          REAL(kind=8), dimension(ID,ID,KMAX)     ::  E 
          REAL(kind=8), dimension(KMAX)           ::  AICB
#if defined __ICC
          !DIR$ ASSUME_ALIGNED LKS:64,LKE:64
          !DIR$ ASSUME_ALIGNED ZS:64
          !DIR$ ASSUME_ALIGNED C:64
          !DIR$ ASSUME_ALIGNED ZMEAN:64
          !DIR$ ASSUME_ALIGNED ZVARI:64
          !DIR$ ASSUME_ALIGNED BW:64
          !DIR$ ASSUME_ALIGNED AIC:64
          !DIR$ ASSUME_ALIGNED A:64
          !DIR$ ASSUME_ALIGNED E:64
          !DIR$ ASSUME_ALIGNED AICB:64
#endif
          ! Locals
          INTEGER(kind=4) :: MJ,MJ1,MJ3,KSW,NS,L,KD,MX,KC,LK,LK1,MF
                         
          REAL(kind=8), dimension(N,ID) :: Z
          REAL(kind=8), dimension(ID,ID,LAG) :: B, G, H
          REAL(kind=8), dimension(LAG*ID,ID,KMAX) :: F1,F2
          REAL(kind=8), dimension((LAG+1)*ID*2,(LAG+1)*ID) :: X
!DIR$     ATTRIBUTES ALIGN : 64 :: Z,B,G,H,F1,F2,X
          ! Exec code ....
                                                   
          MJ = N

          MJ1 = (LAG+1)*ID*2
          MJ3 = ID
          KSW = 0                                                           

          BW(1:KMAX,1:KMAX) = 0.0_8
          AIC(1:KMAX,1:KMAX) = 0.0_8
          A(1:ID,1:ID,1:LAG,1:KMAX) = 0.0_8
          E(1:ID,1:ID,1:KMAX) = 0.0_8
          AICB(1:KMAX) = 0.0_8
          LKS(1:KMAX) = 0
          LKE(1:KMAX) = 0
          F1(1:LAG*ID,1:ID,1:KMAX) = 0.0_8
          F2(1:LAG*ID,1:ID,1:KMAX) = 0.0_8
          X(1:MJ1,1:(LAG+1)*ID) = 0.0_8
                                    
          NS = NS0
                                
          CALL MRDATA( ZS,Z,N,ID,C,ZMEAN,ZVARI )
                                                                       
          L = 0                                                             
          KD = LAG * ID + KSW                                               
          MX = KD * 2                                                       
          KC = 0
                                                                       
          M = 0
      111 CONTINUE                                                          
!cxx      M = M+1
          LK = L + LAG                                                      
          LK1 = LK + 1                                                      
          IF( LK1 .GE. N )     GO TO 300
          M = M+1
          IF( N-LK1 .LE. NS )     NS = N - LK                               
          IF( N-LK1-NS .LT. MX )     NS = N - LK                            

          CALL MNONSB( Z,X,G,H,E(1,1,M),KSW,LAG,L,NS,ID,KMAX,KC,MJ,MJ1,   &
                       MJ3,BW(1,M),AIC(1,M),A(1,1,1,M),B,AICB(M),F1,F2 )
C                                                                       
          L = L + NS                                                        
                                                   
          LKE(M) = LK + NS
          MF = LAG                                                          
                                    
          LKS(M) = LK1
                                                              
          GO TO 111                                                         
      300 CONTINUE

    END SUBROUTINE
                            

    SUBROUTINE  MNONSB( Z,X,G,H,E,KSW,LAG,N0,NS,ID,KMAX1,KC,MJ,MJ1,     &
         MJ3,C,AIC,A,B,AICB,F1,F2 )
      use omp_lib
      implicit none
         
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             DMIN                                                      
!C             BAYSWT                                                    
!C             MARCOF                                                    
!C             MBYSAR                                                    
!C             MREDCT                                                    
!C             MSDCOM                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          Z:     ORIGINAL DATA; Z(K,I) (K=1,N) REPRESENTS THE RECORD OF
!C                 THE I-TH CHANNEL                                      
!C          X:     WORKING AREA                                          
!C          D:     WORKING AREA                                          
!C          G:     WORKING AREA (PARTIAL AUTOREGRESSION COEFFICIENT MATRI
!C                 FORWARD MODEL)                                        
!C          H:     WORKING AREA (PARTIAL AUTOREGRESSION COEFFICIENT MATRI
!C                 BACKWARD MODEL)                                       
!C          E:     WORKING AREA                                          
!C          KSW:   =0   CONSTATNT VECTOR IS NOT INCLUDED AS A REGRESSOR  
!C                 =1   CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSO
!C          LAG:   UPPER LIMIT OF THE ORDER OF AR-MODEL                  
!C          N0:    INDEX OF THE END POINT OF THE FORMER SPAN             
!C          NS:    LENGTH OF BASIC LOCAL SPAN                            
!C          ID:    DIMENSION OF DATA                                     
!C          KMAX:  MAXIMUM NUMBER OF PRECEDING MODELS STORED             
!C          MJ:    ABSOLUTE DIMENSION OF Z IN THE MAIN PROGRAM           
!C          MJ1:   ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM           
!C          MJ3:   ABSOLUTE DIMENSION OF A AND B IN THE MAIN PROGRAM     
!C                                                                       
!C       OUTPUTS:                                                        
!C          A:     AUTOREGRESSIVE COEFFICIENT MATRIX OF FORWARD MODEL    
!C          B:     AUTOREGRESSIVE COEFFICIENT MATRIX OF BACKWARD MODEL   
!C          AICB:  AIC OF THE CURRENT MODEL                              
!C                                                                       

          INTEGER(kind=4) :: KSW, LAG, N0, NS, ID, KMAX1, KC, MJ, MJ1, MJ3
          REAL(kind=8), dimension(MJ,ID)           :: Z
          REAL(kind=8), dimension(MJ1,(LAG+1)*ID)  :: X
          REAL(kind=8), dimension(MJ3,MJ3,LAG)     :: G,H,A,B
          REAL(kind=8), dimension(MJ3,ID)          :: E
          REAL(kind=8), dimension(KMAX1)           :: C, AIC
          REAL(kind=8)                             :: AICB
          REAL(kind=8), dimension(LAG*ID,ID,KMAX1) :: F1, F2
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED G:64,H:64,A:64,B:64
          !DIR$ ASSUME_ALIGNED E:64
          !DIR$ ASSUME_ALIGNED C:64
          !DIR$ ASSUME_ALIGNED AIC:64
          !DIR$ ASSUME_ALIGNED F1:64,F2:64
#endif
          ! Locals
          INTEGER(kind=4) :: IPR,KD,JJ,KC,I,J,KC1,IM
          REAL(kind=8)    ::  AICM, EK, SD, SDMIN
          REAL(kind=8), dimension(LAG+1) :: SD1, AIC1, DIC1,BW1
          REAL(kind=8), dimension(LAG)   :: BW2
#if defined __ICC
          !DIR$     ATTRIBUTES ALIGN : 64 :: SD1,AIC1,DIC1,BW1,BW2
#endif
          ! Exec code ....
!C                                                                       
          KMAX = KMAX1-1
                                                    
          IPR = 0                                                           
          KD = LAG * ID                                                     
!C          -----------------------------------------------              
!C          NEW DATA LOADING AND HOUSEHOLDER TRANSFORMATION              
!C          -----------------------------------------------              
     
          CALL  MREDCT( Z,NS,N0,LAG,ID,MJ,MJ1,KSW,X )
!C                                                                       
!C          -------------------------------------                        
!C          BAYESIAN MODEL FITTED TO THE NEW SPAN                        
!C          -------------------------------------                        

          CALL  MBYSAR( X,NS,LAG,ID,KSW,MJ1,MJ3,SD1,AIC1,DIC1,       &
                   AICM,SDMIN,IMIN,BW1,BW2,A,B,G,H,E,AICB,EK )
!C                                                                       
          IF( KC .EQ. 0 )  GO TO 20                                         
!C          -----------------------------                                
!C          "PARCOR'S" SHIFTED AND STORED                                
!C          -----------------------------                                
          KC1 = KC+1                                                        

          DO 12  JJ=1,KC
                 II = KC1 - JJ                                                   
                 !cxx        DO 10  I=1,KD
#if defined __ICC
                 !DIR$ VECTOR ALIGNED
                 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD
#endif
                 DO 11  I=1,KD                                                   
                    DO 10  J=1,ID                                                   
                       F1(I,J,II+1) = F1(I,J,II)                                         
!cxx   10 F2(I,J,II+1) = F2(I,J,II)
                       F2(I,J,II+1) = F2(I,J,II)
                  10 CONTINUE
              11 CONTINUE
       12 CONTINUE                                         
       20 IM = 0                                                            

          DO 32  II=1,LAG                                                   
                 DO 31  I=1,ID                                                      
                    IM = IM+1
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                    !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                    !$OMP SIMD
#endif
                        DO 30  J=1,ID                                                     
                               F1(IM,J,1) = G(I,J,II)

                               F2(IM,J,1) = H(I,J,II)
                      30 CONTINUE
                31 CONTINUE
       32 CONTINUE                                            
          IF( KC .EQ. 0 )  GO TO 100                                        
!C          ---------------------------------------------------------    
!C          PREDICTION ERROR VARIANCES AND AIC'S OF THE FORMER MODELS    
!C          ---------------------------------------------------------    
          AIC(1) = AICB                                                     
          DO 50  JJ=1,KC                                                    
                 IM = 0                                                          
                                                 
                 DO 42  II=1,LAG                                                 
                        DO 41  I=1,ID
                           IM = IM+1
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                           !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                           !$OMP SIMD
#endif
                               DO 40  J=1,ID                                                 
                                      G(I,J,II) = F1(IM,J,JJ+1)                                       
                                       
                                      H(I,J,II) = F2(IM,J,JJ+1)
                        40     CONTINUE
                    41   CONTINUE
            42   CONTINUE 
!C                                                                       
                 CALL  MARCOF( G,H,ID,LAG,MJ3,A,B )                              
      
                 CALL  MSDCOM( X,A,NS,LAG,ID,KSW,MJ1,E,SD )        

                 AIC(JJ+1) = NS*DLOG( SD ) + ID*(ID+1)                             
       50 CONTINUE
!C          ----------------------------------------                     
!C          BAYESIAN WEIGHTS OF THE PRECEDING MODELS                     
!C          ----------------------------------------                     
!c-----------------------------  06/11/01
                                         
          AICM = AIC(1)
          DO 55  I=1,KC

                 IF( AIC(I) .LT. AICM )  AICM = AIC(I)
       55 CONTINUE
!c-----------------------------
          CALL  BAYSWT( AIC,AICM,KC,2,C )                                   
                          
!C          ------------------------                                     
!C          AVERAGING OF THE MODELS                                      
!C          -----------------------                                      
          EK = EK*C(1)**2                   
                                                  
          DO 72  II=1,LAG                                                   
             DO 71  I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED                
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
                        DO 70  J=1,ID                                                     
                                     
                               B(I,J,II) = A(I,J,II)*C(1)
                      70 CONTINUE
              71 CONTINUE
       72 CONTINUE
!cxx      DO 80  I=1,KD                                                     
            DO 81  I=1,KD
#if defined __ICC                                 
!DIR$ VECTOR ALIGNED                                  
               !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
               !$OMP SIMD
#endif
                 DO 80  J=1,ID 
                     
                        F1(I,J,1) = F1(I,J,1)*C(1)                                        
!cxx   80 F2(I,J,1) = F2(I,J,1)*C(1)                                        
                        F2(I,J,1) = F2(I,J,1)*C(1)                                        
               80 CONTINUE
       81 CONTINUE
!C                                                                       
                                                  
          DO 92  JJ=1,KC                                                    
             DO 91  I=1,KD
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
                        DO 90  J=1,ID                                                   
                               F1(I,J,1) = F1(I,J,1) + F1(I,J,JJ+1)*C(JJ+1)                    
!cxx   90   F2(I,J,1) = F2(I,J,1) + F2(I,J,JJ+1)*C(JJ+1)
                               F2(I,J,1) = F2(I,J,1) + F2(I,J,JJ+1)*C(JJ+1)                    
                   90   CONTINUE
            91   CONTINUE
       92 CONTINUE
!C          -----------------------------------------                    
!C          PREDICTION ERROR VARIANCE MATRIX COMPUTED                    
!C          -----------------------------------------                    
      100 IM = 0                                                            
          KC = KC + 1                                                       
          IF( KC .GT. KMAX )     KC = KMAX                                  
                                                 
          DO 112  II=1,LAG                                                  
                  DO 111  I=1,ID
                     IM = IM+1
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                     !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#lif defined __GFORTRAN__
                     !$OMP SIMD
#endif
                          DO 110  J=1,ID                                                  
                                  G(I,J,II) = F1(IM,J,1)                                          
!cxx  110   H(I,J,II) = F2(IM,J,1)                                          
                                  H(I,J,II) = F2(IM,J,1)
                    110   CONTINUE
             111 CONTINUE
      112 CONTINUE
!C                                                                       
          CALL  MARCOF( G,H,ID,LAG,MJ3,A,B )                                

          CALL  MSDCOM( X,A,NS,LAG,ID,KSW,MJ1,E,SD )
          AICB = NS*DLOG( SD ) + 2.D0*(EK + KSW*ID) + ID*(ID+1)             
    END SUBROUTINE
                        
                        
   
    SUBROUTINE BSUBSTF( ZS,N,IMODEL,LAG,K,IL,LG1,LG2,ZMEAN,SUM,         &
                        M,AICM,SDM,A1,SD,AIC,DIC,AICB,SDB,EK,A2,IND,C,C1,C2,B,OEIC,ESUM,  &
                        OMEAN,OM,E,EMEAN,VARI,SKEW,PEAK,COV,SXX )
      use omp_lib
      implicit none
         
!cc      PROGRAM BSUBST
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAY  14, 1979.......................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.1.3.                                                    
!C     _                 ____ _                                          
!C     BAYESIAN TYPE ALL SUBSET ANALYSIS OF TIME SERIES BY A MODEL LINEAR
!C     IN PARAMETERS                                                     
!C                                                                       
!C     THIS PROGRAM PRODUCES BAYESIAN ESTIMATES OF TIME SERIES MODELS SUC
!C     PURE AR MODELS, AR-MODELS WITH NON-LINEAR TERMS, AR-MODELS WITH PO
!C     TYPE MEAN VALUE FUNCTIONS, ETC.  THE GOODNESS OF FIT OF A MODEL IS
!C     CHECKED BY THE ANALYSIS OF SEVERAL STEPS AHEAD PREDICTION ERRORS. 
!C     BY PREPARING AN EXTERNAL SUBROUTINE SETX PROPERLY, ANY TIME SERIES
!C     WHICH IS LINEAR IN PARAMETERS CAN BE TREATED.                     
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:  
!C             REDATA                                                    
!C             REDLAG                                                    
!C             SETLAG                                                    
!C             REDREG                                                    
!C             REDUCT                                                    
!C             ARMFIT                                                    
!C             SBBAYS                                                    
!C             CHECK                                                     
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS REQUIRED:                                                
!C          MT:    ORIGINAL DATA INPUT DEVICE SPECIFICATION              
!C          IMODEL:=1  AUTOREGRESSIVE MODEL                              
!C                 =2  POLYNOMIAL TYPE NON-LINEAR MODEL (LAG'S READ IN ) 
!C                 =3  POLYNOMIAL TYPE NON-LINEAR MODEL (LAG'S AUTOMATICA
!C                 =4  AR-MODEL WITH POLYNOMIAL MEAN VALUE FUNCTION      
!C                 =5  ANY NON-LINEAR MODEL                              
!C                 =6  POLYNOMIAL TYPE EXPONENTIALLY DAMPED NON-LINEAR MO
!C                 =7  THIS MODEL IS RESERVED FOR THE USER'S OPTIONAL USE
!C          LAG:   MAXIMUM TIME LAG USED IN THE MODEL                    
!C          K:     NUMBER OF REGRESSORS                                  
!C          IL:    PREDICTION ERRORS CHECKING (UP TO IL-STEPS AHEAD) IS R
!C                 N*IL SHOULD BE LESS THAN OR EQUAL TO 20000            
!C                                                                       
!C       --   THE FOLLOWING INPUTS ARE REQUIRED AT SUBROUTINE REDATA   --
!C                                                                       
!C          TITLE:   ORIGINAL DATA SPECIFICATION                         
!C          N:       DATA LENGTH                                         
!C          DFORM:   INPUT DATA FORMAT SPECIFICATION STATEMENT           
!C                   -- EXAMPLE --  (8F10.5 )                            
!C          X(I) (I=1,N):   ORIGINAL DATA                                
!C       ----------------------------------------------------------------
!C                                                                       
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: BSUBSTF
!C
          INTEGER(kind=4), parameter ::   MJ2 = 101 

          INTEGER(kind=4) :: N, IMODEL, LAG, K, IL
          INTEGER(kind=4), dimension(3,K) :: LG1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED LG1:64
#endif
          INTEGER(kind=4), dimension(5)   :: LG2
          INTEGER(kind=4) :: M
          INTEGER(kind=4), dimension(K)   :: IND
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IND:64
#endif
          REAL(kind=8), dimension(N)  :: ZS
          REAL(kind=8) :: ZMEAN, SUM, AICM, SDM
          REAL(kind=8), dimension(K) :: A1 
          REAL(kind=8), dimension(K+1) :: SD, AIC, DIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED ZS:64
          !DIR$ ASSUME_ALIGNED A1:64
          !DIR$ ASSUME_ALIGNED SD:64,AIC:64,DIC:64
#endif
          REAL(kind=8) :: AICB, SDB, EK
          REAL(kind=8), dimension(K) :: A2, C 
          REAL(kind=8), dimension(K+1) :: C1
          REAL(kind=8), dimension(K) :: C2,B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A2:64,C:64
          !DIR$ ASSUME_ALIGNED C1:64
          !DIR$ ASSUME_ALIGNED C2:64,B:64
#endif
          REAL(kind=8) ::  OEIC 
          REAL(kind=8), dimension(K+1) :: ESUM
#if defined __ICC
          !DIR$ ASSUME_ALIGNED ESUM:64
#endif
          REAL(kind=8) :: OMEAN, OM
          REAL(kind=8), dimension(N,IL) :: E
          REAL(kind=8), dimension(IL) :: EMEAN,VARI,SKEW,PEAK
          REAL(kind=8), dimension(MJ2) ::  COV
          REAL(kind=8), dimension(121) :: SXX
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64
          !DIR$ ASSUME_ALIGNED EMEAN:64
          !DIR$ ASSUME_ALIGNED VARI:64
          !DIR$ ASSUME_ALIGNED SKEW:64
          !DIR$ ASSUME_ALIGNED PEAK:64
          !DIR$ ASSUME_ALIGNED COV:64
          !DIR$ ASSUME_ALIGNED SXX:64
#endif
          INTEGER(kind=4) ::  NN,MJ,MJ1,ISW,IPR,NMK,LAG1,I
          REAL(kind=8)    ::  SD0, CONST
          INTEGER(kind=4), dimension(50) :: L1,L2,L3
          CHARACTER(LEN=4), dimension(20,31) :: G
          REAL(kind=8), dimension(N)        :: Z
          REAL(kind=8), dimension(N,K+1)    :: X
          REAL(kind=8), dimension(N-LAG,IL) :: FA
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: Z,X,FA
#endif
!C
          COMMON     / BBB / L1(50) , L2(50) , L3(50) , SD0 , CONST         
          COMMON     / EEE /  G                                     
          COMMON     / AAA /  NN
!C                                                                       
!C        EXTERNAL SUBROUTINE DECLARATION:                               
!C                                                                       
          !EXTERNAL  SETX1                                                   
         ! EXTERNAL  SETX2                                                   
         ! EXTERNAL  SETX4                                                   
                                                 
         ! EXTERNAL  PRDCT1                                                  
         ! EXTERNAL  PRDCT2                                                  

          IF ((IMODEL.LE.0) .OR. (IMODEL.GE.7)) GO TO 150
                                                     
          NN = N
          MJ = N
          MJ1 = N
          ISW = 1                                                           
          IPR = 2                                                           
                                  
          CALL  REDATA( ZS,Z,N,ZMEAN,SUM )
          NMK = N - LAG                                                     
          LAG1 = LAG + 1                                                    
!C                                                                       
!C          ---------------------                                        
!C          HOUSEHOLDER REDUCTION                                        
!C          ---------------------                                        
!C                                                                       
                          
          IF ( IMODEL .EQ. 1 ) GO TO 10
          IF ( IMODEL .EQ. 2 ) GO TO 20
          IF ( IMODEL .EQ. 3 ) GO TO 30
          IF ( IMODEL .EQ. 4 ) GO TO 40
C                                                                       
       10 K = LAG                                                           
                     
          CALL  REDUCT( SETX1,Z,NMK,0,K,MJ1,LAG,X )                       
          GO TO 100                                                         
                                              
20        CONTINUE
#if defined __ICC
          !DIR$  VECTOR ALIGNED
          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif
          DO 21 I=1,K
                L1(I) = LG1(1,I)
                L2(I) = LG1(2,I)
                L3(I) = LG1(3,I)
       21 CONTINUE
                    
          CALL  REDUCT( SETX2,Z,NMK,0,K,MJ1,LAG,X )                       
          GO TO 100                                                         

30        CALL  SETLAG( KK,LG2(1),LG2(2),LG2(3),LG2(4),LG2(5) )
#if defined __ICC
          !DIR$  VECTOR ALIGNED
          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif
          DO 31 I=1,K
                LG1(1,I) = L1(I)
                LG1(2,I) = L2(I)
                LG1(3,I) = L3(I)
       31 CONTINUE
          CALL  REDUCT( SETX2,Z,NMK,0,K,MJ1,LAG,X )                       
          GO TO 100                                                         
                 
       40 CALL  REDUCT( SETX4,Z,NMK,0,K,MJ1,LAG,X )                       
          GO TO 100                                                         
                                         
      100 CONTINUE                                                          

          CALL ARMFIT( X,K,LAG,NMK,ISW,MJ1,A1,M,SD,AIC,DIC,SDM,AICM)
!C                                                                       
!C          ------------------                                           
!C          BAYESIAN PROCEDURE                                           
!C          ------------------                                           
!C                                                                       
                      
          CALL  SBBAYS( X,K,NMK,IPR,MJ1,A2,SDB,EK,AICB,IND,C,C1,C2,B,   &
                       OEIC,ESUM,OMEAN,OM  )
          if( k.eq.32 ) return
      
          IF( IMODEL .EQ. 1 )  CALL  NRASPE( SDB,A2,B,K,0,120,SXX )
!C                                                                       
          NPS = LAG+1                                                       
!C                                                                       
!C          -------------------------                                    
!C          PREDICTION ERROR CHECKING                                    
!C          -------------------------                                    
!C                                                                       
                       
          IF ( IMODEL .EQ. 1 ) GO TO 110 
          IF ( IMODEL .EQ. 2 ) GO TO 120
          IF ( IMODEL .EQ. 3 ) GO TO 120
          GO TO 150                                                         

      110 CALL CHECK( PRDCT1,Z,A2,K,0,IL,NPS,N,MJ,E,FA,EMEAN,VARI,SKEW,       &
              PEAK,COV,MJ2 )
          GO TO 150                                                         

      120 CALL  CHECK( PRDCT2,Z,A2,K,0,IL,NPS,N,MJ,E,FA,EMEAN,VARI,SKEW,         &
                PEAK,COV,MJ2 )
          GO TO 150                                                         
                                                                  
150       CONTINUE  
          
    END SUBROUTINE
                        
!cc      REAL FUNCTION  BICOEF * 8( K,J )                                  
    !cxx      REAL*8 FUNCTION  BICOEF( K,J )

     real(kind=8)  FUNCTION BICOEF( K,J )
       use omp_lib
       implicit none
!C                                                                       
!C!     THIS FUNCTION RETURNS BINOMIAL COEFFICIENTS                       
!C                                                                       
!C          F(K,J) = K]/(J]*(K-J)])                                      
!C                                                                       
!C       INPUTS:                                                         
!C          K:     NUMBER OF OBJECTS                                     
!C          J:     NUMBER OF OBJECTS TAKEN                               
!C                                                                       
!C       OUTPUT:                                                         
!C          F:     NUMBER OF COMBINATIONS OF SELECTING J OBJECTS FROM    
!C                 A SET OF K OBJECTS                                    
!C                                                                       
!cxx      IMPLICIT REAL * 8 ( A-H , O-Z )
          INTEGER(kind=4) :: K,J
          ! Locals
          INTEGER(kind=4) :: KMJ,I
          REAL(kind=8) :: SUM, DI
!C                                                                       
          KMJ = K-J                                                         
          SUM = 0._8
          !$OMP SIMD REDUCTION(+:SUM)
          DO 10   I=1,K                                                     
                  DI = I                                                            
!cx x   10 SUM = SUM + DLOG( DI )
                  SUM = SUM + DLOG( DI )
       10 CONTINUE                                            
!C                                                                       
         IF( J .EQ. 0 )   GO TO 30
          !$OMP SIMD REDUCTION(-:SUM)
          DO 20   I=1,J                                                     
                  DI = I                                                            
!cxx   20 SUM = SUM - DLOG( DI )
                  SUM = SUM - DLOG( DI )                                            
       20 CONTINUE
!C                                                                       
30       IF( KMJ .EQ. 0 )   GO TO 50
          !$OMP SIMD REDUCTION(-:SUM)   
          DO 40   I=1,KMJ                                                   
                  DI = I                                                            
!cxx   40 SUM = SUM - DLOG( DI )                                            
                  SUM = SUM - DLOG( DI )
       40 CONTINUE
!C                                                                       
       50 BICOEF = DEXP( SUM )                                              
    END FUNCTION
    

    SUBROUTINE  CHECK( PRDCT,X,A,K,L,IL,NPS,NPE,MJ,E,F,EMEAN,VARI,     &
                        SKEW,PEAK,COV,MJ2 )
      use omp_lib
      implicit none
!C                                                                       
!C     THIS SUBROUTINE DRAWS HISTGRAMS AND AUTOCOVARIANCE FUNCTION OF ORI
!C     DATA OR PREDICTION ERRORS.                                        
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             GRAPH1                                                    
!C             GRAPH2                                                    
!C             MOMENT                                                    
!C             (PRDCT)                                                   
!C       ----------------------------------------------------------------
!C       INPUTS:                                                         
!C          PRDCT:  EXTERNAL SUBROUTINE DESIGNATION                      
!C          X:      ORIGINAL DATA                                        
!C          A:      REGRESSION COEFFICIENTS                              
!C          K:      NUMBER OF REGRESSORS                                 
!C          L:      MA-ORDER ( THIS ARGUMENT IS ONLY USED FOR THE CHECKIN
!C                  OF AR-MA MODEL)                                      
!C          IL:     MAXIMUM SPAN OF LONG RANGE PREDICTION                
!C                  =0     ANALYSIS OF ORIGINAL DATA                     
!C                  >0     ANALYSIS OF MULTI-STEP (UP TO IL) PREDICTION E
!C          NPS:    PREDICTION STARTING POSITION                         
!C          NPE:    PREDICTION ENDING POSITION                           
!C          IPR:    =0  MATRIX OF SEVERAL STEP AHEAD PREDICTION ERRORS SU
!C                  =1  MATRIX OF SEVERAL STEP AHEAD PREDICTION ERRORS IS
!C                      OUT                                              
!C          MJ:     ABSOLUTE DIMENSION OF E IN THE MAIN PROGRAM          
!C                                                                       
!C       OUTPUT:                                                         
!C          E:      SEVERAL-STEPS PREDICTION ERRORS                      
!C                                                                       
!C                                                                       
        
          INTEGER(kind=4) :: K, L, IL, NPS, NPE, MJ, MJ2 
          REAL(kind=8), dimension(NPE) :: X 
          REAL(kind=8), dimension(K)   :: A 
          REAL(kind=8), dimension(MJ,IL) :: E
          REAL(kind=8), dimension(NPE-NPS+1,IL) :: F
          REAL(kind=8), dimension(IL) :: EMEAN,VARI,SKEW,PEAK
          REAL(kind=8), dimension(MJ2) :: COV
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED A:64
          !DIR$ ASSUME_ALIGNED E:64
          !DIR$ ASSUME_ALIGNED F:64
          !DIR$ ASSUME_ALIGNED EMEAN:64
          !DIR$ ASSUME_ALIGNED VARI:64
          !DIR$ ASSUME_ALIGNED SKEW:64
          !DIR$ ASSUME_ALIGNED PEAK:64
          !DIR$ ASSUME_ALIGNED COV:64
#endif
          ! Locals
          INTEGER(I32P) :: ISTEP,ISW,LAGH,N,LAG1,NMK,I,II, &
                           J,JJ,KK,IE
          REAL(R64P) :: SUM, COV1, SD
                                                                       
          ISTEP = 1                                                         
          ISW = IL                                                          
          LAGH = 100                                                        
          N = NPE - NPS - 1                                                 
          IF( LAGH .GE. N )     LAGH = N - 1                                
          LAG1 = LAGH + 1                                                   
          NMK = N - K                                                       
          IF( ISW .GT. 0 )     GO TO 20                                     
          !C
#if defined __ICC
!DIR$  VECTOR ALIGNED
          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 10  I=NPS,NPE                                                  
!cxx   10 E(I,1) = X(I) 
                 E(I,1) = X(I)
       10 CONTINUE                                                    
          IL = 1                                                            
          GO TO 36                                                          
!C                                                                       
!C       ---  SEVERAL STEP AHEAD PREDICITON  ---                         
!C                                                                       
       20 CONTINUE                                                          
          CALL  PRDCT( X,A,K,L,IL,NPS,NPE,MJ,E )                            
!C                                                                       
!C       ---  PREDICTION ERROR  ---                                      
!C                                                                       
                                                
          DO 31  II=NPS,NPE
                  I = NPE-II+NPS                                                 
                  DO 30  J=1,IL                                                  
                         JJ = I-J+1                                                     
!cxx   30 E(I,J) = X(I) - E(JJ,J)
                         E(I,J) = X(I) - E(JJ,J)
              30 CONTINUE
       31 CONTINUE                                           
          IF( IL .EQ. 1 )     GO TO 34                                      
          DO 35  J=2,IL                                                     
                 JJ = J-1                                                          
!cxx      DO 35  I=1,JJ                                                     
                 DO 33  I=1,JJ 
                        II = I+NPS-1                                                      
!cxx   35 E(II,J) = 0.D0                                                    
                       E(II,J) = 0._8
                 33 CONTINUE
             35 CONTINUE
       34 CONTINUE                                                          
                        
       36 CONTINUE                                                          
!C                                                                       
!C       ---  MOMENT COMPUTATION  ---                                    
!C                                                                       
          DO 50  KK=1,IL                                                    
                                                                       
                 II = NPS+KK-1                                                     
                 DO 40  I=II,NPE                                                   
                        J = I - II + 1                                                    

                        F(J,KK) = E(I,KK)
             40 CONTINUE
                NMK = NPE-NPS-(KK-2)                                              
                      
                CALL  MOMENT( F(1,KK),NMK,EMEAN(KK),VARI(KK),SKEW(KK),PEAK(KK) )
                                     
       50 CONTINUE                                                          
!C                                                                       
!C       ---  AUTOCORRELATION FUNCTION COMPUTATION  ---                  
!C                                                                       
          DO 100  KK=1,IL                                                   
!C                                                                       
                  DO 70   II=1,LAG1                                                 
                          JJ = NPS + KK - 1                                                 
                          IE = NPE - II + 1                                                 
                          SUM = 0.0_8
                          !$OMP SIMD REDUCTION(+:SUM)
                          DO 60   I=JJ,IE                                                   
                                  J = I + II- 1                                                     
!cxx   60 SUM = SUM + E(I,KK)*E(J,KK)
                                  SUM = SUM + E(I,KK)*E(J,KK)
                       60 CONTINUE                                       
!cxx   70 COV(II) = SUM / (NPE-NPS-KK+2)
                          COV(II) = SUM / (NPE-NPS-KK+2)
               70 CONTINUE                                    
!C                                                                       
                          COV1 = COV(1)
#if defined __ICC
                          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                          !$OMP SIMD
#endif
                  DO 80   I=1,LAG1                                                  
!cxx   80 COV(I) = COV(I) / COV1                                            
                          COV(I) = COV(I) / COV1
               80 CONTINUE
                                                                
                  SD = NPE - NPS + 1                                                
                  SD = DSQRT( 1._8/SD )                                             
                                                    
                  IF( ISTEP .EQ. KK )     GO TO 110                                 
                                                                      
      100 CONTINUE                                                          
                                                                       
      110 CONTINUE                                                          
                                                        
    END  SUBROUTINE
                        
    SUBROUTINE  MOMENT( X,N,F1,F2,F3,F4 )
      use omp_lib
      implicit none
!C                                                                       
!C          +--------------------+                                       
!C          ! MOMENT COMPUTATION !                                       
!C          +--------------------+                                       
!C                                                                       
!C     THIS SUBROUTINE COMPUTES MOMENTS.                                 
!C                                                                       
!C!       INPUTS:                                                         
!C          X:     ORIGINAL DATA VECTOR                                  
!C          N:     DATA LENGTH                                           
!C                                                                       
!C       OUTPUTS:                                                        
!C          F1:    MEAN OF X                                             
!C          F2:    VARIANCE OF X                                         
!C          F3:    SKEWNESS OF X                                         
!C          F4:    PEAKEDNESS OF X                                       
!C                                                                       

          INTEGER(kind=4) :: N
          REAL(kind=8), dimension(N) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8) :: F1, F2, F3, F4
          INTEGER(kind=4) :: I
          REAL(kind=8) :: FN, FSUM, FF
                                                                       
          FN = N                                                            
          FSUM = 0._8
#if defined __ICC
          !DIR$ SIMD REDUCTION(+:FSUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:FSUM) LINEAR(I:1)
#endif
          DO  10  I=1,N                                                  
!cxx   10 FSUM = FSUM + X(I)                                                
                 FSUM = FSUM + X(I)
       10 CONTINUE
                                                                       
          F1 = FSUM / FN                                                    
                                                                       
          F2 = 0._8                                                       
          F3 = 0._8                                                         
          F4 = 0._8                                                         
          DO  20  I=1,N                                                  
                  FF = X(I) - F1                                                    
                  F2 = F2 + FF*FF                                                   
                  F3 = F3 + FF**3                                                   
!cxx   20 F4 = F4 + FF**4                                                   
                  F4 = F4 + FF**4
       20 CONTINUE
                                                                      
          F2 = F2 / FN                                                      
          F3 = F3 / (FN*F2*DSQRT(F2))                                       
          F4 = F4 / (FN*F2*F2)                                              
    END SUBROUTINE
    
                                                               
                                                                  
    SUBROUTINE  PRDCT1( Z,A,M,L,IL,NPS,NPE,MJ,EZ )
      implicit none
!C                                                                       
!C     THIS SUBROUTINE COMPUTES SEVARAL STEP AHEAD PREDICTION VALUE OF AN
!C     AUTOREGRESSIVE MOVING AVERAGE MODEL.                              
!C                                                                       
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA VECTOR                                 
!C          A:      AR-MA COEFFICIENTS                                   
!C          M:      AR-ORDER                                             
!C          L:      MA-ORDER                                             
!C          IL:     MAXIMUM SPAN OF LONG RANGE PREDICTION                
!C          NPS:    PREDICTION STARTING POSITION                         
!C          NPE:    PREDICTION ENDING POSITION                           
!C          MJ:     ABSOLUTE DIMENSION OF EZ                             
!C                                                                       
!C       OUTPUT:                                                         
!C          EZ:     PREDICTION VALUE MATRIX                              
!C                                                                       
                                                
          INTEGER(kind=4) :: M, L, IL, NPS, NPE, MJ
          REAL(kind=8), dimension(NPE)   :: Z 
          REAL(kind=8), dimension(M)     :: A 
          REAL(kind=8), dimension(MJ,IL) :: EZ
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,A:64,EZ:64
#endif
          ! Locals
          INTEGER(kind=4) :: II,KK,KKM1,KI,I1,I2
          REAL(kind=8) :: SUM
                                                                       
          DO  100  II=NPS,NPE                                            
                                               
                   DO  91   KK=1,IL 
                            KKM1 = KK - 1                                                     
                            SUM = 0.0_8                                                      
                            IF( KK .EQ. 1 )     GO TO 30                                      
                            DO  20 I=1,KKM1                                               
                                   KI = KK - I                                                       
!cxx   20 SUM = SUM + A(I)*EZ(II,KI)                                        
                                   SUM = SUM + A(I)*EZ(II,KI)
                          20 CONTINUE
       30 IF( KK .GT. M )     GO TO 50                                      
          DO  40 I=KK,M                                                 
                 I1 = II + KKM1 - I                                                
!cxx   40 SUM = SUM + A(I)*Z(I1)                                            
                 SUM = SUM + A(I)*Z(I1)
       40 CONTINUE
!C                                                                       
       50 IF( L .LE. 0 )     GO TO 90                                       
          IF( KK .GT. L )     GO TO 90                                      
          DO  60 I=KK,L                                                 
              I1 = M + I                                                        
              I2 = II + KKM1 - I                                                
              IF( I2 .GE. II )     GO TO 60                                     
              SUM = SUM + A(I1)*(Z(I2)-EZ(I2,1))                                
           60 CONTINUE                                                          
           90 EZ(II,KK) = SUM
         91 CONTINUE                                                   
      100 CONTINUE                                                          
    END SUBROUTINE
    
   
    SUBROUTINE  PRDCT2( Z,A,K,L,IL,NPS,NPE,MJ1,EZ )
      implicit none
!C                                                                       
!C     THIS SUBROUTINE COMPUTES SEVERAL STEPS AHEAD PREDICTION VALUES OF 
!C     NON-LINEAR REGRESSION MODEL.                                      
!C                                                                       
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA VECTOR                                 
!C          A:      VECTOR OF AR-COEFFICIENTS                            
!C          K:      ORDER OF THE AR MODEL                                
!C          L:      THIS DUMMY VARIABLE IS NOT REFERENCED IN THIS SUBROUT
!C          IL:     MAXIMUM SPAN OF LONG RANGE PREDICTION                
!C          NPS:    PREDICTION STARTING POSITION                         
!C          NPE:    PREDICTION ENDING POSITION                           
!C          MJ1:    ABSOLUTE DIMENSION OF EZ                             
!C                                                                       
!C       OUTPUT:                                                         
!C          EZ:     PREDICTION VALUE MATRIX                              
!C                                                                       

          INTEGER(kind=4) :: K, IL, NPS, NPE, MJ1
          REAL(kind=8), dimension(NPE)    :: Z 
          REAL(kind=8), dimension(K)      :: A 
          REAL(kind=8), dimension(MJ1,IL) :: EZ
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,A:64,EZ:64
#endif
          INTEGER(kind=4) :: II,J1,JJ,LAG,II,J
          REAL(kind=8)    ::  CSTDMY, SD0DMY, SUM, XX, X
          INTEGER(kind=4), dimension(50) :: LAG1,LAG2,LAG3
          REAL(kind=8), dimension(IL) :: Y
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: Y
#endif
          COMMON     / BBB /  LAG1 , LAG2 , LAG3, CSTDMY, SD0DMY
                                            
          DO 110  II=NPS,NPE
                  DO 50  J1=1,IL                                                 
                         JJ = J1-1                                                   
                         SUM = 0._8                                               
                         DO 40  J=1,K                                                
                                XX = 1._R64P                                              
                                LAG = LAG1(J)                                            

                                X = 1._8
                            IF ( LAG .GT. 0 ) THEN
                                I = II+JJ-LAG
                                IF ( I .GE. II ) THEN
                                     I = I - II + 1
                                     X = Y(I)
                                ELSE
                                     X = Z(I)
                                END IF
                           END IF
                           XX = XX*X                                               
                                                
                           LAG = LAG2(J)                                            

                           X = 1._8
                           IF ( LAG .GT. 0 ) THEN
                               I = II+JJ-LAG
                              IF ( I .GE. II ) THEN
                                   I = I - II + 1
                                   X = Y(I)
                              ELSE
                                    X = Z(I)
                              END IF
                         END IF
                         XX = XX*X

                         LAG = LAG3(J)                                            

                         X = 1._dp
                        IF ( LAG .GT. 0 ) THEN
                           I = II+JJ-LAG
                           IF ( I .GE. II ) THEN
                                I = I - II + 1
                                X = Y(I)
                           ELSE
                                X = Z(I)
                           END IF
                       END IF
                       XX = XX*X

                      SUM = SUM + A(J)*XX 
        40       CONTINUE                                        
!cxx   50    Y(J1) = SUM
                 Y(J1) = SUM
    50    CONTINUE                                                    
                                                                       
          DO  100  J=1,IL                                                   
                   EZ(II,J) = Y(J)                                                   
          100 CONTINUE
      110 CONTINUE                                     

!C    L : DUMMY
      L = L
    END SUBROUTINE
    
                                     
    SUBROUTINE  SETLAG( K,LAG1,LAG2,LAG3,LAG4,LAG5 )
      implicit none
!C                                                                       
!C     THIS SUBROUTINE  PREPARES SPECIFICATION OF REGRESSORS (L1(I),L2(I)
!C     (I=1,...,K) FOR THE FITTING OF (POLYNOMIAL TYPE) NON-LINEAR MODEL.
!C     THE OUTPUTS ARE USED AS THE INPUTS TO SUBROUTINE SETX2.           
!C                                                                       
!C       INPUTS:                                                         
!C          LAG1:    MAXIMUM TIME LAG OF LINEAR TERM                     
!C          LAG2:    MAXIMUM TIME LAG OF SQUARED TERM                    
!C          LAG3:    MAXIMUM TIME LAG OF QUADRATIC CROSS TERM            
!C          LAG4:    MAXIMUM TIME LAG OF CUBIC TERM                      
!C          LAG5:    MAXIMUM TIME LAG OF CUBIC CROSS TERM                
!C                                                                       
!C       OUTPUTS:                                                        
!C          K:       NUMBER OF REGRESSORS                                
!C          (L1(I),L2(I),L3(I))  (I=1,K):     SPECIFICATION OF REGRESSORS
!C                                                                       
!C              ......................................................   
!C              I-TH REGRESSOR IS DEFINED BY                             
!C                   Z(N-L1(I)) * Z(N-L2(I)) * Z(N-L3(I))                
!C              WHERE  0-LAG TERM Z(N-0) IS REPLACED BY THE CONSTANT 1.  
!C              ......................................................   
!C                                                                       

          INTEGER(kind=4) :: K, LAG1, LAG2, LAG3, LAG4, LAG5
          INTEGER(kind=4) :: I,LL,I1,J
          REAL(kind=8) :: CSTDMY, SD0DMY
          INTEGER(kind=4), dimension(50) :: L1,L2,L3
          COMMON     / BBB /  L1,L2,L3,CSTDMY,SD0DMY
                       
          IF(LAG1.LE.0)  GO TO 15                                           
          DO 10  I=1,LAG1                                                   
                 L1(I) = I                                                         
                 L2(I) = 0                                                         
!cxx   10 L3(I) = 0
                 L3(I) = 0
       10 CONTINUE                                                         
       15 K = LAG1                                                          
                                                                      
          IF(LAG2.LE.0)   GO TO 30                                          
          DO 20  I=1,LAG2                                                   
                 K = K+1                                                           
                 L1(K) = I                                                         
                 L2(K) = I                                                         
!cxx   20 L3(K) = 0                                                         
                 L3(K) = 0
         20 CONTINUE
                                                                      
         30 IF(LAG3.LE.1)   GO TO 50                                          
            LL = LAG3-1                                                       
!cxx      DO 40  I=1,LL
            DO 41  I=1,LL                                                     
                   I1 = I+1                                                       
                   DO 40  J=I1,LAG3                                               
                          K = K+1                                                        
                          L1(K) = I                                                      
                          L2(K) = J                                                      
!cxx   40    L3(K) = 0
                          L3(K) = 0
             40    CONTINUE
           41 CONTINUE
       50 M  = K                                                            
                                                                       
          IF(LAG4.LE.0)   GO TO 65                                          
          DO 60  I=1,LAG4                                                   
                 K = K+1                                                           
                 L1(K) = I                                                         
                 L2(K) = I                                                         
!cxx   60 L3(K) = I                                                         
                 L3(K) = I
          60 CONTINUE
       65 CONTINUE                                                          
!C                                                                       
          IF(LAG5.LE.1)   GO TO 80                                          
                                             
          DO 72  I=1,LAG5                                                   
                 DO 71  J=I,LAG5
                       DO 70  L=J,LAG5                                             
                              IF(I.EQ.J .AND. J.EQ.L)  GO TO 70                           
                              K = K+1                                                     
                              L1(K) = I                                                   
                              L2(K) = J                                                   
                              L3(K) = L                                                   
               70       CONTINUE
             71    CONTINUE
        72 CONTINUE
                                                   
   80 CONTINUE
                                           
    END  SUBROUTINE
    
    SUBROUTINE  SETX2( Z,N0,L,K,MJ1,JSW,LAG,X )   
        implicit none
!C                                                                       
!C          +----------------------------------------+                   
!C          ! MATRIX X SET UP (FOR NON-LINEAR MODEL) !                   
!C          +----------------------------------------+                   
!C                                                                       
!C     THIS SUBROUTINE PREPARES DATA MATRIX X FROM DATA VECTOR Z(I) (I=N0
!C     N0+K+LAG) FOR THE FITTING OF NON-LINEAR AUTOREGRESSIVE MODEL.  X I
!C     USED AS THE INPUT TO SUBROUTINE HUSHLD.                           
!C                                                                       
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA VECTOR                                 
!C          N0:     INDEX OF THE END POINT OF DISCARDED FORMER OBSERVATIO
!C                  (NEW OBSERVATION STARTS AT N0+LAG+1 AND ENDS AT N0+LA
!C          L:      DIMENSION OF THE VECTOR OF NEW OBSERVATIONS          
!C          K:      NUMBER OF REGRESSORS                                 
!C          MJ1:    ABSOLUTE DIMENSION OF X                              
!C          JSW:    =0   TO CONSTRUCT INITIAL L*(K+1) DATA MATRIX        
!C                  =1   TO AUGMENT ORIGINAL (K+1)*(K+1) MATRIX X BY AN  
!C                       L*(K+1) DATA MATRIX OF ADDITIONAL OBSERVATIONS  
!C          LAG:    MAXIMUM TIME LAG                                     
!C          KSW:    THIS DUMMY VARIABLE IS NOT REFERENCED IN THIS SUBROUT
!C                                                                       
!C--  THE FOLLOWING VARIABLE SPECIFICATION IS GIVEN EITHER BY REDLAG OR S
!C         (L1(I) , L2(I) , L3(I))  (I=1,K)                              
!C                                                                       
!C               I-TH REGRESSOR IS DEFINED BY                            
!C                    Z(N-L1(I)) * Z(N-L2(I)) * Z(N-L3(I))               
!C               WHERE 0-LAG TERM Z(N-0) IS AUTOMATICALLY REPLACED BY CON
!C                                                                       
!C       OUTPUT:                                                         
!C          X:      L*(K+1) MATRIX           IF  JSW = 0                 
!C                  (K+1+L)*(K+1) MATRIX     IF  JSW = 1                 
!C                                                                       

          INTEGER(kind=4) :: N0, L, K, MJ1, JSW, LAG 
          REAL(kind=8), dimension(N0+LAG+L) :: Z
          REAL(kind=8), dimension(MJ1,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,X:64
#endif
          INTEGER(kind=4) :: K1,I0,I,I1,J1,II,LL1,LL2,LL3
          REAL(kind=8) :: CSTDMY, SD0DMY, ZTEM
          INTEGER(kind=4), dimension(50) :: L1,L2,L3
          COMMON     / BBB /  L1 , L2 , L3, CSTDMY, SD0DMY  
                                                                       
          K1 = K + 1                                                        
          I0 = K1*JSW                                                       
          DO  10     I=1,L                                                  
                     I1 = I + I0                                                       
                     J1 = N0 + LAG + I                                                 
!cxx   10 X(I1,K1) = Z(J1)                                                  
                     X(I1,K1) = Z(J1)
      10 CONTINUE
                                                                      
         DO  70     II=1,K                                                 
                    LL1 = L1(II)                                                      
                    LL2 = L2(II)                                                      
                    LL3 = L3(II)                                                      
!cxx      DO  60     I=1,L
                    DO  61     I=1,L
                               ZTEM = 1._dp                                                      
                               I1 = I + I0                                                       
                               J1 = N0 + LAG + I                                                 
                               IF( LL1 .EQ. 0 )     GO TO 40                                     
                               M1 = J1 - LL1                                                     
                               ZTEM = ZTEM * Z(M1)                                               
                            40 IF( LL2 .EQ. 0 )     GO TO 50                                     
                               M2 = J1 - LL2                                                     
                               ZTEM = ZTEM * Z(M2)                                               
                            50 IF( LL3 .EQ. 0 )     GO TO 60                                     
                               M3 = J1 - LL3                                                     
                               ZTEM = ZTEM * Z(M3)                                               
                            60 X(I1,II) = ZTEM
                    61 CONTINUE                                                   
       70 CONTINUE                                                          
    END SUBROUTINE
    
    SUBROUTINE  SETX4( Z,NO,L,K,MJ1,JSW,LAG,X )
      implicit none
         
!C                                                                       
!C     THIS SUBROUTINE PREPARES DATA MATRIX X FROM DATA VECTOR Z(I) (I=NO
!C     NO+K+L) FOR THE FITTING OF AUTOREGRESSIVE MODEL WITH POLYNOMIAL TY
!C     VALUE FUNCTION.  X IS THEN USED AS THE INPUT TO SUBROUTINE HUSHLD.
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA VECTOR                                 
!C          NO:     INDEX OF THE END POINT OF DISCARDED FORMER OBSERVATIO
!C          L:      DIMENSION OF THE VECTOR OF NEW OBSERVATIONS          
!C          K:      NUMBER OF REGRESSORS                                 
!C          MJ1:    ABSOLUTE DIMENSION OF X                              
!C          JSW:    =0   TO CONSTRUCT INITIAL L*(K+1) DATA MATRIX        
!C                  =1   TO AUGMENT ORIGINAL (K+1)*(K+1) MATRIX X BY AN  
!C                       L*(K+1) DATA MATRIX OF ADDITIONAL OBSERVATIONS  
!C          LAG:    MAXIMUM TIME LAG OF THE MODELS                       
!C          N:      DATA LENGTH                                          
!C                                                                       
!C       OUTPUT:                                                         
!C          X:      L*(K+1) MATRIX           IF   JSW = 0                
!C                  (K+1+L)*(K+1) MATRIX     IF   JSW = 1                
!C                                                                       
!C                                                                       

          INTEGER(kind=4) :: NO, L, K, MJ1, JSW, LAG                       
          REAL(kind=8), dimension(NO+LAG+L) :: Z 
          REAL(kind=8), dimension(MJ1,K+1)  :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,X:64
#endif
          INTEGER(kind=4) :: N,M,K1,I0,M1,II,NN,JJ
          REAL(kind=8) :: BN, Y, XX
                                    
          COMMON     / AAA /  N
!C                                                                       
!C          M:      ORDER OF POLYNOMIAL OF MEAN VALUE FUNCTION           
!C                                                                       
          M = K - LAG - 1                                                   
          K1 = K + 1                                                        
          I0 = JSW*K1                                                       
          M1 = M + 1                                                        
          LAG=K-M1                                                          
          BN = 2._8/(N-LAG-1._dp)                                            
                                                  
          DO 11  I=1,L
                 Y= BN*(NO+I-1)-1._8                                             
                 XX= 1._8                                                         
                 DO 10 J=1,M1                                                      
                       II= I+I0                                                          
                       X(II,J) = XX                                                      
!cxx   10 XX = XX*Y 
                       XX = XX*Y 
              10 CONTINUE
       11 CONTINUE                                                        

          DO 21  I=1,L                                                     
                 II = I+I0                                                         
                 NN = NO+LAG+I                                                     
                 X(II,K1) = Z(NN)                                                  
                 DO 20   J=1,LAG                                                   
                         NN = NN-1                                                         
                         JJ = J+M1                                                         
                                                 
                         X(II,JJ) = Z(NN)
             20 CONTINUE
       21 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  SRTMIN( X,N,IX )
      implicit none
         
!C                                                                       
!C       THIS SUBROUTINE ARRANGES X(I) (I=1,N) IN ORDER OF INCREASING    
!C       MAGNITUDE OF X(I)                                               
!C                                                                       
!C       INPUTS:                                                         
!C          X:   VECTOR                                                  
!C          N:   DIMENSION OF THE VECTOR                                 
!C       OUTPUTS:                                                        
!C          X:   ARRANGED VECTOR                                         
!C          IND: INDEX OF ARRANGED VECTOR                                
!C                                                                       

          INTEGER(kind=4) :: N
          INTEGER(kind=4), dimension(N) :: IX
          
          REAL(kind=8), dimension(N) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IX:64,X:64
#endif
          INTEGER(kind=4) :: NM1,II,I,MIN
          REAL(kind=8) :: XMIN, XT                                                             
          NM1 = N - 1  

          DO  30 I=1,N                                                  
!cxx   30 IX(I) = I                                                         
                 IX(I) = I 
       30 CONTINUE
          DO  20 II=1,NM1                                               
                 XMIN = X(II)                                                      
                 MIN = II                                                          
                 DO  10 I=II,N                                                 
                     IF( XMIN .LT. X(I) )     GO TO 10                                 
                     XMIN = X(I)                                                       
                     MIN = I                                                           
             10 CONTINUE                                                          
                IF( XMIN .EQ. X(II) )     GO TO 20                                
                XT = X(II)                                                        
                X(II) = X(MIN)                                                    
                X(MIN) = XT                                                       
                IT = IX(II)                                                       
                IX(II) = IX(MIN)                                                  
                IX(MIN) = IT                                                      
       20 CONTINUE                                                          
    END SUBROUTINE
    
                                                                  

    SUBROUTINE  SUBSPC( B,K,N,EK,IND,C,C1,C2,OEIC,ESUM1,OMEAN,OM )
      use omp_lib
      implicit none
         
!C                                                                       
!C       THIS SUBROUTINE PRODUCES BAYESIAN ESTIMATES OF PARTIAL CORRELATI
!C       BY CHECKING ALL SUBSET REGRESSION MODELS.                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             BICOEF                                                    
!C             SRTMIN                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C         INPUTS:                                                       
!C           B:   LEAST SQUARES ESTIMATES OF PARTIAL CORRELATIONS        
!C           K:   DIMENSION OF VECTOR A                                  
!C           N:   NUMBER OF OBSERVATIONS USED FOR THE ESTIMATION OF A(I) 
!C           IPR: =0  TO SUPPRESS THE OUTPUTS                            
!C                >0  TO PRINT OUT THE OUTPUTS                           
!C                                                                       
!C         OUTPUTS:                                                      
!C           B(I) (I=1,K):   BAYESIAN ESTIMATES OF PARTIAL CORRELATIONS  
!C           EK:   EQUIVALENT NUMBER OF FREE PARAMETERS IN THE BAYESIAN M
!C                                                                       

          INTEGER(kind=4) :: K, N
          INTEGER(kind=4), dimension(K) :: IND
          REAL(kind=8),    dimension(K) :: B,C,C2
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IND:64
          !DIR$ ASSUME_ALIGNED B:64,C:64,C2:64
#endif
          REAL(kind=8) :: EK, OEIC
          REAL(kind=8), dimension(K+1) :: C1,ESUM1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C1:64,ESUM1:64
#endif
          REAL(kind=8) ::  OMEAN, OM
          ! Locals
          INTEGER(kind=4) :: K1,I,M,IP,IQ,KMJ
          REAL(kind=8) :: CC, DN, SUM, EIC,   &
                        SUMC, EXIC, OSUM , BICOEF
          INTEGER(kind=4), dimension(K+1) :: KND
          REAL(kind=8), dimension(K+1,K+1) ::  D 
          REAL(kind=8), dimension(K+1)     :: ESUM
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: KND,D,ESUM
#endif
!C                                                                       
          CC = 1.3010299956639812_8                                        
          K1 = K + 1                                                        
          DN = N                                                            

          ESUM(1:K1) = 0._8
          D(1:K1,1:K1) = 0._8
!C                                                                       
!C          SQUARE OF PARTIAL CORRELATIONS ( NORMALISED BY MULTIPLYING N 
          !C
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif
          DO 20   I=1,K                                                     
!cxx   20 C(I) = B(I)*B(I)*DN                                               
                  C(I) = B(I)*B(I)*DN 
       20 CONTINUE
!C                                                                       
!C          ARRANGEMENT OF C(I) IN ORDER OF INCREASING MAGNITUDE         
!C                                                                       
          CALL  SRTMIN( C,K,IND )                                           
!cc      IF( IPR .LE. 1 )     GO TO 60                                     
!cc      WRITE( 6,7 )                                                      
!cc      DO  50     I=1,K                                                  
!cc   50 WRITE( 6,6 )     I , IND(I) , C(I)                                
!cc   60 CONTINUE                                                          
!C                                                                       
!C          FIND THE MINIMUM OF EIC                                      
!C                                                                       
         OEIC = CC*K                                                       
         SUM = 0._8
#if defined __ICC
         !DIR$ VECTOR ALIGNED
         !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
         !$OMP SIMD REDUCTION(+:SUM) LINEAR(I:1)
#endif
         DO 30   I=1,K                                                     
                 SUM = SUM + C(I)                                                  
                 EIC = SUM + CC*(K-I)                                              
!cxx   30 IF( OEIC .GT. EIC )   OEIC = EIC                                  
                 IF( OEIC .GT. EIC )   OEIC = EIC 
30       CONTINUE
!cc      WRITE( 6,604 )   OEIC                                             
!C                                                                       
!C--------  COMPUTATION OF EIC'S OF WHOLE SUBSET REGRESSION MODELS  -----
!C                                                                       
!C          INITIAL SETTING                                              
                 !C
#if defined __ICC
                 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif                 
          DO 40   I=1,K                                                     
!cxx   40 KND(I) = 0                                                        
                  KND(I) = 0
       40 CONTINUE
          KND(K1) = 1                                                       
          SUM = 0._dp                                                      
          SUMC = 0._dp
          M = K                                                             
          IP = 0                                                            
          IQ = 0                                                            
!C                                                                       
      100 CONTINUE                                                          
!C                                                                       
!C          -----  SPECIFICATION OF NEXT SUBSET  -----                   

          DO 111   I=1,K
                   IF( KND(I) .EQ. 0 )   GO TO 110                          
                   KND(I) = 0                                               
                   GO TO 120                                                
  110              KND(I) = 1                                               
      111 CONTINUE
  120     CONTINUE                                                 
!C          ------------------------------------------                   
!C                                                                       
      130 CONTINUE             
          IF( IP .GT. K )   GO TO 200                                       
          IF( KND(IP+1) .EQ. 0 )   GO TO 140                                
!C                                                                       
          IF( IQ .EQ. 0 )   GO TO 165                                       
          IF( KND(IQ) .EQ. 1 )   GO TO 150                                  
          IQ = IQ-1                                                         
          SUMC = SUMC + C(IQ+1)                                             
!C                                                                       
          IF( SUMC + CC*(K-IP+IQ) .GT. OEIC + 40.0_dp )   GO TO 180           
          GO TO 150                                                         
!C                                                                       
  140     IP = IP+1                                                         
          IQ = IP-1                                                         
          SUMC = C(IP)                                                      
          IF( SUMC + CC .GT. OEIC + 40.0_dp )   GO TO 200                     
!C                                                                       
      150 M = K-IP+IQ                                                       
          SUM = SUMC                                                        
          IF( IQ .EQ. 0 )   GO TO 165                                       
          DO 160   I=1,IQ                                                   
                   IF( KND(I) .EQ. 1 )   GO TO 160                                   
                   M = M-1                                                           
                   SUM = SUM + C(I)                                                  
      160 CONTINUE                                                          
      165 CONTINUE                                                          
          EIC = SUM + CC*M - OEIC                                           
          IF( EIC .GT. 40.0_dp )   GO TO 100                                  
          EXIC = DEXP( -0.5_dp*EIC )                                         
          ESUM(M+1) = ESUM(M+1) + EXIC                                      
          DO 170   I=1,K                                                    
!cxx  170 IF( KND(I) .EQ. 1 )   D(I,M+1) = D(I,M+1) + EXIC                  
                   IF( KND(I) .EQ. 1 )   D(I,M+1) = D(I,M+1) + EXIC 
      170 CONTINUE
          GO TO 100                                                         
!C         --------------------------------------------                  
  180     DO 190   I=1,IP                                          
!cxx  190          KND(I) = 1                                               
                   KND(I) = 1 
  190     CONTINUE
          KND(IP+1) = 0                                            
          IP = IP+1                                                
          IQ = IP-1                                                
          GO TO 130                                                
!C         ---------------------------------------------                 
!C                                                                       
!C--------------------------  WHOLE SUBSETS CHECKED  --------------------
!C                                                                       
200 CONTINUE                                                          
!cc      IF( IPR .GE. 2 )     WRITE( 6,8 )                                 
          !cc      IF( IPR .GE. 2 )     WRITE( 6,607 )     (ESUM(I),I=1,K1)
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif             
          DO 201 I=1,K1
!cxx  201 ESUM1(I) = ESUM(I)
                 ESUM1(I) = ESUM(I)
      201 CONTINUE
!C                                                                       
!C          MEAN OF NUMBER OF PARAMETERS                                 
!C                                                                       
          OSUM = 0._8                                                    
          SUM = ESUM(1)
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD REDUCTION(+:SUM,+:OSUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM,OSUM)
#endif
          DO 210   I=1,K                                                    
                   SUM = SUM + ESUM(I+1)                                             
!cxx  210 OSUM = OSUM + I*ESUM(I+1)                                         
                   OSUM = OSUM + I*ESUM(I+1)
      210 CONTINUE
          OMEAN = OSUM / SUM                                                
          OM = OMEAN / K                                                    
!cc      IF( IPR .GE. 2 )     WRITE( 6,608 )     OMEAN , OM                
!C                                                                       
!C       --  BINOMIAL TYPE DAMPER  --                                    
          !C
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD 
#endif              
          DO 220   I=1,K1                                                   
                   J = I-1                                                           
                   KMJ = K-J                                                         
                     
                  C1(I) = BICOEF(K,J)*(OM**J)*((1.0_8-OM)**KMJ)
      220 CONTINUE
          C1(1) = 1._8 / (1._8 + K)                                          
          DO 221  I=1,K                                                     
                              
                  C1(I+1) = C1(I) * I / (1._dp + K - I) 
221               CONTINUE
#if defined __ICC
!DIR$ VECTOR ALIGNED       
                  !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif    
          DO 230   I=1,K1                                                   
                                         
                   ESUM(I) = ESUM(I)*C1(I)
      230 CONTINUE
                                                                       
                   SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                   !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM) LINEAR(I:1)
#endif                      
          DO 240   I=1,K1                                                   
!cxx  240 SUM = SUM + ESUM(I)                                               
                   SUM = SUM + ESUM(I)
      240 CONTINUE
                                               
                   DO 251   J=1,K1
#if defined __ICC
!DIR$ VECTOR ALIGNED                      
                      !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1,J)
#endif                        
                   DO 250   I=1,K                                                    
                                     
                            D(I,J) = D(I,J)*C1(J) / SUM
               250 CONTINUE
      251 CONTINUE
!C                                                                       
!C          WEIGHTS OF PARTIAL CORRELATIONS                              
!C                                                                       

          C2(1:K) = 0._8                                                     
                                          
          DO 271   I=1,K
#if defined __ICC
!DIR$ VECTOR ALIGNED             
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
             
                   DO 270   J=1,K1                                                   

                            C2(I) = C2(I) + D(I,J)
               270 CONTINUE
      271 CONTINUE                                              
             
!C                                                                       
!C          AVERAGING AND REARRANGEMENT OF PARTIAL CORRELATIONS          
!C                                                                       
         EK = 1._8
       
          DO 280   I=1,K                                                    
                   J = IND(I)                                                        
                                              
                   B(J) = B(J)*C2(I)                                                  
                                               
                   EK = EK + C2(I)**2
      280 CONTINUE
    END SUBROUTINE
    
                                                            
                      
    SUBROUTINE  SBBAYS( X,K,N,IPR,MJ1,A,SD,EK,AIC,IND,C,C1,C2,B,       &
                        OEIC,ESUM,OMEAN,OM  ) 
      use omp_lib
      implicit none
!C                                                                       
!C     THIS SUBROUTINE PRODUCES BAYESIAN MODEL BASED ON ALL SUBSET       
!C     REGRESSION MODELS USING THE OUTPUT OF SUBROUTINE REDUCT.          
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             RECOEF                                                    
!C             SDCOMP                                                    
!C             SUBSPC                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          X:     N*(K+1) TRIANGULAR MATRIX,OUTPUT OF SUBROUTINE REDUCT 
!C          K:     NUMBER OF REGRESSORS OF THE BAYESIAN MODEL            
!C          N:     DATA LENGTH                                           
!C          IPR:   =0  TO SUPPRESS THE OUTPUTS                           
!C                 =1  TO PRINT OUT FINAL RESULT                         
!C                 =2  TO PRINT OUT INTERIM AND FINAL RESULTS            
!C          MJ1:   ABSOLUTE DIMENSION OF X                               
!C                                                                       
!C       OUTPUTS:                                                        
!C          A(I) (I=1,K):   REGRESSION COEFFICIENTS OF BAYESIAN MODEL    
!C          SD:    RESIDUAL VARIANCE                                     
!C                                                                       

          INTEGER(kind=4) :: K, N, IPR, MJ1, 
          INTEGER(kind=4), dimension(K) :: IND
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IND:64
#endif
          REAL(kind=8), dimension(MJ1,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(K) :: A,C,C2,B
#if defined __ICC 
          !DIR$ ASSUME_ALIGNED A:64,C;64,C2:64,B:64
#endif
          REAL(kind=8) :: SD, EK, AIC, OEIC,OMEAN,OM  
          REAL(kind=8), dimension(K+1) :: C1,ESUM
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C1:64,ESUM:64
#endif
          ! Locals
          INTEGER(kind=4) :: K1,I,J
          REAL(kind=8)    :: FN, SUM, BB
          REAL(kind=8) :: D(K), G(K)
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: D,G
#endif
          K1 = K + 1                                                        
          FN = N                                                            
                         
!C                                                                       
!C          PARTIAL CORRELATIONS COMPUTATION                             
!C                                                                       
          SUM = X(K1,K1)**2
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:SUM)
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif
          DO 10   I=1,K                                                     
                  J = K1-I                                                          
                  SUM = SUM + X(J,K1)**2                                            
                  G(J) = DSQRT( SUM )                                               
!cxx   10 B(J) = X(J,K1)*X(J,J) / (G(J)*DABS(X(J,J)))                       
                  B(J) = X(J,K1)*X(J,J) / (G(J)*DABS(X(J,J))) 
       10 CONTINUE
!C                                                                       
!C          PARTIAL CORRELATIONS OF BAYESIAN MODEL COMPUTATION           
!C                                                                       

          CALL  SUBSPC( B,K,N,EK,IND,C,C1,C2,OEIC,ESUM,OMEAN,OM )
!C                                                                       
!C          MODIFICATION OF CROSS-PRODUCTS  X(I,K1) (I=1,K)              
          !C
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 30   I=1,K                                                     
                       
                   BB = B(I)*X(I,I)*G(I) / DABS(X(I,I))                            
                   D(I) = X(I,K1)                                                    

                   X(I,K1) = BB
       30 CONTINUE
!C                                                                       
!C          REGRESSION COEFFICIENTS OF BAYSIAN MODEL                     
!C                                                                       
          CALL  RECOEF( X,K,K,MJ1,A )                                       
          !C
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif          
          DO 40   I=1,K                                                     
!cxx   40 X(I,K1) = D(I)                                                    
                  X(I,K1) = D(I)
       40 CONTINUE
!C                                                                       
!C          RESIDUAL VARIANCE AND AIC                                    
!C                                                                       
                              
          CALL  SDCOMP( X,A,N,K,MJ1,SD )                                  
!C                                                                       
          IF( IPR .EQ. 0 )     RETURN                                       
          AIC = FN*DLOG(SD) + 2.D0*EK                                       
    END SUBROUTINE
                        
    SUBROUTINE CANARMF(N,LAGH3,CYY,COEF,IFPL1,SD,AIC,OAIC,MO,A,     &
             NC,MM1,MM2,V,Z,Y,XX,NDT,X3,X3MIN,MIN3,M1M,BETA,M1N,ALPHA,MJ1,MJ2)
      use omp_lib
      implicit none
        
     
!C
!cc	PROGRAM CANARM
!C     PROGRAM 74.1.1. CANONICAL CORRELATION ANALYSIS OF SCALAR TIME SERI
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(1
!C         BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C         NO.5, MARCH 1975, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** FOR THE BASIC THEORY SEE "CANONICAL CORRELATION ANALYSIS OF TIM
!C         AND THE USE OF AN INFORMATION CRITERION" BY H. AKAIKE, IN
!C         "SYSTEM IDENTIFICATION: ADVANCES AND CASE STUDIES" R. K. MEHRA
!C         D. G. LAINIOTIS EDS. ACADEMIC PRESS, NEW YORK, 1976
!C-----------------------------------------------------------------------
!C     THIS PROGRAM FITS AN AR-MA MODEL TO STATIONARY SCALAR TIME SERIES
!C     THROUGH THE ANALYSIS OF CANONICAL CORRELATIONS
!C     BETWEEN THE FUTURE AND PAST SETS OF OBSERVATIONS.
!C     THE OUTPUTS OF THIS PROGRAM SHOULD BE ADDED TO THE INPUTS
!C     TO THIS PROGRAM TO FORM AN INPUT TO THE PROGRAM AUTARM.
!C
!C     INPUTS REQUIRED:
!C     (N,LAGH0): N, LENGTH OF ORIGINAL DATA Y(I) (I=1,N)
!C                    LAGH0, MAXIMUM LAG OF COVARIANCE
!C     CYY(I),I=0,LAGH0: AUTOCOVARIANCE SEQUENCE OF Y(I)
!C
!C     OUTPUTS:
!C     NEWL: NEWL=1, FOR DIRECT INPUT TO PROGRAM AUTARM
!C     M1M: ORDER OF AR
!C     BETA(I)(I=1,M1M): AR-COEFFICIENTS
!C     M1N: ORDER OF MA (=M1M-1)
!C     ALPHA(I)(I=1,M1N): MA-COEFFICIENTS
!C
!C     THE AR-MA MODEL IS GIVEN BY
!C     Y(N)+BETA(1)Y(N-1)+...+BETA(M1M)Y(N-M1M) = X(N)+ALPHA(1)X(N-1)+...
!C                                                                      ...+ALPHA(M1N)X(N-M1N)
!C


          INTEGER(kind=4) :: N, LAGH3, IFPL1, MO, NC,  M1M, M1N, MJ1, MJ2
          INTEGER(kind=4), dimension(MJ1) :: MM1, MM2, MIN3
#if defined __ICC
          !DIR$ ASSUME_ALIGNED MM1:64,MM2:64,MM3:64
#endif
          INTEGER(kind=4), dimension(MJ1,MJ1) :: NDT
#if defined __ICC
          !DIR$ ASSUME_ALIGNED NDT:64
#endif
          REAL(kind=8) :: OAIC
          REAL(kind=8), dimension(LAGH3) :: CYY
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CYY:64
#endif
          REAL(kind=8), dimension(MJ2)   :: COEF
#if defined __ICC
          !DIR$ ASSUME_ALIGNED COEF:64
#endif
          REAL(kind=8), dimension(0:MJ1) :: SD, AIC
#if defined __ICC
          !DIR$ ASUME_ALIGNED SD:64,AIC:64
#endif
          REAL(kind=8), dimension(MJ1) :: A,ALPHA,X3MIN,BETA
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64,ALPHA:64,X3MIN:64,BETA:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1,MJ1) ::  V
#if defined __ICC
          !DIR$ ASSUME_ALIGNED V:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1) :: Z, Y, XX,X3
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,Y:64,XX:64,X3:64
#endif
          ! Locals
  
          INTEGER(kind=4) :: LAGH0,IFPL,NINEW,M9,INDX,I,J,NINEW0,M1,M2,NA, &
                           M,NEWL
          REAL(kind=8) ::  CST0, CST1, CST2, CST9, AN, EM, EN, ANDT, AII               
                   
          REAL(kind=8), dimension(MJ1)           :: WL
          REAL(kind=8), dimension(MJ2)           :: VC, VT
          REAL(kind=8), dimension(MJ2,MJ1)       :: ST, T
          REAL(kind=8), dimension((MJ2-1)*MJ2/2) :: AST1    
          REAL(kind=8), dimension(MJ1,MJ1)       :: VV
#if defined __ICC
          !DIR$  ATTRIBUTES ALIGN : 64 :: WL,VC,VT,ST,T,AST1,W
#endif
          CST0=0.0_8
          CST1=1.0_8
          CST2=2.0_8
          CST9=9999.0_8

          LAGH0=LAGH3-1

          AN=N

          NA=(IFPL1*(IFPL1+1)/2)
          CALL NSICP(CYY,LAGH3,IFPL1,N,AST1,NA,COEF,SD,AIC,A,MO,OAIC)          

                   
          NINEW=MO
          M9=MO+1

          INDX=1
!C     MATRIX MULTIPLICATION: ORTHO-NORMALIZATION OF VARIABLES BY USING
!C     AR-MODELS OF SUCCESSIVELY INCREASING ORDER
          !C     VC=AST1*CYY COMPUTATION
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 210 I=1,M9
!cxx  210 VC(I)=AST1(1)*CYY(I)
                 VC(I)=AST1(1)*CYY(I)
      210 CONTINUE
!C     VT=VC*AST1' COMPUTATION
!C     AST1 OBTAINED BY SUBROUTINE NSICP

                 CALL SVCMAT(VC,VT,M9,AST1,NA)
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                 
          DO 220 I=1,M9

                 ST(I,1)=VT(I)
      220 CONTINUE
!C     NINEW0: NUMBER OF ITERATIONS
          NINEW0=1
          NC=0
      500 M1=NINEW0+1
          NC=NC+1
          M2=M9
          M=M1+M2
!C     VC=(M1-TH ROW OF AST1)*CYY

          CALL SVECT(CYY,LAGH3,AST1,NA,VC,M9,M1,INDX)
          CALL SVCMAT(VC,VT,M9,AST1,NA)
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif          
          DO 240 I=1,M9
!cxx  240 ST(I,M1)=VT(I)
                 ST(I,M1)=VT(I)
         240 CONTINUE

                 DO 251 I=1,M9
#if defined __ICC
!DIR$ VECTOR ALIGNED
                    !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                    
                 DO 250 J=1,M1
!cxx  250 T(I,J)=ST(I,J)
                        T(I,J)=ST(I,J)
             250 CONTINUE
      251 CONTINUE
!C     SVD OF T
!C     T IS THE COVARIANCE MATRIX BETWEEN THE SETS OF THE
!C     ORTHO-NORMALIZED FUTURE AND PAST VARIABLES
!C     SINGULAR VALUES (Z) ARE THE CANONICAL CORRELATION COEFFICIENTS.
!C     COMMON SUBROUTINE CALL

          CALL MSVD(T,VV,Z(1,NC),M2,M1,MJ2,MJ1)
          CALL SVTR(VV,V(1,1,NC),AST1,NA,M1,MJ1)
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 260 J=1,M1

                 Y(J,NC)=Z(J,NC)*Z(J,NC)
      260 CONTINUE
!C     FUTURE CANONICAL WEIGHTS (V) PRINT OUT

          MM1(NC)=M1
          MM2(NC)=M2
!C     TEST OF DEPENDENCE OF THE LAST PREDICTOR BY DIC (DIFFERENCE OF AIC

          EM=M
          EN=N
          J=M1
          WL(J+1)=CST1

       42 WL(J)=WL(J+1)*(CST1-Y(J,NC))
          J=J-1
          IF(J.GT.0) GO TO 42
          DO 45 J=1,M1
                IF(WL(J).GT.CST0) GO TO 145

                XX(J,NC)=CST9
                GO TO 45

      145 XX(J,NC)=-EN*DLOG(WL(J))
       45 CONTINUE

          NDT(1,NC)=M1*M2
          ANDT=NDT(1,NC)

          X3(1,NC)=XX(1,NC)-CST2*ANDT

          J=0

          X3MIN(NC)=X3(1,NC)
          MIN3(NC)=0
          IF(M1.LT.2) GO TO 4110
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 51 J=2,M1
                J1=J-1

                NDT(J,NC)=(M1-J1)*(M2-J1)
                ANDT=NDT(J,NC)
                X3(J,NC)=XX(J,NC)-CST2*ANDT

       51 CONTINUE
          DO 4300 J=2,M1
!C     MINIMUM OF DIC SERCH

                  IF(X3(J,NC).GE.X3MIN(NC)) GO TO 4300
                  X3MIN(NC)=X3(J,NC)
                  MIN3(NC)=J-1
     4300 CONTINUE

     4110 CONTINUE

          IF(NINEW0.EQ.NINEW) GO TO 6999
!C     DEPENDENCE ACCEPTED WHEN M1N-DIC IS NEGATIVE

          IF(X3(M1,NC).GT.CST0) GO TO 110
     6999 M1M=M1-1
          IF(M1M.LE.0) GO TO 110
!C     BETA(AR-COEFF) COMPUTATION

          AII=CST1/V(M1,M1,NC)
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#endif
          DO 5100 I=1,M1M
                  II=M1-I

                  BETA(II)=V(M1,I,NC)*AII
     5100 CONTINUE
!C     ALPHA(MA-COEFF) COMPUTATION

          CALL ALPHAS(COEF,M1M,BETA,ALPHA)
!C     THE INPUTS TO THE PROGRAM AUTAMA PUNCH OUT
     5400 NEWL=1



          IF  (M1M.LE.0) GO TO 5200

     5200 M1N=M1M-1

          IF  (M1N.LE.0) GO TO 1100

          GO TO 1100
      110 IF(NINEW0.LT.NINEW) GO TO 5300
          M1M=0
          GO TO 5400
     5300 NINEW0=NINEW0+1
          GO TO 500
!cc 1100 CALL FLCLS3(NFL)
     1100 CONTINUE
    END SUBROUTINE
             
      

    SUBROUTINE ALPHAS(A,M1M,BETA,ALPHA)
      use omp_lib
      implicit none
         
!C     THIS SUBROUTINE COMPUTES ALPHA(MA-COEFFICIENTS).

          INTEGER(kind=4) :: M1M
          REAL(kind=8), dimension(M1M) :: A, BETA, ALPHA
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64,BETA:64,ALPHA:64
#endif
          REAL(kind=8) :: SUM
          ! Locals
          INTEGER(kind=4) :: IPM,K,KM1,I,KMI
          ! Wxec code...
          ALPHA(M1M)=0.0_8
          IF  (M1M.LE.1) GO TO 20
          ALPHA(1)=BETA(1)-A(1)
          IF(M1M.LE.2) GO TO 20
          IPM=M1M-1
          DO 10 K=2,IPM
                KM1=K-1
                SUM=0.0_8
#if defined   __ICC              
                !DIR$ VECTOR ALIGNED
                !DIR$ SIMD REDUCTION(-:SUM)
#elif defined __GFORTRAN__
                !$OMP SIMD REDUCTION(-:SUM)
#endif
                DO 11 I=1,KM1
                      KMI=K-I

                      SUM=SUM-ALPHA(I)*A(KMI)
             11 CONTINUE
                ALPHA(K)=BETA(K)-A(K)+SUM
       10 CONTINUE

       20 CONTINUE
    END SUBROUTINE
    
     

    SUBROUTINE NSICP(CYY,L3,L1,N,AST1,NA,COEF,SD,AIC,AA,MO,OAIC)      
      use omp_lib
      implicit none
         
!C     COMMON SUBROUTINE
!C     THIS SUBROUTINE FITS AUTOREGRESSIVE MODELS OF SUCCESSIVELY
!C     INCREASING ORDER UP TO L(=L1-1).
!C     INPUT:
!C     CYY(I),I=0,L1; AUTOCOVARIANCE SEQUENCE
!C     L1: L1=L+1, L IS THE UPPER LIMIT OF THE MODEL ORDER
!C     N; LENGTH OF ORIGINAL DATA
!C     OUT PUT:
!C     COEF; AR-COEFFICIENTS
!C     MO: ORDER OF AR
!C     OSD: INNOVATION VARIANCE
!C     OAIC: VALUE OF AIC
!C     AST1: MATRIX OF AR-COEFFICIENTS (IN VECTOR FORM)

          INTEGER(kind=int4) :: L3, L1, N, NA, MO
          REAL(kind=dp), dimension(3) :: CYY 
          REAL(kind=dp), dimension(NA) :: AST1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AST1:64
#endif
          REAL(kind=dp), dimension(L1) :: COEF, AA
#if defined __ICC
          !DIR$ ASSUME_ALIGNED COEF:64,AA:64
#endif
          REAL(kind=dp), dimension(0:L1) :: SD, AIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED SD:64,AIC:64
#endif
          REAL(kind=dp) ::       OAIC
          CHARACTER AX,BL,STA,DASH,PLUS
          INTEGER(kind=int4) :: L,INX,JJ0,JJL,JJL1,IAN,IAN1,LAN1,LAN2,I,J,NFC
          REAL(kind=dp) ::  CST0, CST1, CST2, CST20, CST05, CST01,   &
                         AM, AN, RAN, SCALH, SE, SDR, D, D2, CONST, DLSD
          REAL(kind=dp), dimension(L1) :: A, B
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: A,B
#endif      
     

          DATA AX,BL,STA,DASH,PLUS/'!',' ','*','-','+'/

          CST0=0.0_8
          CST1=1.0_8
          CST2=2.0_8
          CST20=20.0_8
          CST05=0.05_8
          CST01=0.00001_8
          L=L1-1

          SD(1)=CYY(1)
          INX=1

          AST1(1)=CST1/DSQRT(SD(1))
          AN=N

          OAIC=AN*DLOG(SD(1))
          MO=0

          SD(0)=SD(1)
          AIC(0)=OAIC

          RAN=CST1/DSQRT(AN)
          SCALH=CST20

          JJ0=INT(SCALH+CST1)
          JJL=INT(SCALH*CST2+CST1)
          JJL1=JJL-1

          IAN=INT(SCALH*(RAN+CST05))
          IAN1=IAN+JJ0
          IAN2=2*IAN+JJ0
          LAN1=-IAN+JJ0
          LAN2=-2*IAN+JJ0

          SE=CYY(2)
!C     ITERATION START
          DO 400 M=1,L

                 SDR=SD(M)/CYY(1)
                 IF(SDR.GE.CST01) GO TO 399

                 GO TO 402
             399 MP1=M+1

                 D=SE/SD(M)
                 A(M)=D
                 D2=D*D

                 SD(M)=(CST1-D2)*SD(M)
                 CONST=CST1/DSQRT(SD(M))
                 AM=M

                 AIC(M)=AN*DLOG(SD(M))+CST2*AM

                 DLSD=DLOG(SD(M))
                 IF(M.EQ.1) GO TO 410

                 LM=M-1
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD
#endif
                 DO 420 I=1,LM
                        A(I)=A(I)-D*B(I)
             420 CONTINUE
             410 DO 460 I=1,M
                        II=M+1-I
                        INX=INX+1

                        AST1(INX)=-A(II)*CONST
            460 CONTINUE
                INX=INX+1
                AST1(INX)=CONST
                DO 421 I=1,M
                       IM=MP1-I

                       B(I)=A(IM)
              421 CONTINUE

                  IF(A(M).LT.CST0) GO TO 300

                  NFC=INT(SCALH*(A(M)+CST05))
                  GO TO 310

              300 NFC=INT(SCALH*(A(M)-CST05))
              310 ANFC=NFC

                  JJ=INT(ANFC+SCALH+CST1)

                  AA(M)=A(M)

                  IF(OAIC.LT.AIC(M)) GO TO 440
                  OAIC=AIC(M)

                  MO=M
#if defined __ICC
!DIR$ VECTOR ALIGNED
                  !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD
#endif                  
                  DO 430 I=1,M

                       COEF(I)=-A(I)
              430 CONTINUE
              440 IF(M.EQ.L) GO TO 400
                  SE=CYY(M+2)
                  DO 441 I=1,M

                         SE=SE-B(I)*CYY(I+1)
             441 CONTINUE
                 SD(M+1)=SD(M)
      400 CONTINUE
      402 CONTINUE
    END SUBROUTINE
    


   
    SUBROUTINE SVCMAT(VC,VT,M9,AST1,NA)
      use omp_lib
      implicit none
         
!C     THIS SUBROUTINE COMPUTES VT=VC*AST1'.
!C     AST1 IS AN OUTPUT OF NSICP.

          INTEGER(kind=4) :: M9, NA
          REAL(kind=8), dimension(M9) :: VC, VT
#if defined __ICC
          !DIR$ ASSUME_ALIGNED M9:64,NA:64
#endif
          REAL(kind=8), dimension(NA) :: AST1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AST1:64
#endif
          INTEGER(kind=8) :: INX,I,K
          REAL(kind=8) :: CST0, SUM
          CST0=0.0_8
          INX=0
          DO  10 I=1,M9
             SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED             
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif
                 DO 11 K=1,I
                       INX=INX+1

                       SUM=SUM+VC(K)*AST1(INX)
              11 CONTINUE
              VT(I)=SUM
      10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE SVTR(VV,V,AST1,NA,M1,MJ1)
      use omp_lib
      implicit none
         
!C     THIS SUBROUTINE COMPUTES FUTURE SET CANONICAL WEIGHTS DEFINED BY
!C     V=VV'*AST1.
!C     AST1 IS AN OUTPUT OF NSICP.

          INTEGER(kind=4) :: NA, M1, MJ1
          REAL(kind=8), dimension(MJ1,MJ1) :: VV, V
#if defined __ICC
          !DIR$ ASSUME_ALIGNED VV:64,V:64
#endif
          REAL(kind=8), dimension(NA) :: AST1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AST1:64
#endif
          ! Locals
          INTEGER(kind=4) :: I,ISUM,LL,J,INX,IJK
          REAL(kind=8) :: CST0, SUM
          INTEGER(kind=4), dimension(M1) :: ISUM1
      
          CST0=0.0_8
          ISUM=0
          DO 15 I=1,M1
                  ISUM=ISUM+I

                  ISUM1(I)=ISUM
       15 CONTINUE
          DO 10 I=1,M1
                DO 11 J=1,M1
                      SUM=CST0
                      LL=ISUM1(J)
                      INX=0
#if defined __ICC
                      !DIR$ VECTOR ALIGNED
                      !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                      !$OMP SIMD REDUCTION(+:SUM)
#endif
                      DO 12 K=J,M1
                            IJK=LL+INX
                            SUM=SUM+VV(K,I)*AST1(IJK)
                            INX=INX+K
                    12 CONTINUE
                       V(I,J)=SUM
              11 CONTINUE
      10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: SVECT
#endif
    SUBROUTINE SVECT(CYY,L3,AST1,NA,VC,M9,M1,INDX)
      use omp_lib
      implicit none
!C     THIS SUBROUTINE COMPUTES VC=(M1-TH ROW OF AST1)*(CYY MATRIX)
!C     AST1 IS AN OUTPUT OF NSICP.

          INTEGER(kind=4) :: L3, NA, M9, M1, INDX
          REAL(kind=8), dimension(L3) :: CYY
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CYY:64
#endif
          REAL(kind=8), dimension(NA) :: AST1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AST1:64
#endif
          REAL(kind=8), dimension(M9) :: VC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED VC:64
#endif
          INTEGER(kind=4) :: I,IS,ISM,II
          REAL(kind=8) :: CST0
          CST0=0.0_8
          
          VC(1:M9)=CST0
          DO 20 IS=1,M1
                INDX=INDX+1
                ISM=IS-1
#if defined __ICC
                !DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
                DO  30 I=1,M9
                       II=ISM+I
                       VC(I)=VC(I)+AST1(INDX)*CYY(II)
               30 CONTINUE
       20 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE CANOCAF(IR,INW,N,LAGH1,IP0,CCV,L,AIC,OAIC,MO,OSD,AAO,                     &
               NC,N1,N2,VV,Z,Y,XX,NDT,X3,X3MIN,MIN3,F,M1NH,NH,G,IAW,VF,                  &
               LMAX,MJ0,MJ1)
      use omp_lib
      implicit none
      
        
!cc	PROGRAM CANOCA
!C     PROGRAM 74.2.1. CANONICAL CORRELATION ANALYSIS OF VECTOR TIME SERI
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(1
!C         BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C         NO.5, MARCH 1975, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** FOR THE BASIC THEORY SEE "CANONICAL CORRELATION ANALYSIS OF TIM
!C         AND THE USE OF AN INFORMATION CRITERION" BY H. AKAIKE, IN
!C         "SYSTEM IDENTIFICATION: ADVANCES AND CASE STUDIES" R. K. MEHRA
!C         D. G. LAINIOTIS EDS. ACADEMIC PRESS, NEW YORK, 1976
!C-----------------------------------------------------------------------
!C     THIS PROGRAM DOES CANONICAL CORRELATION ANALYSIS OF AN IR-DIMENSIO
!C     MULTIVARIATE TIME SERIES Y(I) (I=1,N).
!C
!C     FIRST AR-MODEL IS FITTED BY THE MINIMUM  A I C  PROCEDURE.
!C     THE RESULTS ARE USED TO ORTHO-NORMALIZE THE PRESENT AND PAST VARIA
!C     THE PRESENT AND FUTURE VARIABLES ARE TESTED SUCCESSIVELY TO DECIDE
!C     ON THE DEPENDENCE OF THEIR PREDICTORS. WHEN THE LAST DIC (AN INFOR
!C     CRITERION) IS NEGATIVE THE PREDICTOR OF THE VARIABLE IS DECIDED
!C     TO BE LINEARLY DEPENDENT ON THE ANTECEDENTS.
!C
!C     THE STRUCTURAL CHARACTERISTIC VECTOR H OF THE CANONICAL MARKOVIAN
!C     REPRESENTATION AND THE ESTIMATE OF THE TRANSITION MATRIX F, IN
!C     VECTOR FORM, ARE PUNCHED OUT. THE ESTIMATE OF THE INPUT MATRIX G A
!C     THE COVARIANCE MATRIX C OF THE INNOVATION, OBTAINED BY USING
!C     THE F-MATRIX AND THE AR-MODEL, ARE ALSO PUNCHED OUT.
!C
!C     INPUTS REQUIRED:
!C     IR:		 DIMENSION OF Y(I)
!C     INW(K)(K=1,IP):	 INW(K)=J MEANS THAT THE K-TH COMPONENT OF Y(I)
!C          IS THE J-TH COMPONENT OF THE ORIGINAL RECORD Z(I) USED FOR
!C          THE COMPUTATION OF THE COVARIANCE SEQUENCE CZZ(I).
!C
!C     ALSO THE FOLLOWING INPUTS ARE REQUESTED BY THE SUBROUTINE	 R E C O
!C     THESE INPUTS CAN BE OBTAINED AS THE OUTPUTS OF THE TIMSAC
!C     PROGRAM 5.1.2 ( MULCOR ).
!C     N:		 DATA LENGTH
!C     LAGH:		 MAXIMUM LAG OF COVARIANCE
!C     IP0:		 DIMENSION OF THE ORIGINAL RECORD
!C     CZZ(I)(I=0,LAGH):	 COVARIANCE MATRIX SEQUENCE OF Z(I) GIVEN IN THE
!C         OF THE SUCCESSION OF THE SEQUENCES OF COVARIANCES BETWEEN THE
!C         C-TH COMPONENTS OF Z(I), ARRANGED IN THE ORDER (R=1,C=1),(R=2,
!C         (R=2,C=1),(R=1,C=2),(R=3,C=3),(R=3,C=1),(R=1,C=3),(R=3,C=2),(R
!C         ...... EACH SEQUENCE HAS THE HEADING (R,C).
!C         THE (J+1)ST ELEMENT OF THE COVARIANCE SEQUENCE WITH R=K AND C=
!C         IS AN ESTIMATE OF E(Z(I+J,K)*Z(I,L)), WHERE Z(I,K) DENOTES
!C         THE K-TH COMPONENT OF Z(I).
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: CANOCAF
!C

        
          INTEGER(kind=4) :: IR 
          INTEGER(kind=4), dimension(IR) :: INW
#if defined __ICC
          !DIR$ ASSUME_ALIGNED INW:64
#endif
          INTEGER(kind=4) :: N, LAGH1, IP0, L, MO, NC 
          INTEGER(kind=4), dimension(MJ1) :: N1,N2,NH
#if defined __ICC
          !DIR$ ASSUME_ALIGNED N1:64,N2:64,NH:64
#endif
          INTEGER(kind=4), dimension(MJ1,MJ1) :: NDT
#if defined __ICC
          !DIR$ ASSUME_ALIGNED NDT:64
#endif
          INTEGER(kind=4), dimension(MJ0*IR) :: MIN3
#if defined __ICC
          !DIR$ ASSUME-ALIGNED MIN3:64
#endif
          INTEGER(kind=4) ::  M1NH, IAW,LMAX,MJ0,MJ1
    
          REAL(kind=8), dimension(LAGH1,IP0,IP0) :: CCV
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CCV:64
#endif
          REAL(kind=8), dimension(MJ0) :: AIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AIC:64
#endif
          REAL(kind=8) :: OAIC 
          REAL(kind=8), dimension(IR,IR) :: OSD
#if defined __ICC
          !DIR$ ASSUME_ALIGNED OSD:64
#endif
          REAL(kind=8), dimension(MJ0,IR,IR) :: AAO
#if defined __ICC          
          !DIR$ ASSUME_ALIGNED AAO:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1,MJ1) ::  VV
#if defined __ICC          
          !DIR$ ASSUME_ALIGNED VV:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1) :: Z,Y,XX,X3,F,VF
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,Y:64,XX:64,X3:64,F:64,VF:64
#endif
          REAL(kind=8), dimension(MJ0*IR) :: X3MIN
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X3MIN:64
#endif
          REAL(kind=8), dimension(MJ1,IR) :: G
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64
#endif
          ! Locals
          INTEGER(kind=4) :: I,J,IL,IP,K,L1,II,ID,LMAX2,MMMH,NINEW, &
                           M1,M2,ISW,NINEW0,M,MP1,IDB,IRES,JJ,JRES, &
                           JDB,IJDB,IJDB1,MM1,LCV,LCV1,NINEWI
          REAL(kind=8) ::  CST0, CST1, CST2, XL, YL, R11C, FCT, SS, FSRINP,  &
                         SSFR2, SG, EM, EN, ANDT, AII
          INTEGER(kind=4), dimension(MJ1) :: IH
          REAL(kind=8), dimension(MJ1) :: WL, VTG, SR,ZZ, SF, SFRG 
          REAL(kind=8), dimension(LMAX*2+1,IR,IR) :: CV 
          REAL(kind=8), dimension(MJ1,MJ1) :: U, V, RGT,FL,FRG
          REAL(kind=8), dimension((LMAX+1)*LMAX,IR,IR) :: AST1 
          REAL(kind=8), dimension(IP0,IP0) :: C1
          REAL(kind=8), dimension(MJ0,IR,IR) :: AO
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: IH,WL,VTG,SR,ZZ,SF,SFRG
!DIR$ ATTRIBUTES ALIGN : 64 :: CV,U,V,RGT,FL,FRG,AST1,C1,AO
#endif

          NC = 0
          CST0=0.0_8
          CST1=1.0_8
          CST2=2.0_8

          DO 3111 I=1,MJ1
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
                 DO 3112 J=1,IR
                         G(I,J)=CST0
3112                     CONTINUE
#if defined __ICC
!DIR$ VECTOR ALIGNED                         
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif                         
                         DO 3113 J=1,MJ1
                                 F(I,J)=CST0
                    3113 CONTINUE

     3111 CONTINUE
!C     INITIAL CONDITION INPUT

          IL=0
          IP=IR

          LCV=LMAX*2
          LCV1=LCV+1
!C     AUTO COVARIANCE INPUT

          DO 92 I=1,MIN(LCV1,LAGH1)
             DO 91 J=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED                
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(K:1)
#endif                
                      DO 90 K=1,IP
                            CV(I,J,K) = CCV(I,J,K)
                90    CONTINUE
         91    CONTINUE
       92 CONTINUE
!C     L (UPPER BOUND OF AR-ORDER) COMPUTATION

          XL=2*N
          XL=DSQRT(XL)
          YL=IR

          J=INT(XL/YL)
          L= MIN0(LMAX,J)
          L1=L+1
!C     MATRIX ARRANGEMENT
          DO 10 II=1,LCV1

                DO 11 I=1,IP0
                      DO 20 J=1,IP0

                             C1(I,J)=CV(II,I,J)
                   20 CONTINUE
             11 CONTINUE
!C     MATRIX REARRANGEMENT BY INW
!C     COMMON SUBROUTINE CALL

                CALL REARRA(C1,INW,IP0,IP)

                DO 12 I=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED                   
                   !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif                   
                      DO 21 J=1,IP

                           CV(II,I,J)=C1(I,J)
                  21 CONTINUE
             12 CONTINUE
       10 CONTINUE

          IAW=0
          ID=IR
          LMAX2=(LMAX+1)*LMAX
!C     AR-MODEL FITTING BY THE MINIMUM AIC PROCEDURE

          CALL NWFPEC(AIC,OAIC,CV,AST1,OSD,AO,AAO,L,IR,IL,N,MO,MJ0,   &
                      LMAX2,LCV1)
!C     MO: MAICE AR-MODEL ORDER DETERMINED BY NWFPEC

          CALL SBRUGT(MO,ID,AST1,CV,RGT,MJ1,IR,LMAX2,LCV1)
          MMMH=(MO+1)*ID
          NINEW=MMMH
!C     FRG' COMPUTATION
!C     M1: NUMBER OF VARIABLE IN THE FUTURE SET
!C     M2: NUMBER OF VARIABLES IN THE PAST SET =MMMH
          M1=1
          R11C=CV(1,1,1)

          FL(1:MJ1,1:MJ1)=CST0

          FL(1,1)=CST1/DSQRT(R11C)
          FCT=FL(1,1)
          M2=(MO+1)*ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
          DO 100 J=1,M2
                 FRG(1,J)=FCT*RGT(1,J)
      100 CONTINUE
          ISW=0
          NINEW0=2
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
          DO 191 I=1,IR

                 NH(I)=I
      191 CONTINUE

          IH(1:MMMH)=0
      500 M1=M1+1
          M2=MMMH
          M=M1+M2
          MP1=M1+1
!C     COVARIANCE MATRIX ARRANGEMENT
          NINEWI=NINEW0
          DO 636 I=NINEWI,MMMH
                 IF(IH(I).EQ.0) GO TO 637
!C     TEST OF EXHAUSTION OF FUTURE VARIABLES
                 IF(I.GE.MMMH) GO TO 1140
                 NINEW0=NINEW0+1
                 GO TO 636
             637 NH(M1)=I
                 GO TO 638
      636 CONTINUE
      638 CONTINUE
!C     THE AUGMENTED FRG' MATRIX (F+)(G+)G' IS OBTAINED BY THE
!C     BORDERING TECHNIQUE:
!C                           +-         -+
!C                  (F+) = I F    0     I
!C                           I             I
!C                           I             I
!C                           I SF'  SG  I
!C                           +-         -+,
!C                           +-         -+
!C              (RVV+) = I RVV  SR I
!C                           I             I
!C                           I             I
!C                           I SR'  SS  I
!C                           +-        - +,
!C              (F+)(RVV+)(F+)'=I,
!C                           +-         -+
!C                  (R+) = I    R      I
!C                           I            I
!C!                           I            I
!C                           I    ST'    I
!C                           +-         -+,
!C             AND
!C                           +-         -+
!C          (F+)(R+)G' = I   FRG'    I
!C                           I             I
!C                           I             I
!C                           I  LRFRG  I
!C                           +-         -+,
!C        FRG' IS STORED AS FRG.
!C     SR,SS,VTG=(ST)'G' ARRANGEMENT
          II=NH(M1)
          IDB=II/ID
          IRES=II-IDB*ID
          IF(IRES.NE.0) IDB=IDB+1
          IF(IRES.EQ.0) IRES=ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
          DO 640 J=1,M2

                 VTG(J)=RGT(II,J)
      640 CONTINUE
          DO 642 J=1,M1
                 JJ=NH(J)
                 JDB=JJ/ID
                 JRES=JJ-JDB*ID
                 IF(JRES.NE.0) JDB=JDB+1
                 IF(JRES.EQ.0) JRES=ID
                 IJDB=IDB-JDB
                 IF(IJDB.LT.0) GO TO 646
                 SR(J)=CV(IJDB+1,IRES,JRES)
                 GO TO 642
      646 IJDB1=-IJDB+1
          SR(J)=CV(IJDB1,JRES,IRES)
      642 CONTINUE
          SS=SR(M1)
!C     ZZ= F*SR COMPUTATION (F STORED AS FL IN COMMON AREA)
          MM1=M1-1

          CALL BLMLVC(SR,ZZ,MM1,FL,MJ1)
!C     INNER PRODUCT OF FL*SR COMPUTATION

          CALL INNERP(ZZ,ZZ,FSRINP,MM1)
!C     SG COMPUTATION
          SSFR2=SS-FSRINP

          IF  (SSFR2 .LT. 0) GO TO 731
          IF  (SSFR2 .EQ. 0) GO TO 731
          IF  (SSFR2 .GT. 0) GO TO 732
      731 SG=CST0
          GO TO 733
      732 SG=CST1/DSQRT(SSFR2)
!C     SF=-(F'*(F*SR))*SG COMPUTATION

733       CALL AVMLVC(ZZ,SF,MM1,FL,MJ1)
#if defined __ICC
 !DIR$ VECTOR ALIGNED         
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(I:1)
#endif
          DO 350 I=1,MM1

                 SF(I)=-SF(I)*SG
350       CONTINUE
                 !C     F AUGMENTATION
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
          DO 360 J=1,MM1

             FL(M1,J)=SF(J)
      360 CONTINUE
          FL(M1,M1)=SG
!C     SFRG=SF'*R12*G' COMPUTATION

          CALL VECMTX(SF,SFRG,NH,RGT,MM1,M2,MJ1)
          !C      LRFRG=SFRG+SG*VTG (=THE LAST ROW OF (F+)(R+)G')
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(I:1)
#endif          
          DO 370 I=1,M2

                 FRG(M1,I)=SFRG(I)+SG*VTG(I)
      370 CONTINUE

                 DO 231 I=1,M2
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                    !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
                 DO 230 J=1,M1
                        U(I,J)=FRG(J,I)
             230 CONTINUE
      231 CONTINUE
!C     CANONICAL WEIGHTS FOR THE SET OF ORTHO-NORMALIZED FUTURE VARIABLES
!C     ARE OBTAINED IN V(COMMON AREA).
!C     CANONICAL CORRELATION COEFFICIENTS ARE RETURNED IN Z.
!C     COMMON SUBROUTINE CALL
!cc      CALL MSVD(Z,M2,M1)
          NC = NC+1
          CALL MSVD(U,V,Z(1,NC),M2,M1,MJ1,MJ1)
!C     W=V'*FL : CANONICAL WEIGHTS COMPUTATION

          CALL MWTFL(V,VV(1,1,NC),M1,FL,MJ1)
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif
          DO 260 J=1,M1

                 Y(J,NC)=Z(J,NC)*Z(J,NC)
      260 CONTINUE

          N1(NC)=M1
          N2(NC)=M2

          EM=M
          EN=N
          J=M1
          WL(J+1)=CST1

       42 WL(J)=WL(J+1)*(CST1-Y(J,NC))
          J=J-1
          IF(J.GT.0) GO TO 42
          DO 45 J=1,M1
                IF(WL(J).GT.CST0) GO TO 145

                XX(J,NC)=9999.0_8
                GO TO 45

            145 XX(J,NC)=-EN*DLOG(WL(J))
       45 CONTINUE

          NDT(1,NC)=M1*M2
          ANDT=NDT(1,NC)

          X3(1,NC)=XX(1,NC)-CST2*ANDT

          J=0

          X3MIN(NC)=X3(1,NC)
          MIN3(NC)=0
          IF(M1.LT.2) GO TO 4110
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif          
          DO 51 J=2,M1
                J1=J-1

                NDT(J,NC)=(M1-J1)*(M2-J1)
                ANDT=NDT(J,NC)
                X3(J,NC)=XX(J,NC)-CST2*ANDT
       51 CONTINUE
          DO 4300 J=2,M1

                  IF(X3(J,NC).GE.X3MIN(NC)) GO TO 4300
                  X3MIN(NC)=X3(J,NC)
                  MIN3(NC)=J-1
     4300 CONTINUE

     4110 CONTINUE

          IF(NINEW0.EQ.NINEW) GO TO 6999
          IF(X3(M1,NC).GT.CST0) GO TO 110
     6999 M1M=M1-1
          IF(M1M.LE.0) GO TO 110
!C     TRANSITION MATRIX (F) COMPUTATION

          AII=CST1/VV(M1,M1,NC)
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD LINEAR(J:1)
#endif          
          DO 5100 I=1,M1M
                  IAW=IAW+1

                  F(I,NC)=-VV(M1,I,NC)*AII
                  VF(IAW)=F(I,NC)
     5100 CONTINUE

          M1=M1-1
          ISW=ISW+1
          DO 1120 I=NINEW0,MMMH,ID

                  IH(I)=1
     1120 CONTINUE
          IF(ISW.GE.ID) GO TO 1100
      110 IF(NINEW0.GE.NINEW) GO TO 1100
          NINEW0=NINEW0+1
          GO TO 500
     1140 M1=M1-1

     1100 CONTINUE
!C     STRUCTURAL CHARACTERISTIC VECTOR PRINT AND PUNCH OUT
          M1NH=M1

          CALL SUBBMA(AO,G,NH,M1,ID,MO,MJ1,MJ0)
!C     INPUT MATRIX (G) PRINT AND PUNCH OUT

          CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: AVMLVC
#endif
    SUBROUTINE AVMLVC(Y,Z,MM,FL,MJ1)
      use omp_lib
      implicit none
         
!C     Z=FL'*Y
!C     FL: LOWER TRIANGLE
!C     Y: VECTOR

         INTEGER(kind=4) :: MM ,MJ1
         REAL(kind=8), dimension(MM) :: Y, Z
         !DIR$ ASSUME_ALIGNED Y:64,Z:64
         REAL(kind=8), dimension(MJ1,MJ1) :: FL
         !DIR$ ASSUME_ALIGNED FL:64
         ! Locals
         INTEGER(kind=4) :: I,J
         REAL(kind=8) :: CST0, SUM
         CST0=0.0_8
         DO 10 I=1,MM
            SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED            
            !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
            !$OMP SIMD REDUCTION(+:SUM) LINEAR(J:1)
#endif
               DO 11 J=I,MM

                     SUM=SUM+FL(J,I)*Y(J)
            11 CONTINUE
               Z(I)=SUM
       10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: BLMLVC
#endif
    SUBROUTINE BLMLVC(Y,Z,MM,FL,MJ1)
      use omp_lib
      implicit none
!C     Z=FL*Y
!C     FL: LOWER TRIANGLE
!C     Y: VECTOR

          INTEGER(kind=4) :: MM, MJ1
          REAL(kind=8), dimension(MM) :: Y, Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Y:64, Z:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1) :: FL
#if defined __ICC
          !DIR$ ASSUME_ALIGNED FL:64
#endif
          INTEGER(kind=4) :: I,J
          REAL(kind=8) :: CST0, SUM
          CST0=0.0_8
          DO 10 I=1,MM
             SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED             
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif
                DO 11 J=1,I

                     SUM=SUM+FL(I,J)*Y(J)
            11 CONTINUE
               Z(I)=SUM
       10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: MWTFL
#endif
    SUBROUTINE MWTFL(V,VV,MM,FL,MJ1)
      use omp_lib
      implicit none
!C     VV=V'*FL

          INTEGER(kind=4) :: MM, MJ1
          REAL(kind=8), dimension(MJ1,MJ1) :: V, VV, FL
#if defined __ICC
          !DIR$ ASSUME_ALIGNED V:64,VV:64,FL:64
#endif
          INTEGER(kind=4) :: I,J,K
          REAL(kind=8) :: CST0, SUM
          CST0=0.0_8
          DO 10 I=1,MM
                DO 11 J=1,MM
                   SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED                   
                   !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                   !$OMP SIMD REDUCTION(+:SUM) LINEAR(K:1)
#endif
                      DO 12 K=1,MM

                           SUM=SUM+V(K,I)*FL(K,J)
                   12 CONTINUE
                      VV(I,J)=SUM
             11 CONTINUE
       10 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE NLTIV(R,RIN,DET,K)
        implicit none
!C     INVERSE OF R IS FACTORI
!C     INVERSE OF R IS FACTORED INTO THE FORM L'*L IS
!C     INVERSE OF R IS FACTORED INTO THE FORM L'*L. L,LOWER
!C     INVERSE OF R IS FACTORED INTO THE FORM L'*L. L, LOWER TRIANGULAR,
!C     IS RETURNED IN R. OTHER OUTPUTS ARE
!C     RIN: INVERSE OF DIAGONAL L(I,J)
!C     DET: DETERMINANT OF R(I,J)
!C     MJ IS THE ABSOLUTE DIMENSION OF R IN THE MAIN ROUTINE

          INTEGER(kind=4) :: K
          REAL(kind=8), dimension(K,K) :: R
#if defined __ICC
          !DIR$ ASSUME_ALIGNED R:64
#endif
          REAL(kind=8), dimension(K) :: RIN
#if defined __ICC
          !DIR$ ASSUME_ALIGNED RIN:64
#endif
          REAL(kind=8) :: DET
          INTEGER(kind=4) :: KM1,L,I,L1,
          REAL(kind=8) :: CST0, CST1, ABC0, RR, RPIVOT, RIL
          CST0=0.0_8
          CST1=1.0_8
          KM1=K-1
          ABC0=CST0
          DET=CST1
          DO 10 L=1,K
                RR=R(L,L)
                DET=DET*RR
                RPIVOT=CST1/DSQRT(RR)
                R(L,L)=RPIVOT
                RIN(L)=CST1/RPIVOT
                DO 12 I=1,K
                      IF(I.EQ.L) GO TO 12
                      R(L,I)=RPIVOT*R(L,I)
             12 CONTINUE
                IF(L.EQ.K) GO TO 11
                L1=L+1
              
                DO 13 I=L1,K
                      RIL=-RPIVOT*R(I,L)
                      R(I,L)=RIL*RPIVOT
                      DO 14 M=1,K
                            IF(M.EQ.L) GO TO 14
                            R(I,M)=R(I,M)+RIL*R(L,M)
                     14 CONTINUE
            13 CONTINUE
        10 CONTINUE
   11 RETURN
    END SUBROUTINE
    

    SUBROUTINE NWFPEC(AAIC,OAIC,CV,AST1,OSD,AO,AAO,L,IR,IL,N,IFPEC,    &
                      MJ0,LMAX2,LCV1)
      use omp_lib
      implicit none
!C     AR-FITTING
!C     AUTOREGRESSIVE MODEL FITTING BY THE MINIMUM AIC PROCEDURE.

          INTEGER(kind=4) :: L, IR, IL, N, IFPEC, MJ0, LMAX2, LCV1
          REAL(kind=8), dimension(0:MJ0-1) :: AAIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AAIC:64
#endif
          REAL(kind=8) :: OAIC 
          REAL(kind=8), dimension(LCV1,IR+IL,IR+IL) :: CV
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CV:64
#endif
          REAL(kind=8), dimension(LMAX2,IR+IL,IR+IL) :: AST1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AST1:64
#endif
          REAL(kind=8), dimension(IR,IR) :: OSD
#if defined __ICC
          !DIR$ ASSUME_ALIGNED OSD:64
#endif
          REAL(kind=8), dimension(MJ0,IR,IR+IL) :: AO, AAO
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AO:64,AAO:64
#endif
          ! Locals
          INTEGER(kind=4) :: IP,L1,L,II,JJ,MS,INX,IMI
          REAL(kind=8)    ::   AIC, SFDT, SDDET, SFDET
          REAL(kind=8), dimension(L,IR+IL,IR+IL) :: A1, B1
          REAL(kind=8), dimension(IR+IL,IR+IL) :: D, SE, SF,XSD, XSF,  E, Z1, SFL, B
          REAL(kind=8), dimension(IR+IL) :: RIN
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: A1,B1,D,SE,SF,XSD,XSF,E,Z1,SFL,B  
#endif    

          IP=IR+IL
          L1=L+1
          CST0=0.0_8
!C     INITIAL CONDITION AND COVARIANCE PRINT OUT
!C     INITIAL SD, SF, SE COMPUTATION

          DO 331 II=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED             
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                 DO 330 JJ=1,IP
                        SD(II,JJ)=CV(1,II,JJ)
                        SF(II,JJ)=SD(II,JJ)
                        SFL(II,JJ)=SF(II,JJ)
                        SE(II,JJ)=CV(2,II,JJ)
                        XSD(II,JJ)=SD(II,JJ)
!cxx  330 XSF(II,JJ)=SF(II,JJ)
                        XSF(II,JJ)=SF(II,JJ)
             330 CONTINUE
      331 CONTINUE
!C     0-TH STEP COMPUTATION
          IFPEC=0
          MS=0
!C     AIC COMPUTATION

          CALL SAIC (SD,N,IP,MS,AIC)
          OAIC=AIC

          AAIC(0)=AIC

          CALL NLTIV(SFL,RIN,SFDT,IP)
!C     SFL IS FACTORED INTO L'*L AND L IS RETURNED IN SFL
          INX=1

          DO 9 II=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED             
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
               DO 8 JJ=1,II
                    AST1(1,JJ,II)=CST0
!cxx    8 AST1(1,II,JJ)=SFL(II,JJ)
                    AST1(1,II,JJ)=SFL(II,JJ)
             8 CONTINUE
        9 CONTINUE
!C     ITERATION M=1 TO L
          DO 400 M=1,L
!C     INVERSE OF SD, SF COMPUTATION

             CALL INVDET(XSD,SDDET,IP,IP)

             CALL INVDET(XSF,SFDET,IP,IP)
!C     D, E, SD, SF COMPUTATION

             CALL MULPLY(SE,XSF,D,IP,IP,IP)

             CALL TRAMDL(SE,XSD,E,IP,IP,IP)

             CALL TRAMDR(D,SE,Z1,IP,IP,IP)

             CALL SUBTAL(SD,Z1,IP,IP)

             CALL MULPLY(E,SE,Z1,IP,IP,IP)

             CALL SUBTAL(SF,Z1,IP,IP)
             MS=M

             DO 411 II=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED                
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                    DO 410 JJ=1,IP
                           XSD(II,JJ)=SD(II,JJ)
                           XSF(II,JJ)=SF(II,JJ)
                           SFL(II,JJ)=SF(II,JJ)
                   410 CONTINUE
        411 CONTINUE
!C     AIC COMPUTATION

            CALL SAIC (SD,N,IP,MS,AIC)

            AAIC(MS) = AIC
!cc      CALL NLTIV(SFL,RIN,SFDT,IP,MJ)
            CALL NLTIV(SFL,RIN,SFDT,IP)
!C     SFL IS FACTORED INTO L'*L AND L IS RETURNED IN SFL
!C     FORWARD AND BACKWARD PREDICTOR COMPUTATION

            CALL COEFAB(A1,B1,D,E,MS,L,IP)
            DO 14 I=1,M
                  IMI=M+1-I
!cxx      DO 15 II=1,IP
                  DO 155 II=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED                     
                     !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                         DO 15 JJ=1,IP
!cxx   15 B(II,JJ)=B1(IMI,II,JJ)
                               B(II,JJ)=B1(IMI,II,JJ)
                      15 CONTINUE
             155 CONTINUE

                 CALL BLMULP(SFL,B,Z1,IP,IP)
                 INX=INX+1

                 DO 166 II=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                    !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                        DO 16 JJ=1,IP
!cxx   16 AST1(INX,II,JJ)=-Z1(II,JJ)
                              AST1(INX,II,JJ)=-Z1(II,JJ)
                     16 CONTINUE
            166 CONTINUE
             14 CONTINUE
                INX=INX+1
!cxx      DO 17 II=1,IP
                DO 177 II=1,IP
!DIR$ VECTOR ALIGNED                    
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                           
                       DO 17 JJ=1,II
                             AST1(INX,JJ,II)=CST0
!cxx   17 AST1(INX,II,JJ)=SFL(II,JJ)
                             AST1(INX,II,JJ)=SFL(II,JJ)
                    17 CONTINUE
             177 CONTINUE
!C     MINIMUM AIC SEARCH
                 IF(OAIC.LE.AIC) GO TO 440
                 OAIC=AIC
                 IFPEC=M
!cxx      DO 560 II=1,IR
                 DO 563 II=1,IR
#if defined __ICC
!DIR$ VECTOR ALIGNED                    
                    !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                        DO 560 JJ=1,IR
!cxx  560 OSD(II,JJ)=SD(II,JJ)
                           OSD(II,JJ)=SD(II,JJ)
                    560 CONTINUE
             563 CONTINUE
                 DO 561 I=1,M
!cxx      DO 562 II=1,IR
                    DO 564 II=1,IR
#if defined __ICC
!DIR$ VECTOR ALIGNED                       
                       !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                               DO 562 JJ=1,IP
                                      AAO(I,II,JJ)=-A1(I,II,JJ)
!cxx  562 AO(I,II,JJ)=-A1(I,II,JJ)
                                      AO(I,II,JJ)=-A1(I,II,JJ)
                            562 CONTINUE
                    564 CONTINUE
             561 CONTINUE
             440 IF(M.EQ.L) GO TO 400
!C     SE COMPUTATION

                CALL NEWSE(A1,CV,SE,MS,L,IP,LCV1)
      400 CONTINUE
!C     MIN.AIC PRINT OUT

          IF(IFPEC.LE.0) GO TO 699

          DO 1611 I=1,M
                  DO 1612 II=1,IR
                     !cxx      DO 1612 JJ=1,IP
#if defined __ICC
!DIR$ VECTOR ALIGNED                     
                     !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                          DO 1613 JJ=1,IP
!cxx 1612 AO(I,II,JJ)=-AO(I,II,JJ)
                                  AO(I,II,JJ)=-AO(I,II,JJ)
                      1613 CONTINUE
             1612 CONTINUE
      1611 CONTINUE
  699 RETURN
    END SUBROUTINE
    

    SUBROUTINE SAIC (SD,N,K,MS,AIC)
      use omp_lib
      implicit none
!C     AIC COMPUTATION.
!C     SD: COVARIANCE MATRIX OF INNOVATION

          INTEGER(4) :: N, K, MS
          REAL(8), dimension(K,K)  :: SD
#if defined __ICC
          !DIR$ ASSUME_ALIGNED SD:64
#endif
          REAL(8) :: AIC
          ! Locals
          INTEGER(4) :: I,J
          REAL(8) ::  AN, SDRM, ARM2
          REAL(8), dimension(K,K) :: SD1 
          AN=N

          DO 10 I=1,K
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                DO 9 J=1,K
!cxx    9 SD1(I,J)=SD(I,J)
                    SD1(I,J)=SD(I,J)
              9 CONTINUE
       10 CONTINUE

          CALL SUBDETC(SD1,SDRM,K)
          ARM2=2*MS*K*K
          AIC=AN*DLOG(SDRM)+ARM2
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: SBRUGT
#endif
    SUBROUTINE SBRUGT(MO,ID,AST1,CV,RGT,MJ1,MJ,LMAX2,LCV1)
      use omp_lib
      implicit none
        
!C     THIS SUBROUTINE COMPUTES MATRIX R12*G'.
!C     INPUTS REQUIRED:
!C     ID: DIMENSION OF Y(I) =IR=IP
!C     MO: MAICE ORDER OF AR-MODEL
!C     CV(I,II,JJ): COVARIANCE MATRIX
!C     AST1(I,II,JJ): MATRIX G FOR ORTHO-NORMALIZATION OF THE PRESENT AND
!C     PAST VARIABLES. G IS A LOWER TRIANGULAR BLOCK MATRIX WITH THE
!C     STRUCTURE
!C                  +-                            -+
!C             G = I  L0	     0        0   ....  I
!C                  I -L1B11  L1       0  .....  I
!C                  I -L2B22 -L2B21 L2 ....  I
!C                  I   .        .        ..      	...  I
!C                  I   .        .        . .	..   I
!C                  I   .        .        .  .	.    I
!C                  I   .        .	   .   .       I
!C                  I   .        .	   .    .      I
!C                  I   .        .	   .     .     I
!C                  I   .        .	   .      .    I
!C                  +-			   -+
!C     WHERE BMI'S ARE THE COEFFICIENTS OF THE M-TH ORDER BACKWARD AUTO-
!!C     REGRESSION,
!C     Y(I-M)-BM1Y(I-M+1)-..-BMMY(I)=ZM(I-M)
!C     AND LM(LM)'=INVERSE OF SD(M),WHERE SD(M) IS THE COVARIANCE MATRIX
!C     RESIDUAL ZM(I).
!C     OUTPUT:
!C     RGT(I,J): MATRIX OF R12*G'

          INTEGER(kind=4) :: MO, ID, MJ1, MJ, LMAX2, LCV1
          REAL(kind=8), dimension(LMAX2,MJ,MJ) :: AST1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AST1:64
#endif
          REAL(kind=8), dimension(LCV1,ID,ID) :: CV
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CV:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1) :: RGT
#if defined __ICC
          !DIR$ ASSUME_ALIGNED RGT:64
#endif
          INTEGER(kind=4) :: MP1,IRG,I,IM1,INX,JNC,K,J,II,IB,JB,INC
          REAL(kind=8) ::   CST0, SUM
          REAL(kind=8), dimension(ID,ID) :: X, Y
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: X, Y
#endif

          CST0=0.0_8
          MP1=MO+1

          IRG=MJ1

          RGT(1:IRG,1:IRG)=CST0
          INC=0
          DO 10 I=1,MP1
                IM1=I-1
                INX=0
                JNC=0
                DO 11 J=1,MP1
                      DO 12 K=1,J
                            IB=IM1+K
                            JB=INX+K
                           DO 18 II=1,ID
                              !cxx      DO 18 JJ=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED                              
                              !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                              !$OMP SIMD
#endif
                                 DO 19 JJ=1,ID
                                       X(II,JJ)=CV(IB,II,JJ)
                                       Y(II,JJ)=AST1(JB,II,JJ)
                              19 CONTINUE
                         18 CONTINUE
                            MJ7=7
                            DO 15 II=1,ID
                                  DO 16 JJ=1,ID
                                     SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED                                     
                                     !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                                     !$OMP SIMD REDUCTION(+:SUM)
#endif
                                        DO 17 KK=1,ID
!cxx   17 SUM=SUM+X(II,KK)*Y(JJ,KK)
                                              SUM=SUM+X(II,KK)*Y(JJ,KK)
                                     17 CONTINUE
                                        IN=INC+II
                                        JN=JNC+JJ
                                        RGT(IN,JN)=RGT(IN,JN)+SUM
                                16 CONTINUE
                      15 CONTINUE
               12 CONTINUE
                  JNC=JNC+ID
                  INX=INX+J
            11 CONTINUE
               INC=INC+ID
       10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE SUBBMA(AO,B,NH,M1,ID,IQ,MJ1,MJ0)
      use omp_lib
      implicit none
         
!C     AR-FITTING
!C     B-MATRIX COMPUTATION
!C     (USE AR-COEFFICIENTS)
!C     M1 IS LESS THAN 47.


      INTEGER(kind=4), dimension(M1)     :: NH
#if defined __ICC
      !DIR$ ASSUME_ALIGNED NH:64
#endif
          INTEGER(kind=4) :: M1, ID, IQ, MJ1, MJ0
          REAL(kind=8), dimension(MJ0,ID,ID) :: AO
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AO:64
#endif
          REAL(kind=8), dimension(MJ1,ID)    :: B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED B:64
#endif
          ! Locals
          INTEGER(kind=4) ::  I,J,MQ1,II,IIM1,IJ,NHC
          REAL(kind=8)    ::  CST0, CST1
          REAL(kind=8), dimension(IQ,ID,ID) :: X 
          REAL(kind=8), dimension(ID,ID)    :: XX, AA, C 
          REAL(kind=8), dimension(100,ID)   :: W
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: X,XX,AA,C,W
#endif
          CST0=0.0_8
          CST1=1.0_8
          W(1:ID,1:ID)=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 10 I=1,ID

                W(I,I)=CST1
       10 CONTINUE
          IF(IQ.LE.1) GO TO 110
          MQ1=IQ-1
          DO 200 II=1,MQ1

             DO 211 I=1,ID
#if defined __ICC
 !DIR$ VECTOR ALIGNED               
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                
                        DO 210 J=1,ID
!cxx  210 X(II,I,J)=AO(II,I,J)
                              X(II,I,J)=AO(II,I,J)
                    210 CONTINUE
             211 CONTINUE
                 IF(II.LE.1) GO TO 201
                 IIM1=II-1
                 DO 220 JJ=1,IIM1
!cxx      DO 230 I=1,ID
                    DO 231 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED                       
                       !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
                              DO 230 J=1,ID
!cxx  230 AA(I,J)=AO(JJ,I,J)
                                    AA(I,J)=AO(JJ,I,J)
                          230 CONTINUE
                  231 CONTINUE
                      IJ=II-JJ
!cxx      DO 240 I=1,ID
                      DO 241 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                         
                            DO 240 J=1,ID
!cxx  240 XX(I,J)=X(IJ,I,J)
                                   XX(I,J)=X(IJ,I,J)
                        240 CONTINUE
                241 CONTINUE

                    CALL MULPLY(AA,XX,C,ID,ID,ID)

                    DO 251 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED                       
                       !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                       
                           DO 250 J=1,ID
!cxx  250 X(II,I,J)=X(II,I,J)+C(I,J)
                                  X(II,I,J)=X(II,I,J)+C(I,J)
                       250 CONTINUE
                  251 CONTINUE
          220 CONTINUE

          201 DO 261 I=1,ID
                  DO 260 J=1,ID
                        IC=ID+(II-1)*ID+I
!cxx  260 W(IC,J)=X(II,I,J)
                        W(IC,J)=X(II,I,J)
              260 CONTINUE
           261 CONTINUE
      200 CONTINUE
      110 DO 300 I=1,M1
                   NHC=NH(I)
                   DO 310 J=1,ID
!cxx  310 B(I,J)=W(NHC,J)
                          B(I,J)=W(NHC,J)
               310 CONTINUE
      300 CONTINUE
    END SUBROUTINE
    
#if defined __ICC     
    !DIR$ ATTRIBUTES INLINE :: VECMTX
#endif
    SUBROUTINE VECMTX(X,Z,NH,RGT,MM,NN,MJ1)
      use omp_lib
      implicit none
!C     Z=X*Y (X,Z: VECTORS, Y: SUBMATRIX)

          INTEGER(kind=4), dimension(MM) :: NH 
          INTEGER(kind=4) :: MM, NN, MJ1
          REAL(kind=8), dimension(MM) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(NN) ::Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1) :: RGT
#if defined __ICC
          !DIR$ ASSUME_ALIGNED RGT:64
#endif
          ! Locals
          INTEGER(kind=4) :: I,J
          REAL(kind=8) :: CST0, SUM

         CST0=0.0_dp
         DO 10 I=1,NN
            SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED            
            !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
            !$OMP SIMD REDUCTION(+:SUM)
#endif
               DO 11 J=1,MM
                     JJ=NH(J)
!cxx   11 SUM=SUM+X(J)*RGT(JJ,I)
!cxx   10 Z(I)=SUM
                     SUM=SUM+X(J)*RGT(JJ,I)
             11 CONTINUE
                Z(I)=SUM
       10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: BLUMLP
#endif
    SUBROUTINE BLMULP(X,Y,Z,MM,NN)
      use omp_lib
      implicit none
!C     COMMON SUBROUTINE
!C     Z=X*Y (X: LOWER TRIANGLE)

          INTEGER(kind=4) :: MM, NN
          REAL(kind=8), dimension(MM,MM) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(MM,NN) :: Y, Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Y:64,Z:64
#endif
          INTEGER(kind=4) :: I,J,K
          REAL(kind=8) :: CST0, SUM
          CST0=0.0_8
          DO 10 I=1,MM
                DO 11 J=1,NN
                   SUM=CST0
#if defined __ICC
!DIR$ VECTOR ALIGNED            
                   !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                   !$OMP SIMD REDUCTION(+:SUM)
#endif
                       DO 12 K=1,I
!cxx   12 SUM=SUM+X(I,K)*Y(K,J)
                             SUM=SUM+X(I,K)*Y(K,J)
                    12 CONTINUE
                       Z(I,J)=SUM
               11 CONTINUE
       10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: SUBDETC
#endif
    SUBROUTINE SUBDETC(X,XDETMI,MM)
      use omp_lib
      implicit none
!C     COMMON SUBROUTINE
!C     THIS SUBROUTINE COMPUTES THE DETERMINANT OF UPPER LEFT MM X MM
!C     OF X.  FOR GENERAL USE STATEMENTS 20-21 SHOULD BE RESTORED.
!C     X: ORIGINAL MATRIX
!C     XDETMI: DETERMINANT OF UPPER LEFT MM X MM OF X
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE

          INTEGER(kind=4) :: MM
          REAL(kind=8), dimension(MM,MM) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8) :: XDETMI
          ! Locals
          INTEGER(kind=4) :: MM1,I,J,I1,K
          REAL(kind=8) :: CST0, CST1, XC, XXC
          CST0=0.0_8
          CST1=1.0_8
          XDETMI=CST1
          IF(MM.EQ.1) GO TO 18
          MM1=MM-1
          DO 10 I=1,MM1

                 XDETMI=XDETMI*X(I,I)
                 XC=CST1/X(I,I)
                 I1=I+1
                 DO 15 J=I1,MM
                    XXC=X(J,I)*XC
#if defined __ICC
                    !DIR$ VECTOR ALIGNED
                    !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                    !$OMP SIMD
#endif
                       DO 16 K=I1,MM
!cxx   16 X(J,K)=X(J,K)-X(I,K)*XXC
                             X(J,K)=X(J,K)-X(I,K)*XXC
                   16 CONTINUE
             15 CONTINUE
       10 CONTINUE
       18 XDETMI=XDETMI*X(MM,MM)

    END SUBROUTINE
    
         

    SUBROUTINE AUSP(FC,P1,LAGH1,A,LA1)
        implicit none
!C     THIS SUBROUTINE COMPUTES SMOOTHED AUTO SPECTRUM.
!C     FC: OUTPUT OF FGERCO
!C     P1: SMOOTHED SPECTRUM
!C     LAGH1: DIMENSION OF FC AND P1
!C     A: SMOOTHING COEFFICIENTS
!C     LA1: DIMENSION OF A (LESS THAN 11)

          INTEGER(kind=4) :: LAGH1, LA1
          
          REAL(kind=8), dimension(LAGH1) :: FC, P1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED FC:64, P1:64
#endif
          REAL(kind=8), dimension(LA1)   :: A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          ! Locals
          INTEGER(kind=4) :: LA,LAGSHF
          REAL(kind=8), dimension(LAGH1+2*(LA1-1)) :: FC1
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: FC1
#endif
          LA=LA1-1
          LAGSHF=LAGH1+2*LA
!C     FC SHIFT-RIGHT BY LA FOR END CORRECTION
          CALL ECORCO(FC,LAGH1,FC1,LAGSHF,LA1)
!C       SMOOTHING
          CALL SMOSPE(FC1,LAGSHF,A,LA1,P1,LAGH1)
    END SUBROUTINE
    

    SUBROUTINE COEFAB(A1,B1,D,E,MS,L,K)
      use omp_lib
      implicit none
!C     AR-FITTING
!C     THIS SUBROUTINE COMPUTES FORWARD(A) AND BACKWARD(B) PREDICTOR
!C     COEFFICIENTS.

          INTEGER(kind=4) :: MS, L, K
          REAL(kind=8), dimension(L,K,K) :: A1, B1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A1:64,B1:64
#endif
          REAL(kind=8), dimension(K,K)   :: D, E
#if defined __ICC
          !DIR$ ASSUME_ALIGNED D:64,E:64
#endif
          ! Locals
          INTEGER(kind=4) :: MSM1,MMI,I,II,J,JJ
          REAL(kind=8), dimension(K,K) :: A, B, Z1, Z2
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: A,B,Z2,Z2
#endif
          IF(MS.EQ.1) GO TO 40
          MSM1=MS-1
          DO 10 I=1,MSM1
                MMI=MS-I
!cxx      DO 20 II=1,K
                DO 22 II=1,K
#if defined __ICC
!DIR$ VECTOR ALIGNED                   
                   !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                   !$OMP SIMD
#endif
                      DO 20 JJ=1,K
                            A(II,JJ)=A1(I,II,JJ)
!cxx   20 B(II,JJ)=B1(MMI,II,JJ)
                            B(II,JJ)=B1(MMI,II,JJ)
                   20 CONTINUE
             22 CONTINUE

                CALL MULPLY(D,B,Z1,K,K,K)
                CALL MULPLY(E,A,Z2,K,K,K)
                CALL SUBTAL(A,Z1,K,K)
                CALL SUBTAL(B,Z2,K,K)
!cxx      DO 21 II=1,K
                DO 23 II=1,K
                   DO 21 JJ=1,K
#if defined __ICC
!DIR$ VECTOR ALIGNED                   
                      !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                   !$OMP SIMD
#endif                      
                            A1(I,II,JJ)=A(II,JJ)
!cxx   21 B1(MMI,II,JJ)=B(II,JJ)
                            B1(MMI,II,JJ)=B(II,JJ)
                   21 CONTINUE
             23 CONTINUE
       10 CONTINUE
!cxx   40 DO 30 II=1,K
40     DO 31 II=1,K
#if defined __ICC                              
!DIR$ VECTOR ALIGNED                               
                               !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                   !$OMP SIMD
#endif                               
                DO 30 JJ=1,K
                      A1(MS,II,JJ)=D(II,JJ)
!cxx   30 B1(MS,II,JJ)=E(II,JJ)
                      B1(MS,II,JJ)=E(II,JJ)
             30 CONTINUE
       31 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE CORNOM(C,CN,LAGH1,CX0,CY0)
      use omp_lib
      implicit none
!C     NORMALIZATION OF COVARIANCE

          INTEGER(kind=4) :: LAGH1
          REAL(kind=8), dimension(LAGH1) :: C, CN
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64,CN:64
#endif
          REAL(kind=8) :: CX0, CY0
          ! Locals
          INTEGER(kind=4) :: I
          REAL(kind=8) :: CST1, DS
          CST1=1.0_8
          DS=CST1/DSQRT(CX0*CY0)
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#lif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 10 I=1,LAGH1
!cxx   10 CN(I)=C(I)*DS
                CN(I)=C(I)*DS
       10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE CROSCO(X,Y,N,C,LAGH1)
        
!C     THIS SUBROUTINE COMPUTES C(L)=COVARIANCE(X(S+L),Y(S))
!C     (L=0,1,...,LAGH1-1).

          INTEGER(kind=4) :: N, LAGH1
          REAL(kind=8), dimension(N)     :: X, Y
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64,Y:64
#endif
          REAL(kind=8), dimension(LAGH1) :: C
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64
#endif
          ! Locals
          INTEGER(kind=4) :: II,I,IL,J1,J
          REAL(kind=8)    :: AN, BN1, BN, CT0, T
          AN=N
          BN1=1.0_8
          BN=BN1/AN
          CT0=0.0_8
          DO 10 II=1,LAGH1
                I=II-1
                T=CT0
                IL=N-I
#if defined __ICC
                      !DIR$ VECTOR ALIGNED
                !DIR$ SIMD REDUCTION(+:T)
#elif defined __GFORTRAN__
                !$OMP SIMD REDUCTION(+:T)
#endif
                DO 20 J=1,IL
                      J1=J+I
                      !cxx   20 T=T+X(J1)*Y(J)

                      T=T+X(J1)*Y(J)
             20 CONTINUE
!cxx   10 C(II)=T*BN
                C(II)=T*BN
       10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTE INLINE :: DMEADL
#endif
    SUBROUTINE DMEADL(X,N,XMEAN)
         
          INTEGER(kind=4) :: N
          REAL(kind=8), dimension(N) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8) :: XMEAN 
          ! Locals
          INTEGER(kind=4) :: I
          REAL(kind=8) :: AN, DSUMF

          AN=N
          XMEAN=DSUMF(X,N)/AN
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 10 I=1,N
!cxx   10 X(I)=X(I)-XMEAN
                X(I)=X(I)-XMEAN
       10 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE ECORCO(FC,LAGH1,FC1,LAGSHF,LA1)
       implicit none
!C     FC SHIFT-RIGHT BY LA FOR REAL PART END CORRECTION

          INTEGER(kind=4) :: LAGH1, LAGSHF, LA1
          REAL(kind=8), dimension(LAGH1) :: FC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED FC:64
#endif
          REAL(kind=8), dimension(LAGSHF) :: FC1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED FC1:64
#endif
          ! Locals
          INTEGER(kind=4) :: LAGH2,LA,I,I1,I2,LA2,I3,I4
          LAGH2=LAGH1+1
          LA=LA1-1
          DO 100 I=1,LAGH1
                 I1=LAGH2-I
                 I2=I1+LA
!cxx  100 FC1(I2)=FC(I1)
                 FC1(I2)=FC(I1)
      100 CONTINUE
          LA2=LAGH1+LA
          DO 110 I=1,LA
                 I1=LA1-I
                 I2=LA1+I
                 I3=LA2-I
                 I4=LA2+I
                 FC1(I1)=FC1(I2)
!cxx  110 FC1(I4)=FC1(I3)
                 FC1(I4)=FC1(I3)
      110 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE FGER1(G,GR,GI,LG,H,JJF)
        implicit none
!C     FOURIER TRANSFORM(GOERTZEL METHOD)
!C     THIS SUBROUTINE COMPUTES ONE VALUE OF THE FOURIER TRANSFORM BY
!C     GOERTZEL METHOD.

          INTEGER(kind=4) :: LG, H, JJF
          REAL(kind=8), dimension(LG+1) :: G
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64
#endif
          REAL(kind=8) :: GR, GI
          ! Locals
          INTEGER(kind=4) :: LGP1,LG3,LG4,I2,I
          REAL(kind=8 ) :: CST0, T, PI, AH, AK, TK, CK, SK, CK2, UM2, UM1, UM0
          CST0=0.0_8
          LGP1=LG+1
!C     REVERSAL OF G(I),I=1,...,LGP1 INTO G(LG3-I)   LG3=LGP1+1
          IF(LGP1.LE.1) GO TO 110
          LG3=LGP1+1
          LG4=LG3/2
          DO 100 I=1,LG4
                 I2=LG3-I
                 T=G(I)
                 G(I)=G(I2)
!cxx  100 G(I2)=T
                 G(I2)=T
      100 CONTINUE
      110 PI=3.1415926535897932384626433_8
          AH=H
          T=PI/AH
          AK=JJF-1
          TK=T*AK
          CK=DCOS(TK)
          SK=DSIN(TK)
          CK2=CK+CK
          UM2=CST0
          UM1=CST0
          IF(LG.EQ.0) GO TO 12
          DO 11 I=1,LG
                UM0=CK2*UM1-UM2+G(I)
                UM2=UM1
!cxx   11 UM1=UM0
                UM1=UM0
       11 CONTINUE
       12 GR=CK*UM1-UM2+G(LGP1)
          GI=-SK*UM1
    END SUBROUTINE
    
    SUBROUTINE FGERCO(G,LGP1,FC,LF1)
        implicit none
!C     FOURIER TRANSFORM (GOERTZEL METHOD)
!C     THIS SUBROUTINE COMPUTES FOURIER TRANSFORM OF G(I),I=0,1,...,LG AT
!C     FREQUENCIES K/(2*LF),K=0,1,...,LF AND RETURNS COSIN TRANSFORM IN
!C     FC(K).

          INTEGER(kind=4) :: LGP1, LF1
          REAL(kind=8), dimension(LGP1) :: G
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64
#endif
          REAL(kind=8), dimension(LF1)  :: FC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED FC:64
#endif
          ! Locals
          INTEGER(kind=4) :: LG,LG3,LG4,I,I2,K,
          REAL(kind=8) :: T, PI, ALF, AK, TK, CK, CK2, UM2, UM1, UM0
          LG=LGP1-1
          LF=LF1-1
!C     REVERSAL OF G(I),I=1,...,LGP1 INTO G(LG3-I)   LG3=LGP1+1
          IF(LGP1.LE.1) GO TO 110
          LG3=LGP1+1
          LG4=LGP1/2
          DO 100 I=1,LG4
                 I2=LG3-I
                 T=G(I)
                 G(I)=G(I2)
!cxx  100 G(I2)=T
                 G(I2)=T
      100 CONTINUE
      110 PI=3.1415926535897932384626433_8
          ALF=LF
          T=PI/ALF
          DO 10 K=1,LF1
                AK=K-1
                TK=T*AK
                CK=DCOS(TK)
                CK2=CK+CK
                UM2=0.0_8
                UM1=0.0_8
                IF(LG.EQ.0) GO TO 12
                DO 11 I=1,LG
                      UM0=CK2*UM1-UM2+G(I)
                      UM2=UM1
!cxx   11 UM1=UM0
                      UM1=UM0
            11 CONTINUE
            12 FC(K)=CK*UM1-UM2+G(LGP1)
       10 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE INVDET(X,XDET,MM,MJ)
      use omp_lib
      implicit none
        
!C                                                                       
!C       THE INVERSE AND DETERMINANT OF X COMPUTATION                    
!C                                                                       
!C       INPUTS:                                                         
!C          X:     MM*MM SQUARE MATRIX                                   
!C          MM:    DIMENSION OF X                                        
!C          MJ:    ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM           
!C                                                                       
!C       OUTPUTS:                                                        
!C          X:     INVERSE OF X                                          
!C          XDET:  DETERMINANT OF X                                      
!C                                                                       

          INTEGER(kind=4) :: MM, MJ
          REAL(kind=8), dimension(MJ,MJ) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8) :: XDET
          ! Locals
          INTEGER(kind=4) :: L,I,MAXI,J,MM1
          REAL(kind=8)    :: XMAXP, XC
          INTEGER(kind=4), dimension(MM) :: IDS
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: IDS          
#endif
          XDET = 1.0_8                                                  
          DO 10 L=1,MM                                                      
!C     PIVOTING AT L-TH STAGE                                            
                XMAXP=0.10000E-10_8                                             
                MAXI=0                                                            
                DO 110 I=L,MM                                                     
!cxx    1 IF( DABS(XMAXP) .GE. DABS(X(I,L)) )     GO TO 110                 
                       IF( DABS(XMAXP) .GE. DABS(X(I,L)) )     GO TO 110                 
                       XMAXP=X(I,L)                                                      
                       MAXI=I                                                            
            110 CONTINUE                                                          
                IDS(L)=MAXI                                                       
                IF(MAXI.EQ.L) GO TO 120                                           
                IF(MAXI.GT.0) GO TO 121                                           
                XDET = 0.0_8                                                   
                GO TO 140                                                         
                !C     ROW INTERCHANGE
#if defined __ICC
!DIR$ VECTOR ALIGNED                
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
            121 DO 14 J=1,MM                                                      
                      XC=X(MAXI,J)                                                      
                      X(MAXI,J)=X(L,J)                                                  
!cxx   14 X(L,J)=XC
                      X(L,J)=XC
             14 CONTINUE
                XDET=-XDET                                                        
            120 XDET=XDET*XMAXP                                                   
                XC = 1.0_8 / XMAXP                                               
                X(L,L)=1.0_8                                                  
                DO 11 J=1,MM                                                      
!cxx   11 X(L,J)=X(L,J)*XC
                      X(L,J)=X(L,J)*XC
             11 CONTINUE
                DO 12 I=1,MM                                                      
                      IF(I.EQ.L) GO TO 12                                               
                      XC=X(I,L)                                                         
                      X(I,L) = 0.0_8
#if defined __ICC
!DIR$ VECTOR ALIGNED                      
                      !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif                      
                      DO 13 J=1,MM                                                      
!cxx   13 X(I,J)=X(I,J)-XC*X(L,J)                                           
                            X(I,J)=X(I,J)-XC*X(L,J)
                   13 CONTINUE
             12 CONTINUE                                                          
       10 CONTINUE                                                          
          IF(MM.GT.1) GO TO 123                                             
          GO TO 140                                                         
!C     COLUMN INTERCHANGE                                                
      123 MM1=MM-1                                                          
          DO 130 J=1,MM1                                                    
                 MMJ=MM-J                                                          
                 JJ=IDS(MMJ)                                                       
                 IF(JJ.EQ.MMJ) GO TO 130
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif                 
                 DO 131 I=1,MM                                                     
                        XC=X(I,JJ)                                                        
                        X(I,JJ)=X(I,MMJ)                                                  
!cxx  131 X(I,MMJ)=XC
                        X(I,MMJ)=XC
             131 CONTINUE
      130 CONTINUE                                                          
      140 RETURN                                                            
    END SUBROUTINE
    
    SUBROUTINE INVDETC(X,XDET,MM)
         
!C     THIS SUBROUTINE COMPUTES THE INVERSE AND DETERMINANT OF
!C     UPPER LEFT MM X MM OF COMPLEX MATRIX X.
!C     X: ORIGINAL MATRIX
!C     MM: DIMENSION OF UPPER LEFT OF X (SHOULD BE LESS THAN 11)
!C     XDET: DETERMINANT OF UPPER LEFT MM X MM OF X
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     THE INVERSE MATRIX IS OVERWRITTEN ON THE ORIGINAL.

          INTEGER(kind=int4) :: MM
          COMPLEX(kind=dp), dimension(MM,MM) :: X
          !DIR$ ASSUME_ALIGNED X:64
          COMPLEX(kind=dp) :: XDET
          ! Locals
          INTEGER(kind=int4) :: L,MAXI,J,I,MM1,MMJ,JJ
          REAL(kind=dp)    :: CST0, CST1
          COMPLEX(kind=dp) :: XMAXP, XC
          INTEGER(kind=int4), dimension(MM)  :: IDS
!DIR$ ATTRIBUTES ALIGN : 64 :: IDS      
          CST0=0.0_dp
          CST1=1.0_dp
          XDET=CST1
          DO 10 L=1,MM
!C     PIVOTING AT L-TH STAGE
                XMAXP=0.10000E-10_dp
                MAXI=0
                DO 110 I=L,MM
                       IF(CDABS(XMAXP).GE.CDABS(X(I,L))) GO TO 110
                       XMAXP=X(I,L)
                       MAXI=I
            110 CONTINUE
                IDS(L)=MAXI
                IF(MAXI.EQ.L) GO TO 120
                IF(MAXI.GT.0) GO TO 121
                XDET=CST0
                GO TO 140
!C     ROW INTERCHANGE
            121 DO 14 J=1,MM
                      XC=X(MAXI,J)
                      X(MAXI,J)=X(L,J)
!cxx   14 X(L,J)=XC
                      X(L,J)=XC
             14 CONTINUE
                XDET=-XDET
            120 XDET=XDET*XMAXP
                XC=CST1/XMAXP
                X(L,L)=CST1
                DO 11 J=1,MM
!c!xx   11 X(L,J)=X(L,J)*XC
                      X(L,J)=X(L,J)*XC
             11 CONTINUE
                DO 12 I=1,MM
                      IF(I.EQ.L) GO TO 12
                      XC=X(I,L)
                      X(I,L)=CST0
                      DO 13 J=1,MM
!cxx   13 X(I,J)=X(I,J)-XC*X(L,J)
                            X(I,J)=X(I,J)-XC*X(L,J)
                   13 CONTINUE
            12 CONTINUE
       10 CONTINUE
          IF(MM.GT.1) GO TO 123
          GO TO 140
!C     COLUMN INTERCHANGE
      123 MM1=MM-1
          DO 130 J=1,MM1
                 MMJ=MM-J
                 JJ=IDS(MMJ)
                 IF(JJ.EQ.MMJ) GO TO 130
                 DO 131 I=1,MM
                        XC=X(I,JJ)
                        X(I,JJ)=X(I,MMJ)
!cxx  131 X(I,MMJ)=XC
                        X(I,MMJ)=XC
              131 CONTINUE
      130 CONTINUE
  140 RETURN
    END SUBROUTINE
    
                                      
    SUBROUTINE LTINV(R,K)
!C     COMMON SUBROUTINE                                                 
!C     THIS SUBROUTINE FACTORIZES (R(I,J): I,J=1,K) INTO R=L*L',         
!C     WITH L LOWER TRIANGLE, AND GIVES L' ON AND ABOVE THE DIAGONAL OF R
!C     MJ: ABSOLUTE DIMENSION OF R IN THE MAIN ROUTINE                   

          INTEGER(kind=int4) :: K
          REAL(kind=dp), dimension(K,K) :: R
          !DIR$ ASSUME_ALIGNED R:64
          ! Locals
          INTEGER(kind=dp) :: L,I,L1,M
          REAL(kind=dp)    :: CST1, RPIVOT, RIL
          CST1=1.0_dp                                                    
          DO 10 L=1,K                                                       
                RPIVOT=CST1/DSQRT(R(L,L))                                         
                R(L,L)=CST1/RPIVOT                                                
                DO 12 I=1,K                                                       
                      IF(I.EQ.L) GO TO 12                                               
                      R(L,I)=RPIVOT*R(L,I)                                              
             12 CONTINUE                                                          
                IF(L.EQ.K) GO TO 11                                               
                L1=L+1                                                            
                DO 13 I=L1,K                                                      
                      RIL=-RPIVOT*R(I,L)                                                
                      R(I,L)=RIL*RPIVOT                                                 
                      DO 14 M=1,K                                                       
                           IF(M.EQ.L) GO TO 14                                               
                           R(I,M)=R(I,M)+RIL*R(L,M)                                          
                   14 CONTINUE                                                          
            13 CONTINUE                                                          
       10 CONTINUE                                                          
   11 RETURN                                                            
    END  SUBROUTINE
    
    !DIR$ ATTRIBUTES INLINE :: LTRVEC                     
    SUBROUTINE LTRVEC(X,Y,Z,MM,NN)
        
!C     Z=X*Y                                                             
!C     (VECTOR Z)=(LOWER TRIANGLE OF UPPER LEFT MM X NN OF X)*(VECTOR Y) 
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE            

          INTEGER(kind=int4) :: MM, NN
          REAL(kind=dp), dimension(MM,NN) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(NN)    :: Y
          !DIR$ ASSUME_ALIGNED Y:64
          REAL(kind=dp), dimension(MM)    :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          ! Locals
          INTEGER(kind=int4) :: I,J
          REAL(kind=dp)    :: CST0, SUM
          CST0=0.0_dp                                                    
          DO 10 I=1,MM                                                      
             SUM=CST0
!DIR$ VECTOR ALIGNED             
!DIR$ SIMD REDUCTION(+:SUM)
                DO 11 J=1,I                                                       
!cxx   11 SUM=SUM+X(I,J)*Y(J)
                      SUM=SUM+X(I,J)*Y(J)
             11 CONTINUE
!cxx   10 Z(I)=SUM                                                          
               Z(I)=SUM
       10 CONTINUE
    END SUBROUTINE
    
    !DIR$ ATTRIBUTES INLINE :: MATADL
    SUBROUTINE MATADL(X,Y,MM,NN)
         
!C     MATRIX ADDITION
!C     X=X+Y
!C     (UPPER LEFT MM X NN OF X)=(UPPER LEFT MM X NN OF X)+(UPPER LEFT
!C     MM X NN OF Y).
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X AND Y IN THE MAIN ROUTINE

          INTEGER(kind=int4) :: MM, NN
          REAL(kind=dp), dimension(MM,NN) :: X, Y
          !DIR$ ASSUME_ALIGNED X:64,Y:64
          ! Locals
          INTEGER(kind=int4) :: I,J
          DO 11 I=1,MM
!DIR$ VECTOR ALIGNED             
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 10 J=1,NN
!cxx   10 X(I,J)=X(I,J)+Y(I,J)
                      X(I,J)=X(I,J)+Y(I,J)
             10 CONTINUE
       11 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE MIXRAD(Z,N,N2P,ISG)
         
!C     COMMON SUBROUTINE
!C     MIXED RADIX FAST FOURIER TRANSFORM
!C     ISG=-1...FOURIER TRANSFORM
!C     ISG=1...INVERSE FOURIER TRANSFORM

          INTEGER(kind=int4) :: N, N2P, ISG
          COMPLEX(kind=dp), dimension(N) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          ! Locals
          INTEGER(kind=int4) :: I,N3,M,L,M4,LM4,J,JM1,J1,J2,J3,J4,N5,I1,JF,  &
                           NM1,LL,ISG
          REAL(kind=dp) :: CST0, CST1, AN, PI, PI2, SG, AM4, AM5, AJM1, ARG, &
                        C1, S1, C2, S2, C3, S3
          COMPLEX(kind=dp) :: ZCI, ZW1, ZW2, ZW3, ZC1, ZC2, ZC3, ZC4, ZC
          INTEGER(kind=int4), dimension(N2P) :: MS
          !DIR$ ATTRIBUTES ALIGN : 64 :: MS
          CST0=0.0_dp
          CST1=1.0_dp
          AN=N
          PI=3.1415926536_dp
          PI2=PI+PI
          SG=ISG
          ZCI=SG*DCMPLX(CST0,CST1)
          DO 10 I=1,N2P
!cxx   10 MS(I)=2**(N2P-I)
                  MS(I)=2**(N2P-I)
       10 CONTINUE
          N3=N2P/2
          M=N
          DO 11 L=1,N3
                M=M/4
                M4=M*4
                LM4=N-M4+1
                AM4=M4
                AM5=SG*PI2/AM4
                DO 12 J=1,M
                      JM1=J-1
                      AJM1=JM1
                      ARG=AJM1*AM5
                      C1=DCOS(ARG)
                      S1=DSIN(ARG)
                      C2=C1*C1-S1*S1
                      S2=C1*S1+C1*S1
                      C3=C1*C2-S1*S2
                      S3=C1*S2+C2*S1
                      ZW1=DCMPLX(C1,S1)
                      ZW2=DCMPLX(C2,S2)
                      ZW3=DCMPLX(C3,S3)
                      DO 13 I=1,LM4,M4
                              J1=I+JM1
                              J2=J1+M
                              J3=J2+M
                              J4=J3+M
                              ZC1=Z(J1)+Z(J3)
                              ZC2=Z(J1)-Z(J3)
                              ZC3=Z(J2)+Z(J4)
                              ZC4=Z(J2)-Z(J4)
                              Z(J1)=ZC1+ZC3
                              Z(J2)=(ZC1-ZC3)*ZW2
                              ZC4=ZCI*ZC4
                              Z(J3)=(ZC2+ZC4)*ZW1
                              Z(J4)=(ZC2-ZC4)*ZW3
                   13 CONTINUE
             12 CONTINUE
       11 CONTINUE
          N5=N2P-2*N3
          IF(N5.NE.1) GO TO 120
          NM1=N-1
          DO 110 I=1,NM1,2
                 I1=I+1
                 ZC=Z(I)+Z(I1)
                 Z(I1)=Z(I)-Z(I1)
                 Z(I)=ZC
      110 CONTINUE
!C     UNSCRAMBLING
      120 JF=0
          DO 16 I=1,N
                IF(JF.LT.I) GO TO 17
                ZC=Z(I)
                Z(I)=Z(JF+1)
                Z(JF+1)=ZC
             17 DO 18 L=1,N2P
                      LL=L
                      IF(JF.LT.MS(L)) GO TO 19
!cxx   18 JF=JF-MS(L)
                      JF=JF-MS(L)
             18 CONTINUE
                LL=N2P
             19 JF=JF+MS(LL)
       16 CONTINUE
          IF(ISG.LT.0) GO TO 30
          DO 20 I=1,N
!cxx   20 Z(I)=Z(I)/AN
                Z(I)=Z(I)/AN
       20 CONTINUE
       30 RETURN
    END   SUBROUTINE
    
    !DIR$ ATTIRBUTES INLINE :: MULPLY
    SUBROUTINE MULPLY(X,Y,Z,MM,NN,NC)
          
!C     MATRIX MULTIPLICATION
!C     Z=X*Y
!C     (UPPER LEFT MM X NC OF Z)=(UPPER LEFT MM X NN OF X)*(UPPER LEFT
!C     NN X NC OF Y).
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     (MJ2,MJ3): ABSOLUTE DIMENSION OF Y IN THE MAIN ROUTINE
!C     (MJ1,MJ3): ABSOLUTE DIMENSION OF Z IN THE MAIN ROUTINE

          INTEGER(kind=int4) :: MM, NN, NC
          REAL(kind=dp), dimension(MM,NN) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(NN,NC) :: Y
          !DIR$ ASSUME_ALIGNED Y:64
          REAL(kind=dp), dimension(MM,NC) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          ! Locals
          INTEGER(kind=int4) :: I,J,K
          REAL(kind=dp) :: CST0, SUM
          CST0=0.0_dp
          DO 10 I=1,MM
                DO 11 J=1,NC
                   SUM=CST0
!DIR$ VECTOR ALIGNED                   
!DIR$ SIMD REDUCTION(+:SUM)
                      DO 12 K=1,NN
!cxx   12 SUM=SUM+X(I,K)*Y(K,J)
                           SUM=SUM+X(I,K)*Y(K,J)
                  12 CONTINUE
                     Z(I,J)=SUM
             11 CONTINUE
       10 CONTINUE
    END SUBROUTINE
    
    !DIR$ ATTRIBUTES INLINE :: MULVER                    
    SUBROUTINE MULVER(X,Y,Z,MM,NN)
         
!C     COMMON SUBROUTINE                                                 
!C     Z=X*Y (X: MATRIX  Y,Z: VECTORS)                                   
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE            

          INTEGER(kind=int4) :: MM, NN
          REAL(kind=dp), dimension(MM,NN) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(NN)    :: Y
          !DIR$ ASSUME_ALIGNED Y:64
          REAL(kind=dp), dimension(MM)    :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          ! Locals
          INTEGER(kind=int4) :: I,J
          REAL(kind=dp) :: CST0, SUM
          CST0=0.0_dp                                                     
          DO 10 I=1,MM                                                      
             SUM=CST0
!DIR$ VECTOR ALIGNED             
!DIR$ SIMD REDUCTION(+:SUM)                
                DO 11 J=1,NN                                                      
!cxx   11 SUM=SUM+X(I,J)*Y(J)                                               
                     SUM=SUM+X(I,J)*Y(J)
             11 CONTINUE
!cxx       10 Z(I)=SUM                                                          
                Z(I)=SUM
       10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE NEWSE(A1,CV,SE,MS,L,K,LCV1)
         
!C     SE COMPUTATION

          INTEGER(kind=int4) :: MS, L, K, LCV1
          REAL(kind=dp), dimension(L,K,K)    :: A1
          !DIR$ ASSUME_ALIGNED A1:64
          REAL(kind=dp), dimension(LCV1,K,K) :: CV
          !DIR$ ASSUME_ALIGNED CV:64
          REAL(kind=dp), dimension(K,K)      :: SE
          !DIR$ ASSUME_ALIGNED SE:64
          ! Locals
          INTEGER(kind=int4) :: MMI,I,II,JJ,MSP2
          REAL(kind=dp)    ::    CST0
          REAL(kind=dp), dimension(K,K) :: A, R, Z
!DIR$     ATTRIBUTES ALIGN : 64 :: A,R,Z
          CST0=0.0_dp

          Z(1:K,1:K)=CST0

          MSP2=MS+2
          DO 11 I=1,MS
                MMI=MSP2-I
                DO 12 II=1,K
                   !cxx      DO 12 JJ=1,K
!DIR$ VECTOR ALIGNED                   
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                      DO 13 JJ=1,K
                            A(II,JJ)=A1(I,II,JJ)
!cxx   12 R(II,JJ)=CV(MMI,II,JJ)
                            R(II,JJ)=CV(MMI,II,JJ)
                  13 CONTINUE
            12 CONTINUE

               CALL MULPLY(A,R,SE,K,K,K)

               CALL MATADL(Z,SE,K,K)
       11 CONTINUE
!C
          DO 14 II=1,K
!cxx      DO 14 JJ=1,K
                DO 15 JJ=1,K
!cxx   14 R(II,JJ)=CV(MSP2,II,JJ)
                      R(II,JJ)=CV(MSP2,II,JJ)
             15 CONTINUE
       14 CONTINUE
!cc	CALL SUBTAC(R,Z,SE,K,K,MJ,MJ)
          CALL SUBTAC(R,Z,SE,K,K)
    END SUBROUTINE
    

    SUBROUTINE REARRA(X,INW,IP0,IP)
         
!C     SUBMATRIX REARRANGEMENT
!C     X: ORIGINAL MATRIX
!C     INW: INDICATOR OF ADOPTED ROWS
!C     IP0: DIMENSION OF ORIGINAL MATRIX, SHOULD BE LESS THAN 11
!C     IP: DIMENSION OF REARRANGED SUBMATRIX
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     THE REARRANGED SUBMATRIX IS OVERWRITTEN ON THE ORIGINAL.
!C     NEXT STATEMENT SHOULD BE REPLACED BY
!C     IMPLICIT COMPLEX*16(X)
!C     FOR COMPLEX VERSION.

          INTEGER(kind=int4), dimension(IP) :: INW 
          INTEGER(kind=int4) :: IP0, IP
          REAL(kind=dp), dimension(IP0,IP0) :: X
          !DIR$ ASSUME_ALIGNED X:64
          ! Locals
          INTEGER(kind=int4) :: I,I1,I2,JJ,II,ID
          REAL(kind=dp)    :: XC
          INTEGER(kind=int4), dimension(IP0) :: IOD
          !DIR$ ATTRIBUTES ALIGN : 64 :: IOD

          DO 300 I=1,IP0
!cxx  300 IOD(I)=I
                 IOD(I)=I
      300 CONTINUE
          DO 301 I=1,IP
                 I1=INW(I)
                 I2=IOD(I1)
                 IF(I.EQ.I2) GO TO 301
!C     ROW INTERCHANGE
                 DO 312 JJ=1,IP0
                        XC=X(I,JJ)
                        X(I,JJ)=X(I2,JJ)
!cxx  312 X(I2,JJ)=XC
                        X(I2,JJ)=XC
            312 CONTINUE
!C     COLUMN INTERCHANGE
                DO 314 II=1,IP0
                       XC=X(II,I)
                       X(II,I)=X(II,I2)
!cxx  314 X(II,I2)=XC
                       X(II,I2)=XC
           314 CONTINUE
               ID=IOD(I)
               IOD(I2)=ID
               IOD(ID)=I2
      301 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE REARRAC(X,INW,IP0,IP)
       
!C     SUBMATRIX REARRANGEMENT
!C     X: ORIGINAL MATRIX
!C     INW: INDICATOR OF ADOPTED ROWS
!C     IP0: DIMENSION OF ORIGINAL MATRIX, SHOULD BE LESS THAN 11
!C     IP: DIMENSION OF REARRANGED SUBMATRIX
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     THE REARRANGED SUBMATRIX IS OVERWRITTEN ON THE ORIGINAL.
!C     NEXT STATEMENT SHOULD BE REPLACED BY

          INTEGER(kind=int4), dimension(IP) :: INW 
          INTEGER(kind=int4) :: IP0, IP
          COMPLEX(kind=dp), dimension(IP0,IP0) :: X
          !DIR$ ASSUME_ALIGNED X:64
          ! Locals
          INTEGER(kind=int4) :: I,I1,I2,JJ,II,ID
          COMPLEX(kind=dp) :: XC
          INTEGER(kind=int4), dimension(IP0) :: IOD
!DIR$ ATTRIBUTES ALIGN : 64 :: IOD
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 300 I=1,IP0
!cxx  300 IOD(I)=I
                 IOD(I)=I
      300 CONTINUE
          DO 301 I=1,IP
                 I1=INW(I)
                 I2=IOD(I1)
                 IF(I.EQ.I2) GO TO 301
!C     ROW INTERCHANGE
                 DO 312 JJ=1,IP0
                        XC=X(I,JJ)
                        X(I,JJ)=X(I2,JJ)
!cxx  312 X(I2,JJ)=XC
                        X(I2,JJ)=XC
312              CONTINUE
!C     COLUMN INTERCHANGE
 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                
                 DO 314 II=1,IP0
                        XC=X(II,I)
                        X(II,I)=X(II,I2)
!cxx  314 X(II,I2)=XC
                        X(II,I2)=XC
             314 CONTINUE
                 ID=IOD(I)
                 IOD(I2)=ID
                 IOD(ID)=I2
      301 CONTINUE
    END SUBROUTINE

    !DIR$ ATTRIBUTES INLINE :: SIGNIF
    SUBROUTINE SIGNIF(P1,P2,P3,LAGH1,N)
        
!C     SIGNIFICANCE TEST
!C     P1: SPECTRUM SMOOTHED BY WINDOW W1
!C     P2: SPECTRUM SMOOTHED BY WINDOW W2
!C     P3: TEST STATISTICS
!C     LAGH1: DIMENSION OF PI (I=1,2,3)
!C     N: LENGTH OF THE ORIGINAL DATA

          INTEGER(kind=int4) :: LAGH1, N
          REAL(R64P), dimension(LAGH1) :: P1, P2, P3
          !DIR$ ASSUME_ALIGNED P1:64,P2:64,P3:64
          ! Locals
          INTEGER(I32P) :: LAGH,I
          REAL(R64P) :: H, AN, HAN, SD2, SD3, T
          LAGH=LAGH1-1
          H=LAGH
          AN=N
          HAN=H/AN
          SD2=0.43_dp*DSQRT(HAN)
          SD3=1.0_dp/SD2
!DIR$ VECTOR ALIGNED          
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 10 I=1,LAGH1
               T=P2(I)/P1(I)-1.0_dp
!cxx   10 P3(I)=DABS(T)*SD3
               P3(I)=DABS(T)*SD3
      10 CONTINUE
    END SUBROUTINE

    !DIR$ ATTRIBUTES INLINE :: SMOSPE
    SUBROUTINE SMOSPE(X,LAGSHF,A,LA1,Z,LAGH1)
         
!C     SPECTRUM SMOOTHING BY THE FORMULA
!C     Z(I)=A(0)X(I)+A(1)(X(I+1)+X(I-1))+...+A(LA)(X(I+LA)+X(I-LA))
!C     I=0,1,...,LAGH.
!C     ACTUAL X(I) IS SHIFTED TO THE RIGHT BY LA FOR END CORRECTION.

          INTEGER(kind=int4) :: LAGSHF, LA1, LAGH1
          REAL(kind=dp), dimension(LAGSHF) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(LA1)    :: A
          !DIR$ ASSUME_ALIGNED A:64
          REAL(kind=dp), dimension(LAGH1)  :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          INTEGER(kind=int4) :: I,LA,I0,J,J1,J2
          REAL(kind=dp) :: SUM1
          LA=LA1-1
          DO 10 I=1,LAGH1
                I0=I+LA
                SUM1=0.0_dp
!DIR$ VECTOR ALIGNED                
!DIR$ SIMD REDUCTION(+:SUM1)
                DO 11 J=1,LA
                   J1=I0-J
                   J2=I0+J
!cxx   11 SUM1=SUM1+A(J+1)*(X(J1)+X(J2))
                   SUM1=SUM1+A(J+1)*(X(J1)+X(J2))
            11 CONTINUE
!cxx   10 Z(I)=A(1)*X(I0)+SUM1
               Z(I)=A(1)*X(I0)+SUM1
       10 CONTINUE
    END SUBROUTINE
    
    

    SUBROUTINE SUBD12(N,LAGH,K,D1,D2)
        
!C     CONSTANTS D1,D2 COMPUTATION

          INTEGER(kind=int4) :: N, LAGH, K
          REAL(kind=dp)    :: D1, D2
          ! Locals
          INTEGER(kind=int4) :: L1,I,NF
          REAL(kind=dp) :: CST0, AN, H, SUM, FK, C1, C2
          REAL(kind=dp), dimension(4) :: A
          !DIR$ ATTRUBUTES ALIGN : 32 :: A
          CST0=0.0_dp
          L1=2
          A(1)=0.5_dp
          A(2)=0.25_dp
          AN=N
          H=LAGH
          SUM=0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)
          DO 20 I=2,L1
!cxx   20 SUM=SUM+A(I)**2
                SUM=SUM+A(I)**2
       20 CONTINUE
          SUM=SUM+SUM+A(1)**2
          SUM=SUM+SUM
!cxx      NF=AN/(H*SUM)+0.5D-00
          NF=INT(AN/(H*SUM)+0.5_dp)
          FK=NF-K
          IF(FK.EQ.CST0) GO TO 100
          C1=FK-1.40_dp
          IF(C1.EQ.CST0) GO TO 100
          D1=(3.84_dp+10.0_dp/C1)/FK
          IF(D1.LT.CST0) GO TO 100
          D1=DSQRT(D1)
          GO TO 110
      100 D1=100.0_dp
      110 C2=FK+FK-1.40_dp
          IF(C2.EQ.CST0) GO TO 120
          D2=(3.0_dp+10.0_dp/C2)/FK
          IF(D2.LT.CST0) GO TO 120
          D2=DSQRT(D2)
          GO TO 130
      120 D2=100.0_dp
      130 RETURN
    END  SUBROUTINE
    

    SUBROUTINE SUBDET(X,XDETMI,MM,MJ)                                 
!C                                                                       
!C       DETERMINANT OF X COMPUTATION                                    
!C                                                                       
!C     THIS SUBROUTINE COMPUTES THE DETERMINANT OF UPPER LEFT MM X MM    
!C     OF X.  FOR GENERAL USE STATEMENTS 20-21 SHOULD BE RESTORED.       
!C     X: ORIGINAL MATRIX                                                
!C     XDETMI: DETERMINANT OF UPPER LEFT MM X MM OF X                    
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE                   

          INTEGER(kind=int4) :: MM, MJ
          REAL(kind=dp), dimension(MJ,MJ) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp) :: XDETMI
          ! Locals
          INTEGER(kind=int4) :: MM1,I,J,JJ,K,I1
          REAL(kind=dp) :: XC, XXC
          XDETMI=1.0_dp                                                     
          IF(MM.EQ.1) GO TO 18                                              
          MM1=MM-1                                                          
          DO 10 I=1,MM1                                                     
!cxx   20 IF(X(I,I).NE.0.0D0) GO TO 11                                      
                IF(X(I,I).NE.0.0_dp) GO TO 11                                      
                DO 12 J=I,MM                                                      
                     IF(X(I,J).EQ.0.0_dp) GO TO 12                                      
                     JJ=J                                                              
                     GO TO 13                                                          
            12 CONTINUE                                                          
               XDETMI=0._dp                                                     
               GO TO 17                                                          
            13 DO 14 K=I,MM                                                      
                     XXC=X(K,JJ)                                                       
                     X(K,JJ)=X(K,I)                                                    
!cxx   14 X(K,I)=XXC
                     X(K,I)=XXC
            14 CONTINUE
!cxx   21 XDETMI=-XDETMI
               XDETMI=-XDETMI 
            11 XDETMI=XDETMI*X(I,I)                                              
               XC=1.0_R64P/X(I,I)                                                   
               I1=I+1                                                            
               DO 15 J=I1,MM                                                     
                  XXC=X(J,I)*XC
                  !DIR$ VECTOR ALIGNED
                  !DIR$ SIMD
                     DO 16 K=I1,MM                                                     
!cxx   16 X(J,K)=X(J,K)-X(I,K)*XXC
                           X(J,K)=X(J,K)-X(I,K)*XXC
                 16 CONTINUE
           15 CONTINUE                                                          
       10 CONTINUE                                                          
       18 XDETMI=XDETMI*X(MM,MM)                                            
       17 RETURN                                                            
    END  SUBROUTINE
    

    SUBROUTINE SUBNOS(X,SD,IP,RS,R,MJ)
         
!C     THIS SUBROUTINE COMPUTES RELATIVE POWER CONTRIBUTIONS.
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     IP: DIMENSION OF RS1 OR RL (LESS THAN 11)

          INTEGER(kind=int4) :: IP, MJ
          REAL(kind=dp), dimension(MJ,MJ) :: SD, RS, R
          !DIR$ ASSUME_ALIGNED SD:64
          !DIR$ ASSUME_ALIGNED RS:64
          !DIR$ ASSUME_ALIGNED R:64
          COMPLEX(kind=dp), dimension(MJ,MJ) :: X
          !DIR$ ASSUME_ALIGNED X:64
          INTEGER(kind=int4) ::  II,JJ,LL
          REAL(kind=dp)    ::  CST0, CST1, SUM, RX, RIX, RCONST
          REAL(kind=dp), dimension(MJ) :: RS1, RL
!DIR$ ATTRIBUTES ALIGN : 64 :: RS1,RL
          CST0=0.0_dp
          CST1=1.0_dp
          DO 10 II=1,IP
                SUM=CST0
                DO 11 JJ=1,IP
                      RX=DREAL(X(II,JJ))
                      RIX=DIMAG(X(II,JJ))
                      RS1(JJ)=(RX**2+RIX**2)*SD(JJ,JJ)
                      SUM=SUM+RS1(JJ)
!cxx   11 RL(JJ)=SUM
                      RL(JJ)=SUM
            11 CONTINUE
                      RCONST=CST1/RL(IP)
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
               DO 14 JJ=1,IP
!cxx   14 RS(II,JJ)=RS1(JJ)*RCONST
                    RS(II,JJ)=RS1(JJ)*RCONST
14                  CONTINUE
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))               
               DO 12 LL=1,IP
!cxx   12 R(II,LL)=RL(LL)*RCONST
                     R(II,LL)=RL(LL)*RCONST
            12 CONTINUE
       10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE SUBTAL(X,Y,MM,NN)
         
!C     COMMON SUBROUTINE
!C     MATRIX SUBTRACTION
!C     X=X-Y
!C     (UPPER LEFT MM X NN OF X)=(UPPER LEFT MM X NN OF X)-(UPPER LEFT
!C     MM X NN OF Y).
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X AND Y IN THE MAIN ROUTINE

          INTEGER(kind=int4) :: MM, NN
          REAL(kind=dp), dimension(MM,NN) :: X, Y
          !DIR$ ASSUME_ALIGNED X:64
          !DIR$ ASSUME_ALIGNED Y:64
          ! Locals
          INTEGER(kind=int4) :: I,J
!cxx      DO 10 I=1,MM
          DO 11 I=1,MM
             !DIR$ VECTOR ALIGNED
             !DIR$ SIMD
                DO 10 J=1,NN
!cxx   10 X(I,J)=X(I,J)-Y(I,J)
                      X(I,J)=X(I,J)-Y(I,J)
             10 CONTINUE
       11 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE TRAMDL(X,Y,Z,MM,NN,NC)
         
!C     TRANSPOSE MULTIPLY (LEFT)
!C     Z=X'*Y
!C     (UPPER LEFT NN X NC OF Z)=(UPPER LEFT MM X NN OF X)'*(UPPER LEFT
!C     MM X NC OF Y).
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     (MJ1,MJ3): ABSOLUTE DIMENSION OF Y IN THE MAIN ROUTINE
!C     (MJ2,MJ3): ABSOLUTE DIMENSION OF Z IN THE MAIN ROUTINE

          INTEGER(kind=int4) :: MM, NN, NC
          REAL(kind=dp), dimension(MM,NN) ::  X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(M,NC)  ::  Y
          !DIR$ ASSUME_ALIGNED Y:64
          REAL(kind=dp), dimension(NN,NC) ::  Z
          !DIR$ ASSUME_ALIGNED
          ! Locals
          INTEGER(kind=int4) :: I,J,K
          REAL(kind=dp) :: CST0, SUM
          CST0=0.0_dp
          DO 10 I=1,NN
             DO 11 J=1,NC
                SUM=CST0
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)
                    DO 12 K=1,MM
!cxx   12 SUM=SUM+X(K,I)*Y(K,J)
                         SUM=SUM+X(K,I)*Y(K,J)
                 12 CONTINUE
                    Z(I,J)=SUM
            11 CONTINUE
       10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE TRAMDR(X,Y,Z,MM,NN,NC)
         
!C     COMMON SUBROUTINE
!C     TRANSPOSE MULTIPLY (RIGHT)
!C     Z=X*Y'
!C     (UPPER LEFT MM X NC OF Z)=(UPPER LEFT MM X NN OF X)*(UPPER LEFT
!C     NC X NN OF Y)'.
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     (MJ3,MJ2): ABSOLUTE DIMENSION OF Y IN THE MAIN ROUTINE
!C     (MJ1,MJ3): ABSOLUTE DIMENSION OF Z IN THE MAIN ROUTINE

          INTEGER(kind=dp) :: MM, NN, NC
          REAL(kind=dp), dimension(MM,NN) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimesnion(NC,NN) :: Y
          !DIR$ ASSUME_ALIGNED Y:64
          REAL(kind=dp), dimension(MM,NC) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          ! Locals
          INTEGER(kind=int4) :: I,J,K
          REAL(kind=dp) :: CST0, SUM
          CST0=0.0_dp
          DO 10 I=1,MM
             DO 11 J=1,NC
                SUM=CST0
                !DIR$ VECTOR ALIGNED
                !DIR$ SIMD REDUCTION(+:SUM)
                    DO 12 K=1,NN
!cxx   12 SUM=SUM+X(I,K)*Y(J,K)
                         SUM=SUM+X(I,K)*Y(J,K)
                 12 CONTINUE
                    Z(I,J)=SUM
           11 CONTINUE
       10 CONTINUE
    END SUBROUTINE
    
    REAL(kind=dp) FUNCTION DSUMF(X,N)
         
          INTEGER(kind=int4) :: N
          REAL(kind=dp), dimension(N) :: X
          !DIR$ ASSUME_ALIGNED X:64
          ! Locls
          INTEGER(kind=int4) :: I
          
          DSUMF=0.0_dp
          !DIR$ VECTRO ALIGNED
          !DIR$ SIMD REDUCTION(+:DSUMF)
          DO 10 I=1,N
!cxx   10 DSUMF=DSUMF+X(I)
                DSUMF=DSUMF+X(I)
       10 CONTINUE
    END FUNCTION
    

   REAL(kind=dp) FUNCTION RANDM(K,K1,K2,K3,K4)
         
!C     RANDOM NUMBER GENERATOR
          INTEGER(kind=int4) :: K, K1, K2, K3, K4
          ! Locals
          INTEGER(kind=int4) :: MCST11,MC100,M1,M2,M3,M4,J
          REAL(kind=dp)    :: X1, X2
          MCST11=11
          MC100=100
!cc      IF(K) 1,2,1
          IF(K .LT. 0) GO TO 1
          IF(K .EQ. 0) GO TO 2
          IF(K .GT. 0) GO TO 1
!C     STARTING NUMBER FOR GENERATOR
        1 K1=53
          K2=95
          K3=27
          K4=04
!cc	WRITE(6,4) K1,K2,K3,K4
        2 M1=MCST11*K4
          M2=MCST11*K3
          M3=MCST11*K2+K4
          M4=MCST11*K1+K3
          J=M1/MC100
          K4=M1-MC100*J
          M2=M2+J
          J=M2/MC100
          K3=M2-MC100*J
          M3=M3+J
          J=M3/MC100
          K2=M3-MC100*J
          M4=M4+J
          J=M4/MC100
          K1=M4-MC100*J
          X1=K1
          X2=K2
!cc	RANDOM=X1*1.E-2+X2*1.E-4
!ccc      RANDM=X1*1.E-2+X2*1.E-4
          RANDM=X1*0.01_R64P+X2*0.001_dp
   END FUNCTION
   
   SUBROUTINE DINIT(A,N,DD)
         
          INTEGER(kind=int4) :: N
          REAL(kind=dp), dimension(N) :: A
          !DIR$ ASSUME_ALIGNED A:64
          REAL(kind=dp) :: DD
          ! Locals
          INTEGER(kind=int4) :: I
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          DO 100 I=1,N
                 A(I)=DD
      100 CONTINUE
   END SUBROUTINE
   
   SUBROUTINE INNERP(DD1,DD2,DINP12,INP)
         
!C     COMMON SUBROUTINE
!C     INNER-PRODUCT OF DD1 AND DD2.

          INTEGER(kind=int4) :: INP
          REAL(kind=dp), dimension(INP) :: DD1, DD2
          !DIR$ ASSUME_ALIGNED DD1:64,DD2:64
          REAL(kind=dp) :: DINP12
          ! Locals
          INTEGER(kind=int4) :: I
          REAL(kind=dp) :: CST0, SUM
          CST0=0.0_dp
          SUM=CST0
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:SUM)
          DO 100 I=1,INP
!cxx  100 SUM=SUM+DD1(I)*DD2(I)
                 SUM=SUM+DD1(I)*DD2(I)
      100 CONTINUE
          DINP12=SUM
   END SUBROUTINE
   

   SUBROUTINE MATINV(M,HS,NN)
        
!C      HS IS AN M*M MATRIX (IN COMMON AREA).
!C     HS-INVERSE IS RETURNED IN HS.
!C     DETERMINANT IS RETURNED IN DET.

      INTEGER(kind=int4) :: M, NN
      REAL(kind=dp), dimension(NN,NN) :: HS
      !DIR$ ASSUME_ALIGNED HS:64
      REAL(kind=dp) :: XDET

      CALL INVDET(HS,XDET,M,NN)
   END SUBROUTINE
   
      

   SUBROUTINE MSVD(U,V,Q,M,N,MJ2,MJ1)
         
!C     COMMON SUBROUTINE
!C     THIS SUBROUTINE COMPLETES THE SINGULAR VALUE
!C     DECOMPOSITION OF A REAL RECTANGULAR MATRIX A INTO THE FORM
!C     A=U*DIAG(Q)*V' WITH ORTHGONAL MATRICES U AND V.
!C     INPUTS:
!C     U: ORIGINAL MATRIX A
!C     M: NUMBER OF ROWS OF A, NOT LESS THAN N.
!C     N: NUMBER OF COLUMNS OF A, NOT GREATER THAN 104.
!C     OUTPUTS:
!C!     V: ORTHOGONAL MATRIX V
!C     Q: SINGULAR VALUES IN DECREASING ORDER

          INTEGER(kind=int4) :: M, N, MJ2, MJ1
          REAL(kind=dp), dimension(MJ2,MJ1) :: U
          !DIR$ ASSUME_ALIGNED U:64
          REAL(kind=dp), dimension(MJ1,MJ1) :: V
          !DIR$ ASSUME_ALIGNED V:64
          REAL(kind=dp), dimension(N)       :: Q
          !DIR$ ASSUME_ALIGNED Q:64
          ! Locals
          INTEGER(kind=int4) :: I,L,J,K,NP1,II,KK,KP1,LP1,NM1,IP1,
          REAL(kind=dp)    ::  EPS, TOL, CST0, CST1, CST2, C, F, G, FG, H,    &
                         S, T, X, Y, Z
          REAL(kind=dp), dimension(M)    :: E
!DIR$ ATTRIBUTES ALIGN : 64 :: E
!C     ESP: SMALL POSITIVE CONSTANT TO BE USED FOR THE DECISION OF CONVER
!C     TOL: (SMALLEST POSITIVE NUMBER REPRESENTABLE IN THE COMPUTER)/EPS
          EPS=1.0E-15_dp
          TOL=1.0E-60_dp
!C     HOUSEHOLDER'S REDUCTION TO BIDIAGONAL FORM
          CST0=0.0_dp
          CST1=1.0_dp
          CST2=2.0_dp
          G=CST0
          X=CST0
          DO 10 I=1,N
                E(I)=G
                S=CST0
                L=I+1
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S)
                DO 11 J=I,M
!cxx   11 S=S+U(J,I)**2
                   S=S+U(J,I)**2
             11 CONTINUE
                IF(S.GE.TOL) GO TO 12
                G=CST0
                GO TO 19
             12 F=U(I,I)
!cxx   13 IF(F.LT.CST0) GO TO 14
                IF(F.LT.CST0) GO TO 14
                G=-DSQRT(S)
                GO TO 15
             14 G=DSQRT(S)
             15 H=F*G-S
                U(I,I)=F-G
                IF(L.GT.N) GO TO 19
                DO 16 J=L,N
                   S=CST0
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S)                   
                   DO 17 K=I,M
!cxx   17 S=S+U(K,I)*U(K,J)
                         S=S+U(K,I)*U(K,J)
                17 CONTINUE
                   F=S/H
                   DO 18 K=I,M
!cxx   18 U(K,J)=U(K,J)+F*U(K,I)
                      U(K,J)=U(K,J)+F*U(K,I)
                18 CONTINUE
            16 CONTINUE
            19 Q(I)=G
               S=CST0
               IF(L.GT.N) GO TO 201
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S)               
               DO 20 J=L,N
!cxx   20 S=S+U(I,J)**2
                  S=S+U(I,J)**2
            20 CONTINUE
           201 IF(S.GE.TOL) GO TO 22
               G=CST0
               GO TO 30
            22 F=U(I,I+1)
!cxx   23 IF(F.LT.CST0) GO TO 24
               IF(F.LT.CST0) GO TO 24
               G=-DSQRT(S)
               GO TO 25
            24 G=DSQRT(S)
            25 H=F*G-S
               U(I,I+1)=F-G
               IF(L.GT.N) GO TO 30
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
               DO 26 J=L,N
!cxx   26 E(J)=U(I,J)/H
                   E(J)=U(I,J)/H
            26 CONTINUE
               DO 27 J=L,M
                  S=CST0
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S)                  
                  DO 28 K=L,N
!cxx   28 S=S+U(J,K)*U(I,K)
                     S=S+U(J,K)*U(I,K)
              28 CONTINUE
                 DO 29 K=L,N
!cc   29 U(J,K)=U(J,K)+S*E(K)
                    U(J,K)=U(J,K)+S*E(K)
              29 CONTINUE
              27 CONTINUE
               30 Y=DABS(Q(I))+DABS(E(I))
!C     X=MAX.Y
                IF(Y.GT.X) X=Y
       10 CONTINUE
          NP1=N+1
          L=N+1
!C     ACCUMULATION OF RIGHT-HAND TRANSFORMATIONS
          DO 110 II=1,N
             I=NP1-II
             IF(L.GT.N) GO TO 202
             IF(G.EQ.CST0) GO TO 115
             H=U(I,I+1)*G
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
             DO 111 J=L,N
!cxx  111 V(J,I)=U(I,J)/H
                V(J,I)=U(I,J)/H
         111 CONTINUE
             DO 112 J=L,N
                S=CST0
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S)                
                DO 113 K=L,N
!cxx  113 S=S+U(I,K)*V(K,J)
                   S=S+U(I,K)*V(K,J)
            113 CONTINUE
                DO 114 K=L,N
!cxx  114 V(K,J)=V(K,J)+S*V(K,I)
                   V(K,J)=V(K,J)+S*V(K,I)
            114 CONTINUE
            112 CONTINUE
            115 DO 116 J=L,N
                    V(I,J)=CST0
!cxx  116 V(J,I)=CST0
                    V(J,I)=CST0
            116 CONTINUE
            202 V(I,I)=CST1
                G=E(I)
                L=I
      110 CONTINUE
!C     DIAGONALIZATION OF THE BIDIAGONAL FORM
!cxx  129 EPS=EPS*X
          EPS=EPS*X
          DO 130 KK=1,N
             K=NP1-KK
             KP1=K+1
!C     TEST F SPLITTING
      145 DO 131 LL=1,K
             L=KP1-LL
             IF(DABS(E(L)).LE.EPS) GO TO 134
             IF(DABS(Q(L-1)).LE.EPS) GO TO 132
      131 CONTINUE
!C     CANCELLATION OF E(L) IF L>1.
      132 C=CST0
          S=CST1
          L1=L-1
          DO 133 I=L,K
              F=S*E(I)
              E(I)=C*E(I)
              IF(DABS(F).LE.EPS) GO TO 134
              G=Q(I)
              H=DSQRT(F*F+G*G)
              Q(I)=H
              C=G/H
              S=-F/H
      133 CONTINUE
!C     TEST F CONVERGENCE
      134 Z=Q(K)
          IF(L.EQ.K) GO TO 142
!C     SHIFT FROM BOTTOM 2X2 MINOR
          X=Q(L)
          Y=Q(K-1)
          G=E(K-1)
          H=E(K)
          F=((Y-Z)*(Y+Z)+(G-H)*(G+H))/(CST2*H*Y)
          T=F*F+CST1
          G=DSQRT(T)
          IF(F.GE.CST0) GO TO 135
          FG=F-G
          GO TO 136
      135 FG=F+G
      136 F=((X-Z)*(X+Z)+H*(Y/FG-H))/X
!C     QR TRANSFORMATION
!C     NEXT QR TRANSFORMATION
          C=CST1
          S=CST1
          LP1=L+1
          DO 137 I=LP1,K
             G=E(I)
             Y=Q(I)
             H=S*G
             G=C*G
             Z=DSQRT(F*F+H*H)
             E(I-1)=Z
             C=F/Z
             S=H/Z
             F=X*C+G*S
             G=-X*S+G*C
             H=Y*S
             Y=Y*C
             DO 138 J=1,N
                X=V(J,I-1)
                Z=V(J,I)
                V(J,I-1)=X*C+Z*S
!cxx  138 V(J,I)=-X*S+Z*C
                V(J,I)=-X*S+Z*C
         138 CONTINUE
!cxx  139 Z=DSQRT(F*F+H*H)
             Z=DSQRT(F*F+H*H)
             Q(I-1)=Z
             C=F/Z
             S=H/Z
             F=C*G+S*Y
             X=-S*G+C*Y
         137 CONTINUE
             E(L)=CST0
             E(K)=F
             Q(K)=X
             GO TO 145
!C     CONVERGENCE
         142 IF(Z.GE.CST0) GO TO 130
!C     Q(K) IS MADE NON-NEGATIVE.
             Q(K)=-Z
             DO 144 J=1,N
!cxx  144 V(J,K)=-V(J,K)
                V(J,K)=-V(J,K)
          144 CONTINUE
      130 CONTINUE
!C     Q AND V ARE ORDERED IN DECREASING ORDER OF THE SINGULAR VALUES.
          IF(N.LE.1) GO TO 340
          NM1=N-1
          DO 311 I=1,NM1
             IP1=I+1
             DO 312 J=IP1,N
                    IF(Q(I).GE.Q(J)) GO TO 312
                    T=Q(I)
                    Q(I)=Q(J)
                    Q(J)=T
                    DO 321 L=1,N
                       T=V(L,I)
                       V(L,I)=V(L,J)
                       V(L,J)=T
                321 CONTINUE
            312 CONTINUE
         311 CONTINUE
      340 RETURN
   END SUBROUTINE
   
#if defined __ICC
   !DIR$ ATTRIBUTES INLINE :: SUBTAC
#endif
   SUBROUTINE SUBTAC(X,Y,Z,MM,NN)
          use omp_lib
          implicit none
!C     COMMON SUBROUTINE
!C     MATRIX SUBTRACTION
!C     Z=X-Y
!C     (UPPER LEFT MM X NN OF Z)=(UPPER LEFT MM X NN OF X)-(UPPER LEFT
!C     MM X NN OF Y).
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X, Y AND Z IN THE MAIN ROUTINE

          INTEGER(4) :: MM, NN
          REAL(8), dimension(MM,NN) :: X , Y, Z

          ! Locals
          INTEGER(4) :: I,J
!cxx      DO 10 I=1,MM
          DO 20 I=1,MM
#if defined __ICC
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
             DO 10 J=1,NN
!cxx   10 Z(I,J)=X(I,J)-Y(I,J)
                Z(I,J)=X(I,J)-Y(I,J)
          10 CONTINUE
      20 CONTINUE
   END SUBROUTINE
   
                    
   SUBROUTINE  ADDVAR( X,IND,JND,K,L,M,MJ )  
         implicit none
!C                                                                       
!C         +-----------------------------------------------------------+ 
!C         ! ADDITION OF THE VARIABLE M AS THE JJ-TH REGRESSOR (JJ<=L) ! 
!C         +-----------------------------------------------------------+ 
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             HUSHL1                                                    
!C       ----------------------------------------------------------------
!C       INPUTS:                                                         
!C          X:            (K+1)*(K+1)  MATRIX                            
!C          D:            WORKING AREA                                   
!C          IND:          WORKING AREA                                   
!C          JND(I)=J:     PRESENT STATUS, I-TH REGRESSOR IS VARIABLE J.  
!C          K:            NUMBER OF VARIABLES                            
!C          L:            NUMBER OF REGRESSORS IN THE PRESENT MODEL      
!C          M:            INDICATION OF THE VARIABLE TO BE ADDED         
!C          MJ:           ABSOLUTE DIMENSION OF X                        
!C                                                                       
!C       OUTPUTS:                                                        
!C          X:            (K+1)*(K+1)  MATRIX                            
!C          JND(I)=J:     UPDATED STATUS, I-TH REGRESSOR IS VARIABLE J.  
!C                                                                       
                    
         INTEGER(kind=4), dimension(K+1) :: IND, JND
#if defined __ICC
         !DIR$ ASSUME_ALIGNED IND:64,JND:64
#endif
          INTEGER(kind=4) :: K, L, M, MJ 
          REAL(kind=8), dimension(MJ,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(kind=4) :: K1,J,JJ,I,I1,L1,II1
                                                                      
          K1 = K + 1                                                        
          DO  60 I=1,K1                                                 
                 J = JND(I)                                                        
!cxx   60 IND(J) = I                                                        
                 IND(J) = I
       60 CONTINUE
          JJ = IND(M)                                                       
!cc      IF( JJ-L )     40,40,10                                           
          IF( JJ-L .LT. 0 )  GO TO 40
          IF( JJ-L .EQ. 0 )  GO TO 40
          IF( JJ-L .GT. 0 )  GO TO 10
       10 II1 = L + 1                                                       
          DO  20     I=II1,JJ                                               
                     I1 = JJ+L-I                                                       
!cxx   20 JND(I1+1) = JND(I1)                                               
                    JND(I1+1) = JND(I1)
      20 CONTINUE
         JND(L) = M                                                        
                           
         CALL  HUSHL1( X,MJ,K1,JJ,L,IND,JND )                            
                                                    
         L = L + 1                                                         
      40 RETURN                                                            
   END SUBROUTINE
   
#if defined __ICC
   !DIR$ ATTRIBUTES INLINE :: AICCOM
#ndif
   SUBROUTINE  AICCOM( X,N,M,K,MJ,SD,AIC )  
     use omp_lib
     implicit none
!C                                                                       
!C     THIS SUBROUTINE COMPUTES INNOVATION VARIANCE AND AIC OF THE MODEL 
!C     WITH M REGRESSORS.                                                
!C                                                                       

          INTEGER(kind=4) :: N, M, K, MJ
          REAL(kind=8), dimension(MJ,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif         
          REAL(kind=8) :: SD, AIC
          ! Locals
          INTEGER(kind=4) :: M1,K1,I
          REAL(kind=8) :: FN, SUM
!C                                                                       
!C       INPUTS:                                                         
!C          X:     (K+1)*(K+1) REDUCED MATRIX                            
!C          N:     DATA LENGTH                                           
!C          M:     NUMBER OF REGRESSORS OF THE MODEL                     
!C          K:     POSSIBLE LARGEST NUMBER OF REGRESSORS                 
!C          MJ:    ABSOLUTE DIMENSION OF X                               
!C                                                                       
!C       OUTPUTS:                                                        
!C          SD:    INNOVATION VARIANCE OF THE MODEL                      
!C          AIC:   AIC OF THE MODEL                                      
!C                                                                       
          FN = N                                                            
          M1 = M + 1                                                        
          K1 = K + 1                                                        
          SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif
          DO 10  I=M1,K1                                                    
!cxx   10 SUM = SUM + X(I,K1)*X(I,K1)                                       
               SUM = SUM + X(I,K1)*X(I,K1)
       10 CONTINUE
          SD = SUM / FN                                                     
!cxx   20 AIC = FN*DLOG( SD ) + 2.D0*M                                      
          AIC = FN*DLOG( SD ) + 2.0_8*M                                      
   END SUBROUTINE
   

   SUBROUTINE  ARBAYS( X,D,K,N,ISW,MJ1,SD,AIC,DIC,AICM,SDMIN,      &
                         IMIN,A,B1,B,C,SDB,PN,AICB )  
     use omp_lib
     implicit none
!C                                                                       
!C         +-----------------------------------------------+             
!C         ! AUTOREGRESSIVE MODEL FITTING (BAYESIAN MODEL) !             
!C         +-----------------------------------------------+             
!C                                                                       
!C     THIS SUBROUTINE PRODUCES AN AUTOREGRESSIVE MODEL BY A BAYESIAN    
!C     PROCEDURE USING THE OUTPUT OF SUBROUTINE REDUCT.                  
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             MAICE                                                     
!C             ARCOEF                                                    
!C             BAYSPC                                                    
!C             BAYSWT                                                    
!C!             COMAIC                                                    
!C             PRINTA                                                    
!C             SDCOMP                                                    
!C       ----------------------------------------------------------------
!C       INPUTS:                                                         
!C         X:    (K+1)*(K+1) TRIANGULAR MATRIX, OUTPUT OF SUBROUTINE REDU
!C         D:    WORKING AREA                                            
!C         K:    HIGHEST ORDER OF THE MODELS                             
!C         N:    DATA LENGTH                                             
!C         ISW:  =0     TO SUPPRESS THE OUTPUTS                          
!C               =1     TO PRINT OUT THE OUTPUTS                         
!C         TITLE:     TITLE OF DATA                                      
!!C         MJ1:  ABSOLUTE DIMENSION OF X                                 
!C                                                                       
!C       OUTPUTS:                                                        
!C         A(I) (I=1,K):     AR-COEFFICIENTS                             
!C         B(I) (I=1,K):     PARTIAL AUTOCORRELATION COEFFICIENTS        
!C         SDB:  INNOVATION VARIANCE OF BAYESIAN MODEL                   
!C         AICB: AIC OF BAYESIAN MODEL                                   
!C                                                                       

          INTEGER(kind=4) :: K, N, ISW, MJ1, IMIN
          REAL(kind=8), dimension(MJ1,1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(K+1) :: D, SD, AIC, DIC, C
#if defined __ICC
          !DIR$ ASSUME_ALIGNED D:64,SD:64,AIC:64,DIC:64,C:64
#endif
          REAL(kind=8), dimension(K) :: A,B1,B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64,B1:64,B:64
#endif
          REAL(kind=8) ::     AICM, SDMIN,   SDB, PN, AICB
          ! Locals
          INTEGER(kind=4) :: I
          REAL(kind=8) :: FN
                                      
          FN = N                                                            
!C                                                                       
!C         +-----------------------------------------+                   
!C         ! INNOVATION VARIANCE AND AIC COMPUTATION !                   
!C         +-----------------------------------------+                   
!C                                                                       
          CALL  COMAIC( X,N,K,MJ1,SD,AIC )                                  
!C                                                                       
!C         +-------------+                                               
!C         ! AIC DISPLAY !                                               
!C         +-------------+                                               
!C                                                                       
               
          CALL MAICE( AIC,SD,K,AICM,SDMIN,IMIN,DIC )                   
!C                                                                       
!C         +-----------------------------+                               
!C         ! BAYSIAN WEIGHTS COMPUTATION !                               
!C         +-----------------------------+                               
!C                                                                       
          CALL  BAYSWT( AIC,AICM,K,0,C )                                    
!C                                                                       
!C         +-----------------------------------------------------+       
!C         ! PARTIAL AUTOCORRELATION ESTIMATION (BAYESIAN MODEL) !       
!C         +-----------------------------------------------------+       
!C                                                                       
                           
          CALL  BAYSPC( X,C,N,K,ISW,MJ1,B1,B,D )
!C                                                                       
!C         +-----------------------------------------+                   
!C         ! AUTOREGRESSIVE COEFFICIENTS COMPUTATION !                   
!C         +-----------------------------------------+                   
!C                                                                       
          CALL  ARCOEF( B,K,A )                                             
!C                                                                       
!C                                                                       
!C          EQUIVALENT NUMBER OF PARAMETERS                              
!C                                                                       
          PN = 1._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:PN)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:PN)
#endif
          DO   10    I=1,K                                                  
!cxx   10 PN = PN + D(I)*D(I)                                               
               PN = PN + D(I)*D(I)
       10 CONTINUE
!!C                                                                       
!C         +-------------------------------------------+                 
!C         ! INNOVATION VARIANCE OF THE BAYESIAN MODEL !                 
!C         +-------------------------------------------+                 
!C                                                                       
                               
          CALL  SDCOMP( X,A,N,K,MJ1,SDB )                                 
!C                                                                       
!C          -------------------------                                    
!C          AIC OF THE BAYESIAN MODEL                                    
!C          -------------------------                                    
!C                                                                       
          AICB = FN * DLOG( SDB ) + 2.0_8*PN                                 
    END SUBROUTINE
                         
                                                            
                                                         
#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: ARCOEF
#endif
    SUBROUTINE  ARCOEF( B,K,A )    
         
!C                                                                       
!C     THIS SUBROUTINE PRODUCES THE AUTOREGRESSIVE COEFFICIENTS FROM A SE
!C     OF PARTIAL AUTOCORRELATION COEFFICIENTS.                          
!C                                                                       
!C       INPUTS:                                                         
!C         B:    VECTOR OF PARTIAL AUTOCORRELATIONS                      
!C         K:    ORDER OF THE MODEL                                      
!C                                                                       
!C       OUTPUTS:                                                        
!C         A:    VECTOR OF AR-COEFFICIENTS                               
!C                                                                       
!C                                                                       

          INTEGER(kind=4) :: K
          REAL(kind=8), dimension(K) :: B, A, AA
#if defined __ICC
          !DIR$ ASSUME_ALIGNED B:64,A:64,AA:64
#endif
          ! Locals
          INTEGER(kind=4) :: II,J,JJ,IM1
                                                                       
          DO  30 II=1,K                                                 
              A(II) = B(II)                                                     
              AA(II) = B(II)                                                    
              IM1 = II - 1                                                      
              IF( IM1 .LE. 0 )     GO TO 30
#if defined __ICC
              !DIR$ VECTOR ALIGNED
              !DIR$ SIMD
#elif defined __GFORTRAN__
              !$OMP SIMD
#endif
              DO  10 J=1,IM1                                                
                  JJ = II - J                                                       
!cxx   10 A(J) = AA(J) - B(II)*AA(JJ)                                       
                  A(J) = AA(J) - B(II)*AA(JJ) 
          10 CONTINUE
                  IF( II .EQ. K )     GO TO 40
#if defined __ICC
!DIR$ VECTOR ALIGNED
                  !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
              !$OMP SIMD
#endif
             DO  20     J=1,IM1                                                
!cxx   20 AA(J) = A(J)
                 AA(J) = A(J)
          20 CONTINUE
       30 CONTINUE                                                          
       40 CONTINUE                                                          
    END SUBROUTINE
    
    
    SUBROUTINE  ARMFIT( X,K,LAG,N,ISW,MJ1,A,IMIN,SD,AIC,DIC,SDMIN,AICM )
      implicit none
        
!C                                                                       
!C          +------------------------------+                             
!C          ! AUTOREGRESSIVE MODEL FITTING !                             
!C          +------------------------------+                             
!C                                                                       
!C       THIS SUBROUTINE PRODUCES PARAMETERS OF AR-MODELS USING THE OUTPU
!C       SUBROUTINE REDUCT.                                              
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             MAICE                                                     
!C             COMAIC                                                    
!C             PRINTA                                                    
!C             RECOEF                                                    
!C       ----------------------------------------------------------------
!C       INPUTS:                                                         
!C         X:    (K+1)*(K+1) TRIANGULAR MATRIX, OUTPUT OF SUBROUTINE REDU
!C         K:    NUMBER OF REGRESSORS OF THE MODEL                       
!C         LAG:  MAXIMUM TIME LAG OF THE MODEL                           
!C         N:    DATA LENGTH                                             
!C         ISW:  =0   TO PRODUCE THE MAICE MODEL ONLY (OUTPUTS SUPPRESSED
!C               =1   TO PRODUCE THE MAICE MODEL ONLY                    
!C               =2   TO PRODUCE ALL AR-MODELS (UP TO THE ORDER K)       
!C         TITLE:     TITLE OF DATA                                      
!C         MJ1:  ABSOLUTE DIMENSION OF X                                 
!C                                                                       
!C       OUTPUTS:                                                        
!C         A:      VECTOR OF MAICE AR-COEFFICIENTS                       
!C         SDMIN:  MAICE INNOVATION VARIANCE                             
!C         IMIN:   MAICE ORDER                                           
!C                                                                       

          INTEGER(kind=4) :: K, LAG, N, ISW, MJ1, IMIN
          REAL(kind=8), dimension(MJ1,1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(K) :: A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          REAL(kind=8), dimension(K+1) :: SD, AIC, DIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED SD:64,AIC:64,DIC:64
#endif
          REAL(kind=8) :: SDMIN,AICM
          ! Locals
          INTEGER(kind=4) :: M,I,M1,L1,NL
               
!C          +-----------------------------------------+                +-
!C          ! INNOVATION VARIANCE AND AIC COMPUTATION !                ! 
!C          +-----------------------------------------+                +-
!C                                                                       
          CALL  COMAIC( X,N,K,MJ1,SD,AIC )                                  
!C                                                                       
!C          +-------------+                                            +-
!C          ! AIC DISPLAY !                                            ! 
!C          +-------------+                                            +-
!C                                                                       

          CALL  MAICE( AIC,SD,K,AICM,SDMIN,IMIN,DIC )
!C                                                                       
!C          +-----------------------------------------+                +-
!C          ! AUTOREGRESSIVE COEFFICIENTS COMPUTATION !                ! 
!C          +-----------------------------------------+                +-
!C                                                                       
          IF( ISW .LT. 2 )     GO TO  20                                    

          M = 0                                                             

          DO 10 M=1,K                                                  
                M1 = M + 1                                                        
                CALL  RECOEF( X,M,K,MJ1,A )                                       

       10 CONTINUE
                                                                       
       20 IF( IMIN .GE. 1 )  CALL  RECOEF( X,IMIN,K,MJ1,A )                 
          L1 = LAG + 1                                                      
          NL = N + LAG                                                      
    END SUBROUTINE
    
                                                            
                      
    SUBROUTINE  BAYSPC( X,C,N,K,ISW,MJ1,B,B1,D )
      use omp_lib
      implicit none
        
!C                                                                       
!C     THIS SUBROUTINE PRODUCES PARTIAL AUTOCORRELATION COEFFICIENTS B(I)
!C     (I=1,K) OF THE BAYESIAN MODEL.                                    
!C                                                                       
!C         +-----------------------------------------------------+       
!C         ! PARTIAL AUTOCORRELATION ESTIMATION (BAYESIAN MODEL) !       
!C         +-----------------------------------------------------+       
!C                                                                       
!C       INPUTS:                                                         
!C         X:    N*(K+1) TRIANGULAR MATRIX, OUTPUT OF SUBROUTINE REDUCT  
!C         C:    BAYESIAN WEIGHTS, OUTPUT OF SUBROUTINE BAYSWT           
!C         N:    DATA LENGTH                                             
!C         K:    HIGHEST ORDER OF THE MODELS                             
!C         ISW:  =0     OUTPUTS ARE SUPPRESSED                           
!C         ISW:  >0     OUTPUTS ARE PRINTED OUT                          
!C         MJ1:  ABSOLUTE DIMENSION OF X                                 
!C                                                                       
!C       OUTPUTS:                                                        
!C         B:    VECTOR OF PARTIAL AUTOCORRELATIONS                      
!C         D:    INTEGRATED BAYESIAN WEIGHTS                             
!C                                                                       

          INTEGER(kind=4) :: N, K, ISW, MJ1
          REAL(kind=8), dimension(MJ1,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(K+1) :: C,D
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64,D:64
#endif
          REAL(kind=8), dimension(K) :: B,B1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED B:64,B1:64
#endif
          ! Locals
          INTEGER(kind=4) :: K1,I,J,ISIG,ISIGP1,ISIGM1,ISIGP2,ISIGM2, &
                           J0,
          REAL(kind=8) :: FN, SUM, G, SC, SIG 
                                           
          K1 = K + 1                                                        
          FN = N                                                            
!C                                                                       
!C          PARTIAL AUTOCORRELATION (LEAST SQUARES ESTIMATE)             
!C                                                                       
          SUM = X(K1,K1)**2
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif
          DO 10  I=1,K                                                      
                 J = K1 - I                                                        
                 SUM = SUM + X(J,K1)**2                                            
                 G = DSQRT( SUM )                                                  
!cxx   10 B(J) = X(J,K1)*X(J,J) / (G*DABS(X(J,J)))                          
                 B(J) = X(J,K1)*X(J,J) / (G*DABS(X(J,J)))
       10 CONTINUE
!C                                                                       
!C          INTEGRATED BAYESIAN WEIGHT                                   
!C                                                                       
          D(K) = C(K1)                                                      
          DO  80 I=2,K                                                  
                 J = K1 - I                                                        
!cxx   80 D(J) = D(J+1) + C(J+1)                                            
                 D(J) = D(J+1) + C(J+1)
       80 CONTINUE
          IF( ISW .EQ. 0 )   GO TO 100                                      
!C                                                                       
!C          PARCOR AND BAYESIAN WEIGHTS DISPLAY                          
!C                                                                       
          SC = 20._dp                                                        
          SIG = 1._dp/DSQRT(FN)                                              
                                                     
          ISIG = INT(SIG*SC + 0.5_dp)
          J0 = INT(SC) + 1                                                       
          ISIGP1 = J0 + ISIG                                                
          ISIGM1 = J0 - ISIG                                                
          ISIGP2 = J0 + ISIG*2                                              
          ISIGM2 = J0 - ISIG*2                                              
                                                      
!C                                                                       
!C          PARCOR OF BAYESIAN MODEL                                     
!C                                                                       
100       CONTINUE
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif          
          DO  110 I=1,K                                                 

              B1(I) = B(I) * D(I)
      110 CONTINUE
    END SUBROUTINE
    
                                                         

    SUBROUTINE  BAYSWT( AIC,AICM,K,ISW,C )
      use omp_lib
      implicit none
        
!C                                                                       
!C     THIS SUBROUTINE COMPUTES BAYESIAN WEIGHT OF AR-MODEL OF EACH ORDER
!C                                                                       
!C         +-----------------------------+                               
!C         ! BAYESIAN WEIGHT COMPUTATION !                               
!C         +-----------------------------+                               
!C                                                                       
!C     BAYESIAN WEIGHT OF THE M-TH ORDER MODEL IS DEFINED BY             
!C            W(M)  =  CONST * C(M) / ( M+1 ),                           
!C     WHERE                                                             
!C            CONST =  NORMALIZING FACTOR                                
!C            C(M)  =  EXP( -0.5*AIC(M) )                                
!C                                                                       
!C       INPUTS:                                                         
!C         AIC:  VECTOR OF AIC'S                                         
!C         AICM: MINIMUM AIC                                             
!C         K:    HIGHEST ORDER OF THE MODELS                             
!C         ISW:  =0   NON-ADAPTIVE DAMPER                                
!C               =1   DATA ADAPTIVE DAMPER                               
!C               =2   DAMPER DOES NOT USED                               
!C                                                                       
!C       OUTPUT:                                                         
!C         C(I) (I=1,K+1):   VECTOR OF BAYESIAN WEIGHTS                  
!C                                                                       

          INTEGER(kind=4) :: K, ISW
          REAL(kind=8), dimension(K+1) :: AIC, C
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AIC:64,C:64
#endif
          REAL(kind=8) :: AICM
          ! Locals
          INTEGER(kind=4) :: K1,I
          REAL(kind=8) :: SUM, EK, DIC, AI
                                                                       
          K1 = K + 1                                                        
          SUM = 0._8                                                      
          EK = 0._8
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          !DIR$ SIMD REDUCTION(+:SUM,EK)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM,EK)
#endif
          DO  11 I=1,K1
              DIC = -0.5_8 * (AIC(I) - AICM)                                    
              C(I) = 0._dp                                                      
              IF( DIC .LT. -40.0_8 )     GO TO 10                                
              C(I) = DEXP(DIC)                                                  
              EK = EK + (I-1) * C(I)                                            
           10 SUM = SUM + C(I)                                                  
       11 CONTINUE
!C                                                                       
!C          DAMPING OF C(I)                                              
!C                                                                       
          IF( ISW .EQ. 1 )     GO TO 30                                     
          IF( ISW .EQ. 2 )     GO TO 50                                     
          SUM = 0._8
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif          
          DO  20 I=1,K1                                                 
              AI = I                                                            
              C(I) = C(I) / AI                                                  
!cxx   20 SUM = SUM + C(I)
              SUM = SUM + C(I)
       20 CONTINUE
          GO TO 50                                                          
!C                                                                       
!C          DATA ADAPTIVE DAMPER                                         
!C                                                                       
       30 EK = EK / ( SUM+EK )                                              
          SUM = 0._8
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif     
          DO  40 I=1,K1                                                 
              C(I) = C(I) * EK**(I-1)                                           
                                                 
              SUM = SUM + C(I)
       40 CONTINUE
!C                                                                       
!C          NORMALIZATION OF C                                           
              !C
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif               
       50 DO  60 I=1,K1                                                 
                                           
              C(I) = C(I) / SUM
       60 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE  COEF2( A,M,ID,II,JND,LMAX,MM,KSW,MSW,MJ1,B,C,E ) 
      use omp_lib
      implicit none
!C                                                                       
!C     COMPOSITION OF AR-COEFFICIENT MATRICES WITH INSTANTANEOUS RESPONSE
!C                                                                       
!C       INPUTS:                                                         
!C          A(I)  (I=1,M):     REGRESSION COEFFICIENTS                   
!C          JND(I) (I=1,M):    SPECIFICATION OF REGRESSORS               
!C          M:     NUMBER OF REGRESSORS                                  
!C          ID:    DIMENSION OF VECTOR OF OBSERVATIONS                   
!C          II:    REGRESSAND                                            
!C          LMAX:  HIGHEST ORDER OF THE MODEL                            
!C          MM:    ORDER                                                 
!C          KSW:   =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR    
!C                 =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSOR
!C          MSW:   =0  CONSTANT VECTOR IS NOT ADOPTED AS A REGRESSOR     
!C                 =1  CONSTANT VECTOR IS ACTUALLY ADOPTED AS REGRESSOR  
!C          MJ1:   ABSOLUTE DIMENSION OF B                               
!C       OUTPUTS:                                                        
!C          B:     AR-COEFFICIENT MATRICES                               
!C          C:     CONSTANT VECTOR                                       
!C          E:     COEFFICIENT FOR INSTANTANEOUS RESPONSE                
!C                                                                       
                               
          INTEGER :: M, ID, II , LMAX, MM, KSW, MSW, MJ1
          INTEGER(kind=4), dimension(M) :: JND
#if defined __ICC
          !DIR$ ASSUME_ALIGN : 64 :: JND
#endif
          REAL(kind=8), dimension(M) :: A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          REAL(kind=8), dimension(MJ1,MJ1,MM) :: B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED B:64
#endif
          REAL(kind=dp), dimension(ID) :: C
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64
#endif
          REAL(kind=dp), dimension(MJ1,ID) :: E
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64
#endif
          ! Locals
          INTEGER(kind=int4) :: M0,JJ,I,L,L1
                                                                       
          M0 = MSW + 1                                                      
          C(II) = 0._8                                                     
          IF( MSW .EQ. 1 )     C(II) = A(1)                                 
          DO  100   JJ=M0,M                                                 
              I = JND(JJ) - KSW                                                 
              L = I / ID                                                        
              J = I - L*ID                                                      
              IF( J .NE. 0 )     GO TO 10                                       
               J = ID                                                            
              L = L - 1                                                         
           10 L1 = L + 1                                                        
              IF( I .LE. MM*ID )     GO TO  20                                  
              E(II,J) = -A(JJ)                                                  
              GO TO 30                                                          
           20 B(II,J,L1) = A(JJ)                                                
              IF( LMAX .LT. L1 )     LMAX = L1                                  
           30 CONTINUE                                                          
      100 CONTINUE                                                          
          DO  40 I=1,ID                                                 
!cxx   40 E(I,I) = 1.D0                                                     
                E(I,I) = 1._8
       40 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  COMAIC( X,N,K,MJ1,SD,AIC ) 
        implicit none
!C                                                                       
!C          +-----------------------------------------+                  
!C          ! INNOVATION VARIANCE AND AIC COMPUTATION !                  
!C          +-----------------------------------------+                  
!C                                                                       
!C       INPUTS:                                                         
!C          X:     (K+1)*(K+1) TRIANGULAR MATRIX, OUTPUT OF SUBROUTINE  R
!C          N:     DATA LENGTH                                           
!C          K:     NUMBER OF REGRESSORS                                  
!C          MJ1:   ABSOLUTE DIMENSION OF X                               
!C                                                                       
!C       OUTPUTS:                                                        
!C          SD(M)  (M=1,K+1):   VECTOR OF INNOVATION VARIANCES           
!C          AIC(M) (M=1,K+1):   VECTOR OF AIC'S.                         
!C                                                                       
                        
          INTEGER(kind=4) :: N, K, MJ1
          REAL(kind=8), dimension(MJ1,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(K+1)     :: SD, AIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED SD:64,AIC:64
#endif
          ! Lcals
          INTEGER(kind=4) :: K1,I,M
          REAL(kind=8) :: FN, OSD
          FN = N                                                            
          K1 = K + 1                                                        
                                                                      
          OSD = 0.0_8                                                    
          DO 10  I = 1,K1                                                  
                 M = K1 - I + 1                                                    
                 OSD = OSD + X(M,K1)**2                                            
                 SD(M)  = OSD / FN                                                 
                         
                 AIC(M) = FN*DLOG( SD(M) ) + 2*M
       10 CONTINUE
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: COPY
#endif
    SUBROUTINE  COPY( X,K,II,JJ,MJ1,MJ2,Y ) 
       implicit none
!C                                                                       
!C         +-----------------------+                                     
!C         ! MAKE A COPY OF X ON Y !                                     
!C         +-----------------------+                                     
!C                                                                       
!C        INPUTS:                                                        
!C             X(I+II,J):     K*K MATRIX (I,J=1,...,K)                   
!C             II:            INDICATES ORIGIN OF X                      
!C             JJ:            INDICATES ORIGIN OF Y                      
!C             MJ1:           ABSOLUTE DIMENSION OF X                    
!C             MJ2:           ABSOLUTE DIMENSION OF Y                    
!C                                                                       
!C        OUTPUT:                                                        
!C             Y(I+JJ,J):     COPY OF X (I,J=1,...,K)                    
!C                                                                       
                               
          INTEGER(kind=4) :: K, II, JJ, MJ1, MJ2
          REAL(kind=8), dimension(MJ1,K) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(MJ2,K) :: Y
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Y:64
#endif
          ! Locals
          INTEGER(kind=int4) :: I,I1,I2
          DO  20 I=1,K
                 I1 = I + II                                                       
                 I2 = I + JJ                                                       
                 DO  10 J=1,K                                                  

                     Y(I2,J) = X(I1,J)
              10 CONTINUE
        20 CONTINUE
    END SUBROUTINE
    
#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: DELETE
#endif
    SUBROUTINE  DELETE( X,IND,JND,K,L,M,MJ )  
       
!C                                                                       
!C         +------------------------------------------------+            
!C         ! DELETION OF THE VARIABLE M FROM THE REGRESSORS !            
!C         +------------------------------------------------+            
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             HUSHL1                                                    
!C       ----------------------------------------------------------------
!C       INPUTS:                                                         
!C          IND(J)=I:     PRESENT STATUS,   VARIABLE J IS THE I-TH REGRES
!C          JND(I)=J:     REQUIRED STATUS,  I-TH REGRESSOR IS VARIABLE J.
!C          X:            (K+1)*(K+1)  MATRIX                            
!C          D:            WORKING AREA                                   
!C          K:            NUMBER OF VARIABLES                            
!C          L:            NUMSER OF REGRESSORS IN THE PRESENT MODEL      
!C          M:            INDICATION OF THE VARIABLE TO BE DELETED       
!C          MJ:           ABSOLUTE DIMENSION OF X                        
!C       OUTPUTS:                                                        
!C          X:            (K+1)*(K+1)  MATRIX                            
!C                                                                       

          INTEGER(kind=4), dimension(K+1) :: IND, JND 
          INTEGER(kind=4) :: K, L, M, MJ
          REAL(kind=8), dimension(MJ,K+1) :: X
          ! Locals
          INTEGER(kind=int4) :: K1,J,I,II,I1,LM1

          K1 = K + 1                                                        
          DO  60 I=1,K1                                                 
              J = JND(I)                                                        
                                                  
              IND(J) = I
       60 CONTINUE
          II = IND(M)                                                       
                                    
          IF( II-L .LT. 0 )  GO TO 10
          IF( II-L .EQ. 0 )  GO TO 30
          IF( II-L .GT. 0 )  GO TO 40
       10 I1 = II + 1                                                       
          DO  20 I=I1,L                                                 
                                        
              JND(I-1) = JND(I)
       20 CONTINUE
          JND(L) = M                                                        
          LM1 = L - 1                                                       
                     
          CALL  HUSHL1( X,MJ,K1,LM1,II,IND,JND )                          
                                                                       
        30 L = L - 1                                                         
                                                                       
       40 RETURN                                                            
    END SUBROUTINE
    
#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: FOUGER
#endif
    SUBROUTINE FOUGER(G,LGP1,FC,FS,LF1) 
        implicit none
!C                                                                       
!C     FOURIER TRANSFORM (GOERTZEL METHOD)                               
!C     THIS SUBROUTINE COMPUTES FOURIER TRANSFORM OF G(I),I=0,1,...,LG AT
!C     FREQUENCIES K/(2*LF), K=0,1,...,LF AND RETURNS COSINE TRANSFORM IN
!C     FC(K) AND SINE TRANSFORM IN FS(K).                                
!C                                                                       
!C       INPUTS:                                                         
!C          G(I):   ORIGINAL DATA (I=0,1,...,LG)                         
!C          LG1:    = LG+1                                               
!C          LF1:    = LF+1                                               
!C                                                                       
!C       OUTPUTS:                                                        
!C          FC(I):  COSINE TRANSFORM OF G  (I=0,1,...,LF)                
!C          FB(I):  SINE TRANSFORM OF G  (I=0,1,...,LF)                  
!C                                                                       

          INTEGER(kind=4) :: LGP1, LF1
          REAL(kind=8), dimension(LGP1) :: G
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64
#endif
          REAL(kind=8), dimension(LF1) :: FC, FS
#if defined __ICC
          !DIR$ ASSUME_ALIGNED FC:64,FS:64
#endif
          ! Locals
          INTEGER(kind=4) :: LG,LF,LG3,LG4,I,I2,K,LF1
          REAL(kind=7) :: T, PI, ALF, AK, TK, CK, SK, CK2, UM0, UM1, UM2
          LG=LGP1-1                                                         
          LF=LF1-1                                                          
!C     REVERSAL OF G(I),I=1,...,LGP1 INTO G(LG3-I)   LG3=LGP1+1          
          IF(LGP1.LE.1) GO TO 110                                           
          LG3=LGP1+1                                                        
          LG4=LGP1/2                                                        
          DO 100 I=1,LG4                                                    
             I2=LG3-I                                                          
             T=G(I)                                                            
             G(I)=G(I2)                                                        
!cxx  100 G(I2)=T                                                           
             G(I2)=T
      100 CONTINUE
      110 PI=3.1415926536_8                                                 
          ALF=LF                                                            
          T=PI/ALF                                                          
          DO 10 K=1,LF1                                                     
             AK=K-1                                                            
             TK=T*AK                                                           
             CK=DCOS(TK)                                                       
             SK=DSIN(TK)                                                       
             CK2=CK+CK                                                         
             UM1=0._8                                                        
             UM2=0._8                                                         
          IF(LG.EQ.0) GO TO 12                                              
          DO 11 I=1,LG                                                      
             UM0=CK2*UM1-UM2+G(I)                                              
             UM2=UM1                                                           
!cxx   11 UM1=UM0
             UM1=UM0
       11 CONTINUE
       12 FC(K)=CK*UM1-UM2+G(LGP1)                                          
          FS(K)=SK*UM1                                                      
       10 CONTINUE                                                          
    END SUBROUTINE
    
                  
    SUBROUTINE  HUSHL1( X,MJ1,K,L,M,IND,JND ) 
      use omp_lib
      implicit none
!C                                                                       
!C     THIS SUBROUTINE PERFORMS THE HOUSEHOLDER TRANSFORMATION OF THE MAT
!C                                                                       
!C       INPUTS:                                                         
!C         X:   ORIGINAL (K+1)*(K+1) MATRIX                              
!C         N:   NUMBER OF ROWS OF X,  NOT GREATER THAN MJ1               
!C         K:   NUMBER OF COLUMNS OF X                                   
!C         L:   END POSITION OF THE HOUSEHOLDER TRANSFORMATION           
!C         M:   STARTING POSITION OF THE HOUSEHOLDER TRANSFORMATION      
!C         IND:   SPECIFICATION OF THE PRESENT FORM OF X                 
!C                IND(J) = I;     VARIABLE I IS THE J-TH REGRESSOR       
!C         JND:   SPECIFICATION OF THE REQUIRED FORM OF X                
!C                JND(I) = J;     THE I-TH REGRESSOR IS VARIABLE J       
!C                                                                       
!C       OUTPUTS:                                                        
!C         X:   TRANSFORMED MATRIX                                       
!C                                                                       
!C                                                                       

          INTEGER(kind=4) :: MJ1, K, L, M, 
          INTEGER(kind=4), dimension(K) :: IND, JND
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IND:64,JND:64
#endif
          REAL(kind=8), dimension(MJ1,K) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(4) :: II,I,NN,II1,J1
          REAL(8) ::  TOL, H, G, F, S
          REAL(8), dimension(MJ1) :: D 
!DIR$ ATTRIBUTES ALIGN : 64 :: D                                                                      
          TOL = 1.0E-60_8                                                     


          NN = 0                                                            
!cxx      DO  100     II=M,L                                                
          DO  110 II=M,L
              JJ = JND(II)                                                      
              NN = MAX0( NN,IND(JJ) )                                           
              H = 0.0_8
#if defined __ICC
              !DIR$ VECTOR ALIGNED
              !DIR$ SIMD
              !DIR$ SIMD REDUCTION(+:H)
#elif defined __GFORTRAN__
              !$OMP SIMD REDUCTION(+:H)
#endif
              DO  10 I=II,NN                                                
                  D(I) = X(I,JJ)                                                    
!cxx   10 H = H + D(I)*D(I)                                                 
                  H = H + D(I)*D(I)
           10 CONTINUE
              IF( H .GT. TOL )     GO TO 20                                     
              G = 0.0_8                                                       
              GO TO 100                                                         
           20 G = DSQRT( H )                                                    
              F = X(II,JJ)                                                      
              IF( F .GE. 0.0_8)     G = -G                                    
              D(II) = F - G                                                     
              H = H - F * G                                                     
!C                                                                       
!C     ( I - D*D'/H ) * X                                                
!C                                                                       
             II1 = II + 1                                                      
             IF( II .EQ. NN )   GO TO 35                                       
             DO  30 I=II1,NN                                               
!cxx   30 X(I,JJ) = 0.D0                                                    
                   X(I,JJ) = 0._8
           30 CONTINUE
        35    CONTINUE                                                          
                   IF( II .EQ. K )     GO TO 100
#if defined __ICC
              !DIR$ VECTOR ALIGNED
              !DIR$ SIMD
                   !DIR$ SIMD REDUCTION(+:S)
#elif defined __GFORTRAN__
              !$OMP SIMD REDUCTION(+:S)
#endif                   
              DO  60 J1=II1,K                                               
                  J = JND(J1)                                                       
                  S = 0.0_8                                                      
                  DO  40 I=II,NN                                                
!cxx   40 S = S + D(I)*X(I,J)
                         S = S + D(I)*X(I,J)
              40 CONTINUE
                         S = S / H
#if defined __ICC
                  !DIR$ VECTOR ALIGNED
                         !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
              !$OMP SIMD
#endif
                 DO  50  I=II,NN                                                
!cxx   50 X(I,J) = X(I,J) - D(I)*S
                    X(I,J) = X(I,J) - D(I)*S
              50 CONTINUE
         60 CONTINUE                                                          
      100 X(II,JJ) = G
      110 CONTINUE
    END SUBROUTINE
    
                            
    SUBROUTINE  HUSHLD( X,MJ1,N,K ) 
      use omp_lib
      implicit none
!C                                                                       
!C          +----------------------------+                               
!C          ! HOUSEHOLDER TRANSFORMATION !                               
!C          +----------------------------+                               
!C                                                                       
!C     THIS SUBROUTINE  TRANSFORMS MATRIX X INTO AN UPPER TRIANGULAR FORM
!C     BY HOUSEHOLDER TRANSFORMATION.                                    
!C                                                                       
!C       INPUTS:                                                         
!C          X:     ORIGINAL N*K DATA MATRIX                              
!C          D:     WORKING AREA                                          
!C          MJ1:   ABSOLUTE DIMENSION OF X                               
!C          N:     NUMBER OF ROWS OF X, NOT GREATER THAN MJ1             
!C          K:     NUMBER OF COLUMNS OF X                                
!C                                                                       
!C       OUTPUT:                                                         
!C          X:     SQUARE ROOT OF DATA COVARIANCE MATRIX (UPPER TRIANGULA
!C                                                                       
!C                                                                       

          INTEGER(kind=4) :: MJ1, N, K
          REAL(kind=8), dimension(MJ1,K) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(kind=4) :: II,I,II1,J
          REAL(kind=8) ::   TOL, H, G, F, S
          REAL(kind=8), dimension(MJ1) :: D
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: D
#endif                                                                      
          TOL = 1.0E-60_8                                               
                                                                       
                                              
          DO 110  II=1,K
             H = 0.0_8
#if defined __ICC
              !DIR$ VECTOR ALIGNED
              !DIR$ SIMD
             !DIR$ SIMD REDUCTION(+:H)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:H)
#endif
                 DO 10  I=II,N                                                  
                     D(I) = X(I,II)                                              
!cxx   10       H = H + D(I)*D(I)                                           
                     H = H + D(I)*D(I)
           10    CONTINUE
                 IF( H .GT. TOL )  GO TO 20                                     
                 G = 0.0_8                                                    
                 GO TO 100                                                      
           20    G = DSQRT( H )                                                 
                 F = X(II,II)                                                   
                 IF( F .GE. 0.0_8)   G = -G                                   
                 D(II) = F - G                                                  
                 H = H - F*G                                                    
!C                                                                       
!C          FORM  (I - D*D'/H) * X, WHERE H = D'D/2                      
!C                                                                       
                 II1 = II+1
#if defined __ICC
                   !DIR$ VECTOR ALIGNED
                 !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
             !$OMP SIMD 
#endif                 
                 DO 30  I=II1,N                                                 
!cxx   30    X(I,II) = 0.0D00                                               
                        X(I,II) = 0.0_8
           30    CONTINUE
                 IF( II .EQ. K )  GO TO 100                                     
                 DO 60  J=II1,K                                                 
                    S = 0.0_8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                    !DIR$ SIMD REDUCTION(+:S)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:S)
#endif                    
                        DO 40  I=II,N                                               
!cxx   40       S = S + D(I)*X(I,J)                                         
                              S = S + D(I)*X(I,J)
              40       CONTINUE
                              S = S/H
#if defined __ICC
                         !DIR$ VECTOR ALIGNED
                              !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
             !$OMP SIMD 
#endif      
                       DO 50  I=II,N                                               
!cxx   50      X(I,J) = X(I,J) - D(I)*S                                     
                              X(I,J) = X(I,J) - D(I)*S
               50       CONTINUE
            60    CONTINUE                                                       
               100 X(II,II) = G
      110 CONTINUE                                                      
    END SUBROUTINE
    
    SUBROUTINE  MAICE( AIC,SD,K,AICM,SDM,IMIN,DIC )
        implicit none
!C                                                                       
!C             +-------------+                                           
!C             ! AIC DISPLAY !                                           
!C             +-------------+                                           
!C                                                                       
!C        THIS SUBROUTINE PRODUCES NUMERICAL AND GRAPHICAL DISPLAYS OF AI
!C                                                                       
!C       INPUTS:                                                         
!C          AIC:   VECTOR OF AIC'S                                       
!C          SD:    VECTOR OF INNOVATION VARIANCES                        
!C          K:     UPPER LIMIT OF THE ORDER                              
!C          ISW:   =0   OUTPUTS ARE SUPPRESSED                           
!C                 >0   AIC'S ARE DIPLAIED                               
!C                                                                       
!C       OUTPUTS:                                                        
!C          AICM:  MINIMUM AIC                                           
!C          SDM:   MAICE INNOVATION VARIANCE                             
!C          IMIN:  MAICE ORDER                                           
!C                                                                       

          INTEGER(kind=4) :: K, IMIN
          REAL(kind=8), dimension(K+1) :: AIC, SD,  DIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AIC:64,SD:64,DIC:64
#endif
          REAL(kind=8) :: AICM, SDM  
          ! Locals
          INTEGER(kind=4) :: K1,I
!C       SEARCH FOR THE MINIMUM OF AIC(I)                                
!C                                                                       
          K1 = K + 1                                                        
          IMIN = 0                                                          
          SDM  = SD(1)                                                      
          AICM = AIC(1)                                                     
          DO  20 I = 1,K                                                  
                 IF( AIC(I+1) .GE. AICM )  GO TO 20                                
                 IMIN = I                                                          
                 SDM = SD(I+1)                                                     
                 AICM = AIC(I+1)                                                   
       20 CONTINUE                                                          
          DO 25    I = 1,K1
!cxx   25 DIC(I) = AIC(I) - AICM
                   DIC(I) = AIC(I) - AICM
       25 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  MARCOF( D,E,ID,M,MJ3,A,B )
      use omp_lib
      implicit none
!C                                                                       
!C     THIS SUBROUTINE COMPUTES COEFFICIENT MATRICES OF MULTI-VARIATE AUT
!C     REGRESSIVE MODEL FROM PARTIAL AUTOREGRESSION COEFFICIENT MATRICES 
!C     FORWARD AND BACKWARD MODELS.                                      
!C                                                                       
!C       INPUTS:                                                         
!C          D:     PARTIAL AUTOCORRELATIONS OF FORWARD MODEL             
!C          E:     PARTIAL AUTOCORRELATIONS OF BACKWARD MODEL            
!C          ID:    DIMENSION OF THE PROCESS                              
!C          M:     ORDER OF THE MODELS                                   
!C          MJ3:   ABSOLUTE DIMENSION OF A,B,D AND E IN THE MAIN PROGRAM 
!C                                                                       
!C       OUTPUTS:                                                        
!C          A:     AR-COEFFICIENT MATRICES OF FORWARD MODEL              
!C          B:     AR-COEFFICIENT MATRICES OF BACKWARD MODEL             
                              
          INTEGER(kind=4) :: ID, M, MJ3
          REAL(kind=8), dimension(MJ3,MJ3,M) :: D, E, A, B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED D:64,E:64,A:64,B:64
#endif
          ! Locals
          INTEGER(kind=4) :: II,I,J,II1,IMJ
          REAL(kind=8) ::  SUMA, SUMB
          REAL(kind=8), dimension(ID,ID) :: F, G
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: F,G
#endif
          DO 12  II=1,M                                                     
             DO 11  I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
                DO 10  J=1,ID                                                     
                       A(I,J,II) = D(I,J,II)                                             
!cxx   10 B(I,J,II) = E(I,J,II)                                             
                       B(I,J,II) = E(I,J,II)
             10 CONTINUE
          11 CONTINUE
       12 CONTINUE
          IF(  M .EQ. 1 )  RETURN                                           
                                                                       
          DO 60 II=2,M                                                     
                                                                       
             II1 = II - 1                                                      
             DO 50  JJ=1,II1                                                   
                IMJ = II - JJ                                                     
!cxx      DO 20  I=1,ID
                DO 21  I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
                   !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif                   
                   DO 20  J=1,ID
                      
                      F(I,J) = A(I,J,IMJ)                                               
!cxx   20 G(I,J) = B(I,J,JJ)
                      G(I,J) = B(I,J,JJ)
                 20 CONTINUE
             21 CONTINUE
!cxx      DO 40  I=1,ID                                                     
                DO 41  I=1,ID
                   DO 40  J=1,ID                                                     
                      SUMA = F(I,J)                                                     
                      SUMB = G(I,J)
#if defined __ICC
                      !DIR$ VECTOR ALIGNED
                      !DIR$ SIMD REDUCTION(+:SUMA,SUMB)
#elif defined __GFORTRAN__
                      !$OMP SIMD REDUCTION(+:SUMA,SUMB)
              
#endif                      
                      DO 30  L=1,ID                                                     
                         SUMA = SUMA - A(I,L,II)*G(L,J)                                    
!cxx   30 SUMB = SUMB - B(I,L,II)*F(L,J)                                    
                         SUMB = SUMB - B(I,L,II)*F(L,J)
                   30 CONTINUE
                      A(I,J,IMJ) = SUMA                                                 
!cxx   40 B(I,J,JJ) = SUMB                                                  
                      B(I,J,JJ) = SUMB
                  40 CONTINUE
              41 CONTINUE
          50 CONTINUE                                                          
                                                                       
   60 CONTINUE                                                          
    END SUBROUTINE
    
                           
    SUBROUTINE  MARFIT( X,N,ID,M,KSW,MJ1,MJ2,MJ3,MJ4,ISW,IPR,AIC,SD,      &
                          DIC,AICM,SDM,IM,BI,EI,B,E,EX,C,LMAX,AICS,JNDF,AF,NPR,AAIC )
      use omp_lib
      implicit none
!C                                                                       
!C         MULTI-VARIATE AUTOREGRESSIVE MODEL FITTING                    
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             COPY                                                      
!C             COEF2                                                     
!C             MAICE                                                     
!C             MCOEF                                                     
!C             ADDVAR                                                    
!C             AICCOM                                                    
!C             DELETE                                                    
!C             HUSHL1                                                    
!C             SRCOEF                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          X:     ((M+1)*ID)*((M+1)*ID)  UPPER TRIANGULAR MATRIX,       
!C                 OUTPUT OF SUBROUTINE MREDCT                           
!C          Y:     WORKING AREA (MATRIX)                                 
!C          D:     WORKING AREA                                          
!C          N:     DATA LENGTH                                           
!C          ID:    DIMENSION OF DATA                                     
!C          M:     HIGHEST ORDER OF THE MODELS                           
!C          KSW:   =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR    
!C                 =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSOR
!C          MJ1:   ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM           
!C          MJ2:   ABSOLUTE DIMENSION OF E IN THE MAIN PROGRAM           
!C          MJ3:   ABSOLUTE DIMENSION OF B IN THE MAIN PROGRAM           
!C          MJ4:   ABSOLUTE DIMENSION OF Y IN THE MAIN PROGRAM           
!C!          ISW:   =0  MULTI-VARIATE AUTOREGRESSIVE MODEL IS REQUESTED   
!C                 =1  INSTANTANEOUS RESPONSE MODEL IS REQUESTED         
!C          IPR:   PRINT OUT CONTROL                                     
!C                                                                       
!C       OUTPUTS:                                                        
!C          B:     AR-COEFFICIENT MATRICES                               
!C          E:     INNOVATION VARIANCE MATRIX                            
!C          EX:    RESIDUAL VARIANCES OF INSTANTENEOUS RESPONSE MODELS   
!C          C:     CONSTANT VECTOR                                       
!C          LMAX:  ORDER OF THE MAICE MODEL                              
!C                                                                       

          INTEGER(kind=4) :: N, ID, M, KSW, MJ1, MJ2, MJ3, MJ4, ISW, IPR, LMAX

          INTEGER(kind=4), dimension(MJ4,ID) :: JNDF
#if defined __ICC
          !DIR$ ASSUME_ALIGNED JNDF:64
#endif
          INTEGER(kind=4), dimension(ID)     :: IM,NPR
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IM:64,NPR:64
#endif
          REAL(kind=8), dimension(MJ1,MJ4)   :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(M+1,ID)    :: AIC, SD, DIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AIC:64,SD:64,DIC:64
#endif
          REAL(kind=8), dimension(ID)        :: AICM,SDM,EX,C,AAIC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AICM:64,SDM:64,EX:64,C:64,AAIC:64
#endif
          REAL(kind=8), dimension(ID,ID,M)   :: BI, B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED BI:64,B:64
#endif
          REAL(kind=8), dimension(ID,ID)     :: E,EI
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64,EI:64
#endif
          REAL(kind=8), dimension(MJ4,ID)    :: AF
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AF:64
#endif
          REAL(kind=8) :: AICS
          ! Locals
          INTEGER(kind=4) :: M1,MD0,MD,MD2,NSW,I,II,MSW,JJ,KK,KK1, &
                           I1,IPR2,K0,K01,KX1,K02
          REAL(kind=8)    ::  AICSUM, OSD, OAIC, AICMIN, &
                            SDMIN, SDD, AIC1, AIC2, OSP
          INTEGER(kind=4), dimension(MJ4)      :: IND, JND, KND
          REAL(kind=8),    dimension(MJ4,MJ4)  :: Y 
          REAL(kind=8),    dimension(MJ4)      :: A
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: IND,JND,KND,Y,A
#endif
!C                                     
!C                                                                       
!C         INITIAL SETTING                                               
!C                                                                       
          M1 = M + 1                                                        
          MD0 = M * ID                                                      
          MD = M*ID + KSW                                                   
          MD2 = M1*ID + KSW                                                 
          AICSUM = 0._8                                                   
          LMAX = 0                                                          
          NSW = 0                                                           

          B(1:MJ2,1:MJ2,1:MJ3) = 0._8                                                  
          E(1:MJ2,1:MJ2) = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 30  I=1,MD2                                                    
                IND(I) = I
!cxx   30 JND(I) = I                                                        
                JND(I) = I
       30 CONTINUE
!C                                                                       
          CALL  COPY( X,MD2,0,MD2,MJ1,MJ1,X )                               
!C                                                                       
!C                                                                       
          DO 500     II=1,ID                                                
             MSW = KSW                                                         

             JJ = II - 1                                                       
             KK = MD + JJ                                                      
             KK1 = KK + 1                                                      
!C                                                                       
!C         ADDITION OF REGRESSOR (INSTANTANEOUS RESPONSE FROM II-TH VARIA
!C                                                                       
             CALL  COPY( X,MD2,MD2,0,MJ1,MJ4,Y )                               
             CALL  COPY( X,MD2,MD2,0,MJ1,MJ1,X )                               
!C                                                                       
             IF( II .LE. 1 )  GO TO 40                                         
             J1 = JJ + KSW                                                     
             DO 70  I=1,MD2                                                    
                J = JND(I)                                                        
!cxx   70 IND(J) = I                                                        
                IND(J) = I
         70 CONTINUE
            JND(1) = 1                                                        
            DO 75  I=1,JJ                                                     
               J = MD + I                                                        
               I1 = I + KSW                                                      
!cxx   75 JND(I1) = J                                                       
               JND(I1) = J
         75 CONTINUE
            DO 80  I=1,MD0                                                    
               J = I + KSW                                                       
               I1 = I + KSW + JJ                                                 
!cxx   80 JND(I1) = J                                                       
               JND(I1) = J
         80 CONTINUE
            I1 = JJ + 1                                                       
            DO 85  I=I1,ID                                                    
               J = MD + I                                                        
!cxx   85 JND(J) = J                                                        
              JND(J) = J
           85 CONTINUE
                        
              CALL  HUSHL1( X,MJ1,MD2,MD2,1,IND,JND )                         
                                                                       
              CALL  COPY( X,MD2,0,MD2,MJ1,MJ1,X )                               
!C                                                                       
!C--------------------   FIRST STEP OF AIC MINIMIZATION   ---------------
!C                                                                       
!C          AIC'S OF INITIAL MODELS COMPUTATION                          
!C                                                                       
           40 DO 50  I=1,M1                                                     
                  K = (I-1)*ID + JJ + KSW                                           
                  CALL  AICCOM( X,N,K,KK,MJ1,OSD,OAIC )                             
                                                   
                  SD(I,II) = OSD                                                    
!cxx   50 AIC(I,II) = OAIC                                                  
                  AIC(I,II) = OAIC
50                CONTINUE
#if defined __ICC
!DIR$ VECTOR ALIGNED
                  !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                  
             DO 60  I=1,MD2                                                    
!cxx   60 KND(I) = JND(I)                                                   
                KND(I) = JND(I)
          60 CONTINUE
!C                                                                       
!C         ORDER DETERMINATION BY AIC ( INITIAL ESTMATE )                
!C                                                                       
             IPR2 = IPR - 2                                                    

             CALL MAICE( AIC(1,II),SD(1,II),M,AICMIN,SDMIN,IMIN,DIC(1,II) )
             AICM(II) = AICMIN
             SDM(II) = SDMIN
             IM(II) = IMIN
                                                                       
             K0 = IMIN*ID + JJ + KSW                                           
!C                                                                       
!!C                                                                       
!C         REGRESSION COEFFICIENTS COMPUTATION ( INITIAL ESTIMATE )      
!C                                                                       
            IF( IPR .LT. 3 )  GO TO 90

            IF( IMIN.GT.0 )

            CALL  SRCOEF( X,K0,KK,N,MJ1,JND,A,SDD,AAIC(II) )

         90 CONTINUE                                                          
!C                                                                       
!C                                                                       
!C--------------------   SECOND STEP OF AIC MINIMIZATION   --------------
!C                                                                       
           IMP1 = IMIN + 1                                                   
           DO 230  I1=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
              !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif              
              DO 100  I=1,KK                                                    
!cxx  100 KND(I) = JND(I)                                                   
                 KND(I) = JND(I)
          100 CONTINUE
                                                                       
              CALL  COPY( X,KK1,0,0,MJ1,MJ4,Y )                                 

              AIC1 = AICMIN                                                     
              AIC2 = AICMIN                                                     
              K01 = K0                                                          

              IF( IMIN .GE. M )  GO TO 140                                      
!C                                                                       
!C          CHECK REGRESSOR MADD  < ADD? >                               
!C                                                                       
              DO 110  J1=IMP1,M                                                 
                 MADD = (J1-1)*ID + I1 + KSW                                       
                 IF( IND(MADD) .EQ. 1 )  GO TO 110                                 
                 K = K01 + 1                                                       
                 KX1 = K                                                           
                  
                 CALL  ADDVAR( X,IND,JND,KK,KX1,MADD,MJ1 )                       
                 CALL  AICCOM( X,N,K,KK,MJ1,OSD,OAIC )                             
!C                                                                       
!C         DECISION BY AIC                                               
!C                                                                       
              
                IF( OAIC .GT. AIC1 )  GO TO 120                                   

                AIC1 = OAIC                                                       
                K01 = K01 + 1                                                     
          110 CONTINUE                                                          
              GO TO 140                                                         
          120 K = K - 1                                                         

              IF( J1 .NE. IMP1 )  GO TO 140                                     
              CALL  COPY( Y,KK1,0,0,MJ4,MJ1,X )                                 
              DO 130  J=1,KK                                                    
                      I = IND(J)                                                        
!cxx  130 JND(I) = J                                                        
                      JND(I) = J
           130 CONTINUE
        140 CONTINUE                                                          
!C                                                                       
!C         CHECK REGRESSOR MDEL  < DELETE ? >                            
!C                                                                       
            IF( IMIN .LT. 1 )  GO TO 200                                      
            K02 = K0                                                          
            DO 170  JM1=1,IMIN                                                
               J1 = IMIN - JM1 + 1                                               
               MDEL = (J1-1)*ID + I1 + KSW                                       
               K = K02 - 1                                                       
               DO 150  I0=1,MD2                                                  
                  IF( JND(I0) .EQ. MDEL )  GO TO 160                                
           150 CONTINUE                                                          
               GO TO 170                                                         
           160 CONTINUE                                                          
                 
               CALL  DELETE( Y,IND,KND,KK,K02,MDEL,MJ4 )                       
               CALL  AICCOM( Y,N,K,KK,MJ4,OSD,OAIC )                             
!C                                                                       
!C         DECISION BY AIC                                               
!C                                                                       
!cc      IF(IPR.GE.3)  WRITE( 6,7 )   MDEL,OAIC,MDEL,J1,I1                 
               IF( OAIC .GT. AIC2 )  GO TO 180                                   

               AIC2 = OAIC                                                       
               IF( AIC2 .GE. AIC1 )  GO TO 170                                   
               DO 165  I=1,KK                                                    
!cxx  165 JND(I) = KND(I)                                                   
                  JND(I) = KND(I)
           165 CONTINUE
               CALL  COPY( Y,KK1,0,0,MJ4,MJ1,X )                                 
           170 CONTINUE                                                          
               GO TO  200                                                        
           180 K02 = K02 + 1                                                     

           200 CONTINUE                                                          
               AICMIN = DMIN1( AIC1,AIC2 )                                       
!C                                                                       
!C         COMPARISON OF AIC1 AND AIC2                                   
!C                                                                       
              K0 = K01                                                          
              IF( AIC1 .LE. AIC2 )  GO TO 220                                   
              K0 = K02                                                          
          220 CONTINUE                                                          

          230 CONTINUE                                                          
!C                                                                       
!C                                                                       
!C       SECOND ESTIMATE                                                 
!C                                                                       
              IF( IPR .LT. 3 )  GO TO 240                                       

              CALL  SRCOEF( X,K0,KK,N,MJ1,JND,A,SDD,AAIC(II) )
                                 
          240 CONTINUE                                                          
!C                                                                       
!C--------------------   FINAL STEP OF AIC MINIMIZATION   ---------------
!C                                                                       
              IF(KSW.NE.1)  GO TO 280                                           
!C                                                                       
!C          CHECK CONSTANT VECTOR  < DELETE ? >                          
!C                                                                       
              CALL  COPY( X,KK1,0,0,MJ1,MJ4,Y )                                 

              MDEL = 1                                                          
              K = K0-1                                                          
                    
              CALL  DELETE( Y,IND,JND,KK,K0,MDEL,MJ4 )                        
                                                                       
              CALL  AICCOM( Y,N,K,KK,MJ4,OSP,OAIC )                             
                   
              IF(OAIC.GE.AICMIN)  GO TO 250                                     

              AICMIN = OAIC                                                     
              MSW = 0                                                           
              CALL  COPY( Y,KK1,0,0,MJ4,MJ1,X )                                 
              GO TO 270                                                         
                                                                       
          250 K0 = K0+1                                                         

              DO 260  I=1,KK                                                    
                 J = IND(I)                                                        
!cxx  260 JND(J) = I                                                        
                 JND(J) = I
          260 CONTINUE

          270 CONTINUE
          280 CONTINUE                                                          
!C                                                                       
!C         CHECK REGRESSOR MDEL  < DELETE ? >                            
!C                                                                       
             DO 400     I1=1,ID                                                
!C                                                                       
               CALL  COPY( X,KK1,0,0,MJ1,MJ4,Y )                                 

                     DO 330  J0=1,IMP1                                                 
                        J1 = J0 - 1                                                       
                        IF( J1 .EQ. 0 .AND. I1.GE. II )  GO TO 330                        
                        MDEL = (J1-1)*ID + I1 + KSW                                       
                        IF( J1 .EQ. 0 )     MDEL = MD + I1                                
                        DO 310  I=1,MD2                                                   
                           IF( JND(I) .EQ. MDEL )  GO TO 320                                 
                    310 CONTINUE                                                          
                        GO TO 330                                                         
                    320 K = K0 - 1                                                        
                        IF( I .GT. K0 )   GO TO 400                                       
                      
                        CALL  DELETE( Y,IND,JND,KK,K0,MDEL,MJ4 )                        
                                                                       
                        CALL  AICCOM( Y,N,K,KK,MJ4,OSD,OAIC )                             
               
                        IF( OAIC .GE. AICMIN )  GO TO 340                                 

                        AICMIN = OAIC                                                     
                        CALL  COPY( Y,KK1,0,0,MJ4,MJ1,X )                                 
                                                                       
                    330 CONTINUE                                                          
                        GO TO 400                                                         
                                                    
                    340 CONTINUE
                        K0 = K0 + 1                                                       

                        DO 350  I=1,KK                                                    
                            J = IND(I)                                                        
                                                       
                            JND(J) = I
                    350 CONTINUE
                    400 CONTINUE                                                          

                        CALL  SRCOEF( X,K0,KK,N,MJ1,JND,A,SDD,AAIC(II) )
                        NPR(II) = K0
                        DO 450  KK = 1,K0
                           JNDF(KK,II) = JND(KK)
                           AF(KK,II) = A(KK)
                    450 CONTINUE
                                        
                        EX(II) = SDD / DBLE(N)                                          
                        CALL  COEF2( A,K0,ID,II,JND,LMAX,M,KSW,MSW,MJ2,B,C,E )            
                        AICSUM = AICSUM + AICMIN                                          
                        NSW = MAX0( NSW,MSW )                                             
                                                                       
      500 CONTINUE                                                          
                                                                       
                        IF( ISW .EQ. 1 )   RETURN                                         
                  
                        CALL  MCOEF( BI,B,C,EI,E,EX,ID,LMAX,NSW,IPR,MJ2,MJ3 )
                                                                      
                        AICS = AICSUM                                                     
                                                                       
    END SUBROUTINE
                          
    SUBROUTINE  MBYSAR( X,N,M,ID,KSW,MJ1,MJ2,SD1,AIC1,DIC1,         &
                        AICM1,SDMIN1,IMIN1,C,D,A,B,G,H,E,AICB,EK )
      use omp_lib
      implicit none
!C                                                                       
!C     THIS SUBROUTINE PRODUCES MULTI-VARIATE AUTOREGRESSIVE MODELS BY A 
!C     BAYESIAN PROCEDURE USING THE OUTPUT OF SUBROUTINE MREDCT.         
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             COPY                                                      
!C             MAICE                                                     
!C             BAYSWT                                                    
!C             HUSHLD                                                    
!C             HUSHL1                                                    
!C             MARCOF                                                    
!C             MBYSPC                                                    
!C             MPARCO                                                    
!C             MSDCOM                                                    
!C             PRINT3                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C         X:      ((M+1)*ID+KSW)*((M+1)*ID+KSW) TRIANGULAR MATRIX, OUTPU
!C                 SUBROUTINE MREDCT                                     
!C         D:      WORKING AREA                                          
!C         N:      DATA LENGTH                                           
!C         M:      MAXIMUM TIME LAG OF THE MODEL                         
!C         ID:     DIMENSION OF THE OBSERVATION                          
!C         KSW:    =0   CONSTANT TERM IS NOT INCLUDED AS A REGRESSOR     
!C                 =1   CONSTANT TERM IS INCLUDED AS THE FIRST REGRESSOR 
!C         IPR:    PRINT OUT CONTROL                                     
!C         MJ1:    ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM           
!C         MJ2:    ABSOLUTE DIMENSION OF A,B,G,H AND E IN THE MAIN PROGRA
!C                                                                       
!C       OUTPUTS:                                                        
!C         A:      AR-COEFFICIENT MATRICES OF FORWARD MODEL              
!C         B:      AR-COEFFICIENT MATRICES OF BACKWARD MODEL             
!C         G:      PARTIAL AUTOCORRELATION COEFFICIENT MATRICES OF FORWAR
!C         H:      PARTIAL AUTOCORRELATION COEFFICIENT MATRICES OF BACKWA
!C         E:      INNOVATION VARIANCE-COVARIANCE MATRIX                 
!C         AICB:   EQUIVALENT AIC OF THE BAYESIAN (FORWARD) MODEL        
!C         EK:     EQUIVALENT NUMBER OF AUTOREGRESSIVE COEFFICIENTS      
!C                                                                       
                                
          INTEGER(kind=4) :: N, M, ID, KSW, MJ1, MJ2, IMIN1
          REAL(kind=8), dimension(MJ1,(M+1)*ID+KSW) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(M+1) :: SD1, AIC1, DIC1,C
#if defined __ICC
          !DIR$ ASSUME_ALIGNED SD1:64,AIC1:64,DIC1:64,C:64
#endif
          REAL(kind=8), dimension(M) :: D
#if defined __ICC
          !DIR$ ASSUME_ALIGNED D:64
#endif
          REAL(kind=8), dimension(MJ2,MJ2,M) :: A,B,G,H
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64,B:64,G:64,H:64
#endif
          REAL(kind=8), dimension(MJ2,ID) :: E
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64
#endif
          REAL(kind=8) ::  AICM1,SDMIN1,AICB,EK
          !Locals
          INTEGER(kind=4) ::  M1,MD,MD2,MJ4,J0,ISUB,II,K1,K,MDMK,J2,J1,J3
          REAL(kind=8) ::   YY, AICM, SDMIN, OSD   
                            
          INTEGER(kind=4), dimension((M+1)*ID+KSW) :: IND, JND
          REAL(kind=8), dimension(M+1) :: DIC2, AIC, SD 
          REAL(kind=8), dimension((M+1)*ID+KSW,ID) :: Y
#if defined __ICC
          !DIR$ ATTTIBUTES ALIGN : 64 :: IND,JND,DIC2,AIC,SD,Y
#endif
!C
!C                                                                       
!C          ---------------                                              
!C          INITIAL SETTING                                              
!C          ---------------                                              
!C                                                                       
!cc      MJ4 = 100                                                         
          M1 = M + 1                                                        
          MD = M * ID + KSW                                                 
          MD2= M1*ID + KSW                                                  
          MJ4 = MD2

          SD(1:M1)  = 1._8                                                     
          AIC(1:M1) = 0._8 
          CALL  COPY( X,MD2,0,MD2,MJ1,MJ1,X )                               
                                                                      
!C          ------------------------------------------------------------ 
!C          PARTIAL AUTOREGRESSION COEFFICIENT-MATRICES OF FORWARD MODEL 
!C          ------------------------------------------------------------ 
          CALL  MPARCO( X,ID,M,KSW,0,MJ1,MJ2,G,H )                          
       
!C                                                                       
!C          -----------------------------------------------              
!C          AIC COMPUTATION ( FORWARD AND BACKWARD MODELS )              
!C          -----------------------------------------------              
          J0 = MD                                                           
                                              
          ISUB =  70
                                                
       40 DO 61  II=1,M1
             K = (II-1)*ID + KSW                                               
             K1= K+1                                                           
                                                 
             DO 51  J=1,ID
                    JJ = J + J0                                                       
                    DO 50  I=K1,MD2                                                   
                          I1 = I - K                                                        
                                               
                          Y(I1,J) = X(I,JJ)
                 50 CONTINUE
         51 CONTINUE
                                                                       
            MDMK = MD2 - K                                                    
                               
            CALL  HUSHLD( Y,MJ4,MDMK,ID )                                   
            !DIR$ VECTOR ALIGNED
            !DIR$ SIMD
            DO 60  I=1,ID                                                     
                 YY = Y(I,I)**2 / N                                                
                 SD(II)  = SD(II) * YY                                             
                   
                 AIC(II) = AIC(II) + N*DLOG( YY ) + 2._8*(K+1)
         60 CONTINUE
       61 CONTINUE
                                       
          IF( ISUB .EQ. 70 ) GO TO 70
          IF( ISUB .EQ. 100 ) GO TO 100

70        CALL  MAICE( AIC,SD,M,AICM,SDMIN,IMIN,DIC1 )
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))          
          DO 71  I=1,M1
                 AIC1(I) = AIC(I)
                 SD1(I) = SD(I)
       71 CONTINUE
          AICM1 = AICM
          SDMIN1 = SDMIN
          IMIN1 = IMIN
!C          -------------------------------------------------------------
!C          PARTIAL AUTOREGRESSION COEFFICIENT-MATRICES OF BACKWARD MODEL
!C          -------------------------------------------------------------
          DO 80  I=1,MD2                                                    
!cxx   80 IND(I) = I                                                        
             IND(I) = I 
       80 CONTINUE
          JND(1) = 1                                                        
          J2 = KSW                                                          
                                                 
          DO 86  JJ=2,M
             J = (M-JJ)*ID                                                     
             DO 85  I=1,ID                                                     
                J2 = J2 + 1                                                       
                J1 = J +I                                                         
                                                    
                JND(J2) = J1
         85 CONTINUE
      86 CONTINUE
         DO 90  I=1,ID                                                     
            J2 = J2 + 1                                                       
            J1 = MD + I                                                       
            JND(J2) = J1                                                      
            J3 = J2 + ID                                                      
            J1 = J1 - ID                                                      
!cxx   90 JND(J3) = J1                                                      
           JND(J3) = J1
      90 CONTINUE
                        
           CALL  HUSHL1( X,MJ1,MD2,MD2,1,IND,JND )                         
           CALL  MPARCO( X,ID,M,KSW,1,MJ1,MJ2,G,H )                          
        
!C                                                                       
!C          ---------------                                              
!C          AIC COMPUTATION                                              
!C          ---------------                                              
          J0 = MD - ID                                                      
                                            
          ISUB = 100
          GO TO 40
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                       
     100  DO 110  I=1,M1                                                    
            SD(I) = DSQRT( SD(I) )                                            
                                           
            AIC(I) = AIC(I) / 2
     110  CONTINUE

          CALL  MAICE( AIC,SD,M,AICM,SDMIN,IMIN,DIC2 )
!C                                                                       
!C          ----------------------------                                 
!C          BAYESIAN WEIGHTS COMPUTATION                                 
!C          ----------------------------                                 
!C                                                                       
          CALL  BAYSWT( AIC,AICM,M,0,C )                                    
!C                                                                       
!C          -------------------------------------------------            
!C          PARTIAL AUTOREGRESSION MATRICES OF BAYESIAN MODEL            
!C          -------------------------------------------------            
!C                                                                       
!cxx      CALL  MBYSPC( G,H,C,D,M,ID,IPR,MJ2 )                              
          CALL  MBYSPC( G,H,C,D,M,ID,MJ2 )                              
                                                                      
!C          -----------------------------------------------------        
!C          AUTOREGRESSION COEFFICIENT MATRICES OF BAYESIAN MODEL        
!C          -----------------------------------------------------        
!C                                                                       
!cxx  115 CALL  MARCOF( G,H,ID,M,MJ2,A,B )                                  
          CALL  MARCOF( G,H,ID,M,MJ2,A,B )                                  
           
!C          -------------------------                                    
!C          AIC OF THE BAYESIAN MODEL                                    
!C          -------------------------                                    
          EK = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:EK)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:EK)
#endif
          DO 120  I=1,M                                                     
                                             
             EK = EK + D(I)**2
      120 CONTINUE
          EK = EK*(ID**2)                                                   
          CALL  COPY( X,MD2,MD2,0,MJ1,MJ1,X )                               
       
          CALL  MSDCOM( X,A,N,M,ID,KSW,MJ1,E,OSD )          
                                                                       
          AICB = N*DLOG( OSD ) + 2._dp*EK + 2._dp*KSW*ID + ID*(ID+1)          
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: MBYSPC
#endif
    SUBROUTINE  MBYSPC( G,H,C,D,M,ID,MJ2 )
      use omp_lib
      implicit none
        
!C                                                                       
!C     THIS SUBROUTINE PRODUCES PARTIAL AUTOREGRESSION COEFFICIENTS G(I),
!C     (I=1,K) OF THE MULTI-VARIATE AUTOREGRESSIVE MODEL.                
!C                                                                       
!C       INPUTS:                                                         
!C          G:      LEAST SQUARES ESTIMATES OF "PARCOR'S" (FORWARD MODEL)
!C          H:      LEAST SQUARES ESTIMATES OF "PARCOR'S" (BACKWARD MODEL
!C          C(I+1): BAYESIAN WEIGHT OF EACH ORDER  (I=0,...,M)           
!C          M:      MAXIMUM TIME LAG OF THE MODEL                        
!C          ID:     DIMENSION OF THE PROCESS                             
!C          IPR:    PRINT OUT CONTROL                                    
!C          MJ2:    ABSOLUTE DIMENSION OF G AND H                        
!C!                                                                       
!C       OUTPUTS:                                                        
!C          G:      BAYESIAN ESTIMATES OF "PARCOR'S" (FORWARD MODEL)     
!C          H:      BAYESIAN ESTIMATES OF "PARCOR'S" (BACKWARD MODEL)    
!C          D:      INTEGRATED BAYESIAN WEIGHT EACH ORDER (I=1,...,M)    
!C                                                                       
         
          INTEGER(kind=4) :: M, ID, MJ2 
          REAL(kind=8), dimension(MJ2,MJ2,M) ::  G, H
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64,H:64
#endif
          REAL(kind=8), dimension(M+1)       ::  C
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64
#endif
          REAL(kind=8), dimension(M)         ::  D
#if defined __ICC
          !DIR$ ASSUME_ALIGNED D:64
#endif
          ! Locala
          INTEGER(kind=4) :: M1,I,J,II
!C                                                                       
!C          INTEGRATED BAYESIAN WEIGHT                                   
!C                                                                       
          M1 = M+1                                                          
          D(M) = C(M1)                                                      
          DO 10 I=2,M                                                       
             J = M1 - I                                                        
!cxx   10 D(J) = D(J+1) + C(J+1)                                            
             D(J) = D(J+1) + C(J+1)
       10 CONTINUE
                                                  
!C                                                                       
!C          PARTIAL CORRELATION                                          
!C                                                                       
                                                  
          DO 42  II=1,M
             DO 41  J=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
                DO 40  I=1,ID                                                     
                       G(I,J,II) = G(I,J,II)*D(II)                                       
!cxx   40 H(I,J,II) = H(I,J,II)*D(II)                                       
                       H(I,J,II) = H(I,J,II)*D(II)
             40 CONTINUE
          41 CONTINUE
       42 CONTINUE
    END SUBROUTINE
    
       
    SUBROUTINE  MCOEF( BI,B,C,EI,E,EX,ID,LMAX,KSW,IPR,MJ2,MJ3 )
      use omp_lib
      implicit none
       
!C                                                                       
!C     THIS SUBROUTINE COMPUTES AND PRINTS OUT THE COEFFICIENT MATRICES O
!C     MULTI-VARIATE AUTOREGRESSIVE MODEL FROM THE COEFFICIENT MATRICES O
!C     THE MODEL WITH INSTANTANEOUS RESPONSE                             
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             INVDET                                                    
!C             PRINT3                                                    
!C             TRIINV                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          B:     REGRESSION COEFFICIENTS MATRIX                        
!C          C:     CONSTANT VECTOR                                       
!C          E:     COEFFICIENT OF QUICK RESPONSE                         
!C          EX:    RESIDUAL VARIANCES OF ORTHOGONALIZED MODEL            
!C          ID:    DIMENSION OF THE OBSERVATION                          
!C          LMAX:  HIGHEST ORDER OF THE AR-MODEL                         
!C          KSW:   =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR    
!C                 =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSOR
!C          IPR:   PRINT OUT CONTROL                                     
!C          MJ2:   ABSOLUTE DIMENSION OF B AND E                         
!C          MJ3:   ABSOLUTE DIMENSION OF B                               
!C       OUTPUTS:                                                        
!C          B:     AR-COEFFICIENT MATRIX                                 
!C          C:     CONSTANT VECTOR                                       
!C          E:     INNOVATION COVARIANCE MATRIX                          
!C                                                                       

          INTEGER(kind=4) :: ID, LMAX, KSW, IPR, MJ2, MJ3 
          REAL(kind=8), dimension(ID,ID,LMAX) :: BI
#if defined __ICC 
          !DIR$ ASSUME_ALIGNED BI:64
#endif
          REAL(kind=8), dimension(MJ2,MJ2,MJ3) :: B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED B:64
#endif
          REAL(kind=8), dimension(ID) :: C,EX
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64,EX:64
#endif
          REAL(kind=8), dimension(ID,ID) ::  EI
#if defined __ICC
          !DIR$ ASSUME_ALIGNED EI:64
#endif
          REAL(kind=8), dimension(MJ2,ID) :: E
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64
#endif
          ! Locals
          INTEGER(kind=4) :: MJ5,I,J,II
          REAL(kind=8) ::   SUM, EDET
          REAL(kind=8), dimension(ID)    :: C1 
          REAL(kind=8), dimension(ID,ID) ::  EE 
!C
!C    INPUT  E ---> EI
!C    INPUT  B ---> BI
                                                         
          MJ5 = ID
                                                                       
          IF(IPR.LE.1)  GO TO 300                                           
                                                   
          DO 311  I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8)
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                DO 310  J=1,ID
!cxx  310 EI(I,J) = E(I,J)
                   EI(I,J) = E(I,J)
            310 CONTINUE
      311 CONTINUE
                                                  
          DO  330  II=1,LMAX                                             

             DO  321     I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
                    DO  320     J=1,ID
!cxx  320 BI(I,J,II) = B(I,J,II)
                         BI(I,J,II) = B(I,J,II)
                320 CONTINUE
          321 CONTINUE
                                                 
      330 CONTINUE
                          
      300 CONTINUE                                                          
                                                                       
          IF( KSW .NE. 1 )     GO TO 375                                    
                                    
          DO  336   I=1,ID
                 DO  335  J=1,ID                                                
                    SUM = E(I,J)
#if defined __ICC
!DIR$ VECTOR ALIGNED
                    !DIR$ SIMD REDUCTION(-:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(-:SUM)
#endif                    
                           DO  325  II=1,LMAX                                             
!cxx  325 SUM = SUM - B(I,J,II)                                             
                                   SUM = SUM - B(I,J,II)
                       325 CONTINUE
!cxx  335 EE(I,J) = SUM
                           EE(I,J) = SUM
                335 CONTINUE
      336 CONTINUE
          CALL  INVDET( EE,EDET,ID,MJ5 )                                    
          DO  355 I=1,ID                                                
             SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif   
               DO  345  J=1,ID                                                
!cxx  345 SUM = SUM + EE(I,J)*C(J)                                          
                   SUM = SUM + EE(I,J)*C(J)
           345 CONTINUE
                                                      
               C1(I) = SUM
      355 CONTINUE
          DO  365   I=1,ID                                                
                                                    
              C(I) = C1(I)
      365 CONTINUE
                                                                       
      375 CONTINUE                                                          
          CALL  TRIINV( E,ID,MJ2,MJ5,EE )                                   

          DO  362   II=1,LMAX
               DO  351  I=1,ID
                    DO  350  J=1,ID                                                
                       SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                       !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif                          
                           DO  340  JJ=1,I                                                
!cxx  340 SUM = SUM + EE(I,JJ)*B(JJ,J,II)
                               SUM = SUM + EE(I,JJ)*B(JJ,J,II)
                       340 CONTINUE
!cxx  350 E(I,J) = SUM
                           E(I,J) = SUM
                  350 CONTINUE
           351 CONTINUE
!cxx      DO  360     I=1,ID                                                
                           DO  361  I=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
                              !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD 
#endif   
                              
                    DO  360  J=1,ID                                                
!cxx  360 B(I,J,II) = E(I,J)                                                
                        B(I,J,II) = E(I,J)
                360 CONTINUE
          361 CONTINUE
      362 CONTINUE
          DO  370  I=1,ID                                                
             SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif                
               DO  371     J=1,ID
                                     
                    SUM = SUM + EE(I,J)*C(J)
           371 CONTINUE
!cxx  370 C1(I) = SUM                                                       
               C1(I) = SUM
      370 CONTINUE
          DO  372 I=1,ID                                                

              C(I) = C1(I)
      372 CONTINUE
                                           
          DO  381 I=1,ID
              DO  380  J=1,I                                                 
                 SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif   
                        DO  385  II=1,J                                                
             
                              SUM = SUM + EE(I,II) * EE(J,II)*EX(II)
                     385 CONTINUE
                         E(I,J) = SUM                                                      
                                                     
                         E(J,I) = SUM
          380 CONTINUE
      381 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  MPARCO( X,ID,M,KSW,IFG,MJ1,MJ3,G,H ) 
        implicit none
!C                                                                       
!C     THIS SUBROUTINE PRODUCES LEAST SQUARES ESTIMATES OF PARTIAL       
!C     AUTOREGRESSION COEFFICIENT MATRICES OF FORWARD AND BACKWARD       
!C     MULTI-DIMENSIONAL AUTOREGRESSIVE MODEL                            
!C!       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             SOLVE                                                     
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          X:      ((M+1)*ID+KSW)*((M+1)*ID+KSW) MATRIX                 
!C          ID:     DIMENSION OF OBSERVATION                             
!C          M:      MAXIMUM TIME LAG OF THE MODEL                        
!C          KSW:    =0  CONSTANT TERM IS NOT INCLUDED AS A REGRESSOR     
!C                  =1  CONSTANT TERM IS INCLUDED AS THE FIRST REGRESSOR 
!C          IFG:    =0   TO REQUEST THE COEFFICIENTS OF FORWARD MODEL    
!C                  =1   TO REQUEST THE COEFFICIENTS OF BACKWARD MODEL   
!C          MJ1:    ABSOLUTE DIMENSION OF X                              
!C          MJ3:    ABSOLUTE DIMENSION OF G AND H                        
!C                                                                       
!C       OUTPUTS:                                                        
!C          G:      AR-COEFFICIENT MATRICES OF FORWARD MODEL             
!C          H:      AR-COEFFICIENT MATRICES OF BACKWARD MODEL            
!C                                                                       

          INTEGER(kind=4) :: ID, M, KSW, IFG, MJ1, MJ3
          REAL(kind=8), dimension(MJ1,(M+1)*ID+KSW) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(MJ3,MJ3,M) :: G, H
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64,H:64
#endif
          ! Locals
          INTEGER(kind=4) :: MJ2, MD,I0,II,J,I,J1,J2,I1,MM1,JS0,J0
          REAL(kind=8), dimension(ID,ID) :: C, R
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: C,R
#endif
          MJ2 = ID
          IF( IFG .NE. 0 )     GO TO 30                                     
          MD = ID*M + KSW                                                   
          DO  20 II=1,M                                                 
                 I0 = (II-1)*ID + KSW                                              
                                       
                  DO  11  J=1,ID
                      J1 = J + I0                                                       
                      J2 = J + MD                                                       
                         DO  10 I=1,ID                                                 
                               I1 = I + I0                                                       
                               C(I,J) = X(I1,J1)                                                 

                               R(I,J) = X(I1,J2)
                      10 CONTINUE
               11 CONTINUE
                             
                  CALL  SOLVE( C,R,ID,II,MJ2,MJ3,G )
       20 CONTINUE
          GO TO 60                                                          
                                                                       
       30 MM1 = M - 1                                                       
          JS0 = MM1*ID + KSW                                                
          DO  50  II=1,M                                                 
               I0 = (II-1)*ID + KSW                                              
               J0 = (MM1-II)*ID + KSW                                            
               IF( II .EQ. M )     J0 = M*ID + KSW                               

               DO  41 J=1,ID
                      J1 = J0 + J                                                       
                      J2 = JS0 + J                                                      
                        DO  40 I=1,ID                                                 
                               I1 = I0 + I                                                       
                               C(I,J) = X(I1,J1)                                                 
                                               
                               R(I,J) = X(I1,J2)
                     40 CONTINUE
          41 CONTINUE
                              
             CALL  SOLVE( C,R,ID,II,MJ2,MJ3,H )
       50 CONTINUE
                                                                       
   60 RETURN                                                            
    END  SUBROUTINE
    
                         
    SUBROUTINE MRDATA( ZS,Z,N,ID,C,ZMEAN,ZVARI )
      use omp_lib
      implicit none
!C                                                                       
!C         +-----------------------------------------+                   
!C         ! ORIGINAL DATA LOADING AND MEAN DELETION !                   
!C         +-----------------------------------------+                   
!C                                                                       
!C     THIS SUBROUTINE IS USED FOR THE LOADING OF ORIGINAL DATA AND      
!C     DELETION OF THE MEAN VALUES.  THE DATA IS LOADED THROUGH THE DEVIC
!C     SPECIFIED BY MT.  EACH DATA SET IS COMPOSED OF TITLE, DATA LENGTH,
!C     CALIBRATIONS OF DATA, DATA FORMAT AND THE ORIGINAL DATA.          
!C                                                                       
!C       INPUTS:                                                         
!C          MT:      INPUT DEVICE SPECIFICATION                          
!C          MJ:      ABSOLUTE DIMENSION OF Z                             
!C                                                                       
!C          TITLE:   SPECIFICATION OF DATA                               
!C          N:       DATA LENGTH                                         
!C          ID:      DIMENSION OF OBSERVATION                            
!C          IFM:     CONTROL FOR INPUT                                   
!C          FORM:    INPUT DATA FORMAT SPECIFICATION                     
!C          C(I):    CALIBRATION OF CHANNEL I (I=1,ID)                   
!C          Z:       ORIGINAL DATA; Z(K,I) (K=1,N) REPRESENTS THE I-TH CH
!C                   RECORD                                              
!C                                                                       
!C       OUTPUTS:                                                        
!C          Z:       ORIGINAL DATA ( MEAN DELETED )                      
!C          N:       DATA LENGTH                                         
!C          ID:      DIMENSION OF OBSERVATION                            
!C                                                                       

          INTEGER(kind=4) :: N, ID
          REAL(kind=8), dimension(N,ID) :: ZS, Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED ZS:64,Z:64
#endif
          REAL(kind=8), dimension(ID)   :: C, ZMEAN, ZVARI
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64,ZMEAN:64,ZVARI:64
#endif
          ! Locals
          INTEGER(kind=4) :: I,J
          REAL(kind=8) :: CC, SUM
                                                       
                                            
          DO  76  J=1,ID
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif
              DO  75     I=1,N
!cxx   75 Z(I,J) = ZS(I,J)
                  Z(I,J) = ZS(I,J)
           75 CONTINUE
       76 CONTINUE
                                            
          DO  86  J=1,ID
             CC = C(J)
#if defined __ICC
 !DIR$ VECTOR ALIGNED
             !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif             
                   DO  85  I=1,N                                                  
                                           
                      Z(I,J) = Z(I,J) * CC
                85 CONTINUE
       86 CONTINUE
                                               
          DO  120 J=1,ID                                                
!C                                                                       
!C     MEAN DELETION   AND  VARIANCE COMPUTATION                         
!C                                                                       
             SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
             
#endif     
                   DO  90 I=1,N                                                  
!cxx   90 SUM = SUM + Z(I,J)                                                
                        SUM = SUM + Z(I,J)
                90 CONTINUE
                                      
                        ZMEAN(J) = SUM / DBLE(N)
#if defined __ICC
!DIR$ VECTOR ALIGNED
                        !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
             !$OMP SIMD
#endif     
                   DO  100 I=1,N                                                 

                           Z(I,J) = Z(I,J) - ZMEAN(J)
               100 CONTINUE
                                                                       
                           SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                           !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
             
#endif                           
                   DO  110 I=1,N                                                 
                                       
                       SUM = SUM + Z(I,J)*Z(I,J)
               110 CONTINUE
                                         
                   ZVARI(J) = SUM / DBLE(N)
!C                                                                       
!C         MEAN AND VARIANCE PRINT OUT                                   
!C                                                                       
                        
      120 CONTINUE
                                         
    END  SUBROUTINE
    
         
    SUBROUTINE  MREDCT( Z,NMK,N0,LAG,ID,MJ,MJ1,KSW,X ) 
          implicit none
!C                                                                       
!C         +-------------------------+                                   
!C         ! HOUSEHOLDER'S REDUCTION !                                   
!C         +-------------------------+                                   
!C                                                                       
!C     THIS SUBROUTINE FIRST SETS UP DATA MATRIX X BY AUGMENTING         
!C     SUCCESSIVELY SHIFTED ORIGINAL DATA MATRIX Z AND THEN TRANSFORMS X 
!C     INTO TRIANGULAR FORM BY HOUSEHOLDER TRANSFORMATION.               
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             HUSHLD                                                    
!C             MSETX1                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA MATRIX                                 
!C          D:      WORKING AREA                                         
!C          NMK:    DIMENSION OF THE VECTOR OF REGRESSAND (Z(N0+K-KSW+1),
!C                  ...,Z(N0+K-KSW+NMK) (J=1,ID)                         
!C          N0:     INDEX OF THE END POINT OF DISCARDED FORMER OBSERVATIO
!C          LAG:    HIGHEST TIME LAG OF THE MODEL                        
!C          ID:     DIMENSION OF OBSERVATIONS                            
!C          MJ:     ABSOLUTE DIMENSION OF Z                              
!C          MJ1:    ABSOLUTE DIMENSION OF X                              
!C          KSW:    =0   CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR  
!C                  =1   CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESS
!C                                                                       
!C         OUTPUT:                                                       
!C          X:      REDUCED MATRIX ( UPPER TRIANGULAR FORM )             
!C                                                                       

          INTEGER(kind=4) :: NMK, N0, LAG, ID, MJ, MJ1, KSW
          REAL(kind=8), dimension(MJ,ID) :: Z
#if defined __ICC
          !DIR$ ASUME_ALIGNED Z:64
#endif
          REAL(kind=8), dimension(MJ1,(LAG+1)*ID+KSW) ::  X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(kind=4) :: L,K1,KD1,N1,LK,N2
          L = MIN0( NMK,MJ1 )                                               
          K1 = LAG + 1                                                      
          KD1 = K1*ID + KSW                                                 
          N1 = L                                                            
!C                                                                       
!C          +-----------------+                                        +-
!C          ! MATRIX X SET UP !                                        ! 
!C          +-----------------+                                        +-
!C                                                                       
          CALL  MSETX1( Z,N0,L,LAG,ID,MJ,MJ1,0,KSW,X )                      
!C                                                                       
!C          +----------------------------+                             +-
!C          ! HOUSEHOLDER TRANSFORMATION !                             ! 
!C          +----------------------------+                             +-
!C                                                                       
                                  
          CALL  HUSHLD( X,MJ1,L,KD1 )                                     
                                                                       
          IF( N1 .GE. NMK )     RETURN                                      
!C                                                           +------->>--
!C                                                           !           
      100 L = MIN0( NMK-N1,MJ1-KD1 )                                        
!C                                                           !           
          LK = L + KD1                                                      
          N2 = N0 + N1                                                      
!C                                                           !           
!C          +-----------------+                              !         +-
!C          ! MATRIX X SET UP !                              !         ! 
!C          +-----------------+                              !         +-
!C                                                           !           
          CALL  MSETX1( Z,N2,L,LAG,ID,MJ,MJ1,1,KSW,X )                      
!C                                                           !           
!C          +----------------------------+                   !         +-
!C          ! HOUSEHOLDER TRANSFORMATION !                   !         ! 
!C          +----------------------------+                   !         +-
!C                                                           !           
                                  
          CALL  HUSHLD( X,MJ1,LK,KD1 )                                    
                                                                     !+-
          N1 = N1 + L                                                       
          IF( N1 .LT. NMK )     GO TO 100                                   
    END SUBROUTINE
    
    SUBROUTINE  MSDCOM( X,A,N,M,ID,KSW,MJ,E,SD )
      use omp_lib
      implicit none
        
!C                                                                       
!C     THIS SUBROUTINE PRODUCES THE ONE-STEP AHEAD PREDICTION ERROR VARIA
!C     MATRIX AND ITS DETERMINANT FOR THE MULTI-VARIATE AUTOREGRESSIVE MO
!C     DEFINED BY THE AR-COEFFICIENT MATRICES GIVEN BY A.                
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             HUSHLD                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          X:    ((M+1)*ID+KSW)*((M+1)*ID+KSW) TRIANGULAR MATRIX        
!C          A:    AR-COEFFICIENT MATRICES                                
!C          Y:    WORKING AREA                                           
!C          D:    WORKING AREA                                           
!C          N:    DATA LENGTH                                            
!C          M:    ORDER OF THE AR-MODEL                                  
!C          ID:   DIMENSION OF THE PROCESS                               
!C          KSW:  =0   CONSTANT TERM IS NOT INCLUDED AS A REGRESSOR      
!C                =1   CONSTANT TERM IS INCLUDED AS THE FIRST REGRESSOR  
!C          IPR:  PRINT OUT CONTROL                                      
!C          MJ:   ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM            
!C          MJ2:  ABSOLUTE DIMENSION OF A AND E IN THE MAIN PROGRAM      
!C          MJ4:  ABSOLUTE DIMENSION OF Y IN THE MAIN PROGRAM            
!C                                                                       
!C       OUTPUTS:                                                        
!C          E:    ONE STEP AHEAD PREDICTION ERROR VARIANCE MATRIX        
!C          SD:   DETERMINANT OF SD                                      
!C                                                                       

          INTEGER(kind=4) :: N, M, ID, KSW, MJ
          REAL(kind=8), dimension(MJ,(M+1)*ID+KSW) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(ID,ID,M) ::  A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          REAL(kind=8), dimension(ID,ID)   :: E
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64
#endif
          REAL(kind=8) :: SD
          ! Locals
          INTEGER(kind=4) :: MD,M1D,II,II,I0,J0,J1,I1 
          REAL(kind=8) :: SUM
          REAL(kind=8), dimension((M+1)*ID,ID) :: Y
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: Y
#endif                                                                      
          MD = M * ID                                                       
          M1D= MD + ID                                                      
          DO 30  JJ=1,ID                                                    
                DO 20  II=1,MD                                                    
                      I0 = II + KSW                                                     
                      SUM = 0._8                                                      
                        DO 10  J=II,MD                                                    
                               J0 = J + KSW                                                      
                               M0 = (J-1)/ID + 1                                                 
                               J1 = J - (M0-1)*ID                                                
!cxx   10 SUM = SUM + X(I0,J0)*A(JJ,J1,M0)                                  
                               SUM = SUM + X(I0,J0)*A(JJ,J1,M0)
                    10 CONTINUE
                      J0 = MD + KSW + JJ                                                
!cxx   20 Y(II,JJ) = X(I0,J0) - SUM                                         
                      Y(II,JJ) = X(I0,J0) - SUM
            20 CONTINUE
       30 CONTINUE                                                          
                                                 
          DO 41  J=1,ID
                 J0 = MD + KSW + J                                                 
                 DO 40  I=1,ID                                                     
                        I0 = MD + KSW + I                                                 
                        I1 = MD + I                                                       
!cxx   40 Y(I1,J) = X(I0,J0)                                                
                        Y(I1,J) = X(I0,J0)
              40 CONTINUE
       41 CONTINUE
                                  
          CALL  HUSHLD( Y,M1D,M1D,ID )                                    
          SD = 1._8
#if defined __ICC
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(*:SD)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(*:SD)
#endif          
          DO 50  I=1,ID                                                     
!cxx   50 SD = SD * (Y(I,I)**2)/N                                           
             SD = SD * (Y(I,I)**2)/N
       50 CONTINUE
                                                
          DO 71  I=1,ID
              DO 70  J=1,ID                                                     
                 SUM = 0._8
#if defined __ICC
 !DIR$ VECTOR ALIGNED
                 !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif                      
                       DO 60  II=1,ID                                                    
                                
                              SUM = SUM + Y(II,I)*Y(II,J)
                    60 CONTINUE
                                                 
                       E(I,J) = SUM / N
           70 CONTINUE
       71 CONTINUE
                                          
    END  SUBROUTINE
      

    SUBROUTINE  MSETX1( Z,N0,L,LAG,ID,MJ,MJ1,JSW,KSW,X )   
         implicit none
!C                                                                       
!C          +-----------------+                                          
!C          ! MATRIX X SET UP !                                          
!C          +-----------------+                                          
!C                                                                       
!C     THIS SUBROUTINE PREPARES DATA MATRIX X FROM DATA MATRIX Z(I,J) (I=
!C     ,N0+K-KSW+L;J=1,...,ID) FOR AUTOREGRESSIVE MODEL FITTING.  X IS TH
!C     AS INPUT TO SUBROUTINE HUSHLD.                                    
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA MATRIX                                 
!C          N0:     INDEX OF THE END POINT OF DISCARDED FORMER OBSERVATIO
!C          L:      DIMENSION OF THE VECTOR OF NEW OBSERVATIONS          
!C          LAG:    MAXIMUM TIME LAG OF THE MODEL                        
!C          ID:     DIMENSION OF OBSERVATION                             
!C          MJ:     ABSOLUTE DIMENSION OF Z                              
!C          MJ1:    ABSOLUTE DIMENSION OF X                              
!C          JSW:   =0   TO CONSTRUCT INITIAL L*(LAG+1) DATA MATRIX       
!C                 =1   TO AUGMENT ORIGINAL (LAG+1)*(LAG+1) MATRIX X BY A
!C                      L*(LAG+1) DATA MATRIX OF ADDTIONAL OBSERVATIONS  
!C          KSW:   =0   CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR   
!C                 =1   CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSO
!C                                                                       
!C       OUTPUT:                                                         
!C          X:      L*(LAG+1) MATRIX            IF  JSW = 0              
!C                  (LAG+1+L)*(LAG+1) MATRIX    IF  JSW = 1              
!C                                                                       

          INTEGER(kind=4) :: N0, L, LAG, ID, MJ, MJ1, JSW, KSW
          REAL(kind=8), dimension(MJ,ID) :: Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64
#endif
          REAL(kind=8), dimension(MJ1,(LAG+1)*ID+KSW) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(kind=4) :: KD,KD1,I0,II,I1,I2,J,J2,J1
                                                                     
          KD = LAG*ID + KSW                                                 
          KD1 = (LAG+1)*ID + KSW                                            
          I0 = 0                                                            
          IF( JSW .EQ. 1 )     I0 = KD1                                     
                                             
          DO  31 II=1,L
                 I1 = N0 + LAG + II                                                
                 I2 = I0 + II                                                      
                 DO  10  J=1,ID                                                 
                         J2 = KD + J                                                       
!cxx   10 X(I2,J2) = Z(I1,J)                                                
                          X(I2,J2) = Z(I1,J)
             10 CONTINUE
                DO  30  JJ=1,LAG                                               
                        I1 = I1 - 1                                                       
                        J1 = (JJ-1)*ID + KSW                                              
                        DO  20  J=1,ID                                                 
                                J2 = J1 + J                                                       
!cxx   20 X(I2,J2) = Z(I1,J)                                                
                                X(I2,J2) = Z(I1,J)
                     20 CONTINUE
            30 CONTINUE
       31 CONTINUE                                                          
!C                                                                       
          IF( KSW .NE. 1 )     RETURN                                       
          DO  40 II=1,L                                                 
                 I = II + I0                                                       
!cxx   40 X(I,1) = 1.D0                                                     
                 X(I,1) = 1.0_8
       40 CONTINUE
!C                                                                       
    END SUBROUTINE
    
                      
    SUBROUTINE  NRASPE( SGME2,A,B,L,K,H,SXX )
      use omp_lib
      implicit none
       
!C     THIS SUBROUTINE COMPUTES POWER SPECTRUM OF AN AR-MA PROCESS       
!C     X(N)=A(1)X(N-1)+...+A(L)X(N-L)+E(N)+B(1)E(N-1)+...+B(K)E(N-K),    
!C     WHERE E(N) IS A WHITE NOISE WITH ZERO MEAN AND VARIANCE EQUAL TO  
!C     SGME2.  OUTPUTS PXX(I) ARE GIVEN AT FREQUENCIES I/(2*H)           
!C     I=0,1,...,H.                                                      
!C     REQUIRED INPUTS ARE;                                              
!C     L,K,H,SGME2,(A(I),I=1,L), AND (B(I),I=1,K).                       
!C        SGME2: NOISE VARIANCE                                          
!C        A: AR-COEFFICIENTS                                             
!C        B: MA-COEFFICIENTS                                             
!C        L: ORDER OF AR                                                 
!C        K: ORDER OF MA                                                 
!C        N: LENGTH OF DATA                                              
!C        H: NUMBER OF SEGMENTS OF FREQUENCY AXIS                        
!C     0 IS ALLOWABLE AS L AND/OR K.                                     
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             FOUGER                                                    
!C             SPEGRH                                                    
!C       ----------------------------------------------------------------

          INTEGER(kind=4) :: L, K, H                                                       
          REAL(kind=8) :: SGME2 
          REAL(kind=8), dimension(L)   :: A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          REAL(kind=8), dimension(K)   ::  B
#if defined __ICC
          !DIR$ ASSUME_ALIGNED B:64
#endif
          REAL(kind=8), dimension(H+1) :: SXX
#if defined __ICC
          !DIR$ ASSUME_ALIGNED SXX:64
#endif
          INTEGER(kind=4) :: H1,K1,L1,I1,I,J
          REAL(kind=8), dimension(L+K+1) :: G 
          REAL(kind=8), dimension(H+1)   ::  GR1, GI1, GR2, GI2, PXX
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: GR1,GI1,GR2,GI2,PXX
#endif
!cxx  310 H1=H+1                                                            
          H1=H+1                                                            
          L1=L+1                                                            
          K1=K+1                                                            
          G(1)=1.0_8                                                        
          IF(L.LE.0) GO TO 400                                              
          DO 10 I=1,L                                                       
                I1=I+1                                                            
!cxx   10 G(I1)=-A(I)                                                       
                G(I1)=-A(I)
       10 CONTINUE
      400 CALL FOUGER(G,L1,GR1,GI1,H1)                                      
          G(1)=1.0_8                                                         
          IF(K.LE.0) GO TO 410                                              
          DO 20 I=1,K                                                       
                I1=I+1                                                            
!cxx   20 G(I1)=B(I)
                G(I1)=B(I)
       20 CONTINUE
410             CALL FOUGER(G,K1,GR2,GI2,H1)
#if defined __ICC
!DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
          DO 30 I=1,H1                                                      
!cxx   30 PXX(I)=(GR2(I)**2+GI2(I)**2)/(GR1(I)**2+GI1(I)**2)*SGME2          
                PXX(I)=(GR2(I)**2+GI2(I)**2)/(GR1(I)**2+GI1(I)**2)*SGME2
30              CONTINUE
#if defined __ICC
!DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                !$OMP SIMD
#endif
          DO 520 I=1,H1
!cxx  520 SXX(I)=DLOG10(PXX(I))                                             
                SXX(I)=DLOG10(PXX(I))
      520 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE  PARCOR( AR,K,PAC ) 
      use omp_lib
      implicit none
!C                                                                       
!C  ...  TRANSFORMATION FROM AR COEFFICIENTS TO PARCOR                   
!C                                                                       
!C       INPUTS:                                                         
!C          AR:   VECTOR OF AR-COEFFICIENTS                              
!C          K:    ORDER OF THE MODEL                                     
!C       OUTPUT:                                                         
!C          PAC:  VECTOR OF PARTIAL AUTOCORRELATIONS                     
!C                                                                       

          INTEGER(kind=4) :: K
          REAL(kind=8), dimension(K)  :: AR, PAC
#if defined __ICC
          !DIR$ ASSUME_ALIGNED AR:64,PAC:64
#endif
          ! Locals
          INTEGER(kind=4) :: I,JJ,II,II1,I2
          REAL(kind=8) :: S
          REAL(kind=8), dimension(K) :: W
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: W
#endif
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 10  I=1,K                                                      
!cxx   10 PAC(I) = AR(I)                                                    
             PAC(I) = AR(I)
       10 CONTINUE
          IF( K .EQ. 1 )   RETURN                                           
          DO 20  JJ=1,K-1                                                   
                 II = K - JJ                                                       
                 S = 1._8 - PAC(II+1)**2
#if defined __ICC
!DIR$ VECTOR ALIGNED          
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif                 
                 DO 30  I=1,II                                                     
                        J = II - I + 1                                                    
!cxx   30 W(I) = (PAC(I) + PAC(II+1)*PAC(J))/S                              
                        W(I) = (PAC(I) + PAC(II+1)*PAC(J))/S
             30 CONTINUE
                II1 = II + 1                                                      
                I2 = II1 / 2                                                      
                IF( MOD( II,2 ) .EQ. 1 )  W(I2) = PAC(I2)/(1.D0 - PAC(II1))
#if defined __ICC
!DIR$ VECTOR ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif   
                DO 40  I=1,II                                                     
                                                   
                       PAC(I) = W(I)
             40 CONTINUE
     20   CONTINUE                                                          
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: RECOEF
#endif
    SUBROUTINE  RECOEF( X,M,K,MJ,A )
      use omp_lib
      implicit none
      
!C          +-------------------------------------+                      
!C          ! REGRESSION COEFFICIENTS COMPUTATION !                      
!C          +-------------------------------------+                      
!C                                                                       
!C     THIS SUBROUTINE PRODUCES REGRESSION COEFFICIENTS OF REGRESSION MOD
!C     WITH M REGRESSORS FROM THE TRIANGULAR MATRIX X PREPARED BY SUBROUT
!C     REDUCT.                                                           
!C                                                                       
!C       INPUTS:                                                         
!C          X:     (K+1)*(K+1) TRIANGULAR MATRIX, WITH J-TH COLUMN REPRES
!C                 J-TH REGRESSOR (J=1,K) AND (K+1)-TH REGRESSAND        
!C          K:     NUMBER OF REGRESSORS                                  
!C          M:     REGRESSION ON THE FIRST M REGRESSORS IS REQUESTED     
!C          MJ:    ABSOLUTE DIMENSION OF X                               
!C                                                                       
!C       OUTPUT:                                                         
!C          A(I) (I=1,M):   VECTOR OF REGRESSION COEFFICIENTS            
!C                                                                       

          INTEGER(kind=4) :: M, K, MJ                                           
          REAL(kind=8), dimension(MJ,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(M)      :: A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          ! Locals
          INTEGER(kind=4) :: K1,MM1,II,I,I1,J
          REAL(kind=8) :: SUM
                                                                      
          K1 = K + 1                                                        
          A(M) = X(M, K1) / X(M,M)                                          
          IF( M .EQ. 1 )     RETURN                                         
          MM1 = M - 1                                                       
          DO  10 II = 1,MM1                                               
                 I = M - II                                                        
                 SUM = X(I,K1)                                                     
                 I1 = I + 1
#if defined __ICC
                 !DIR$ VECTOR ALIGNED
                 !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                 !$OMP SIMD REDUCTION(+:SUM)
#endif
                 DO  20  J = I1,M                                                 
                                      
                       SUM = SUM - A(J) * X(I,J)
             20 CONTINUE
                                          
                A(I) = SUM / X(I,I)
       10 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  REDATA( XS,X,N,XMEAN,SUM )
      use omp_lib
      implicit none
       
!C                                                                       
!C          +---------------------------------------+                    
!C          ! ORIGINAL DATA INPUT AND MEAN DELETION !                    
!C          +---------------------------------------+                    
!C                                                                       
!C     THIS SUBROUTINE IS USED FOR THE LOADING OF ORIGINAL DATA AND DELET
!C     THE MEAN VALUE.  THE DATA IS LOADED THROUGH THE DEVICE SPECIFIED B
!C     EACH DATA SET IS COMPOSED OF TITLE, DATA LENGTH, DATA FORMAT AND  
!C     ORIGINAL DATA.                                                    
!C                                                                       
!C       INPUTS:                                                         
!C         MT:     INPUT DEVICE SPECIFICATION                            
!C         TITLE:  TITLE OF DATA                                         
!C         N:      DATA LENGTH                                           
!C         DFORM:  INPUT DATA FORMAT SPECIFICATION                       
!C         X(I) (I=1,N):  ORIGINAL DATA                                  
!C                                                                       
!C       OUTPUTS:                                                        
!C         X:   ORIGINAL DATA ( MEAN DELETED )                           
!C         N:   DATA LENGTH                                              
!C         TITLE:  TITLE OF DATA                                         
!C                                                                       

          INTEGER(kind=4) :: N
          REAL(kind=8), dimension(N) :: XS, X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED XS:64,X:64
#endif
          REAL(kind=8) :: XMEAN, SUM
          ! Loals
          INTEGER(kind=4) :: I
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 100 I=1,N
                 X(I)=XS(I)
      100 CONTINUE
!C                                                                  
!C          MEAN DELETION                                                
!C                                                                       
                 SUM = 0.0_8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                 !$OMP SIMD REDUCTION(+:SUM)
#endif
          DO 10 I=1,N                                                   
!cxx   10 SUM = SUM + X(I)                                                  
                SUM = SUM + X(I)
       10 CONTINUE
                                          
                XMEAN = SUM / DBLE(N)
#if defined __ICC
!DIR$ VECTRO ALIGNED
                !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 20   I=1,N                                                     
                                           
                 X(I) = X(I) - XMEAN
       20 CONTINUE
!C                                                                       
!C          VARIANCE COMPUTATION                                         
!C                                                                       
                 SUM = 0._8
#if defined __ICC      
!DIR$ VECTOR ALIGNED
                 !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                 !$OMP SIMD REDUCTION(+:SUM)
#endif                 
          DO  30 I=1,N                                                  
!cxx   30 SUM = SUM + X(I) * X(I)                                           
                SUM = SUM + X(I) * X(I)
       30 CONTINUE
                                           
          SUM = SUM / DBLE(N)                                             
    END SUBROUTINE
    
             
    SUBROUTINE  REDUCT( SETX,Z,NMK,N0,K,MJ1,LAG,X ) 
       implicit none 
!C                                                                       
!C          +-----------------------+                                    
!C          ! HOUSEHOLDER REDUCTION !                                    
!C          +-----------------------+                                    
!C                                                                       
!C     THIS SUBROUTINE FIRST SETS UP DATA MATRIX X BY AUGMENTING         
!C     SUCCESSIVELY SHIFTED ORIGINAL DATA VECTOR Z AND THEN TRANSFORMS   
!C     X INTO TRIANGULAR FORM BY HOUSEHOLDER TRANSFORMATION.             
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             HUSHLD                                                    
!C             (SETX)                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          SETX:  EXTERNAL SUBROUTINE DESIGNATION                       
!C          Z:     ORIGINAL DATA VECTOR                                  
!C          D:     WORKING AREA                                          
!C          NMK:   DIMENSION OF THE VECTOR OF REGRESSAND (Z(N0+LAG+1),...
!C                 Z(N0+LAG+NMK))                                        
!C          N0:    INDEX OF THE END POINT OF DISCARDED FORMER OBSERVATION
!C          K:     NUMBER OF REGRESSORS                                  
!C          MJ1:   ABSOLUTE DIMENSION OF X                               
!C          LAG:   MAXIMUM TIME LAG OF THE MODEL                         
!C                                                                       
!C       OUTPUT:                                                         
!C          X:     REDUCED MATRIX ( UPPER TRIANGULAR FORM )              
!C                                                                       

          INTEGER(kind=4) :: NMK, N0, K, MJ1, LAG
          REAL(kind=8), dimension(N0+LAG+NMK) :: Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64
#endif
          REAL(kind=8), dimension(MJ1,LAG+1)  :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(kind=4) :: L,K1,N1,LK,N2
          
          L = MIN0( NMK,MJ1 )                                               
          K1 = K + 1                                                        
          N1 = L                                                            
!C                                                                       
!C          +-----------------+                                        +-
!C          ! MATRIX X SET UP !                                        ! 
!C          +-----------------+                                        +-
!C                                                                       
          CALL  SETX( Z,N0,L,K,MJ1,0,LAG,X )                                
!C                                                                       
!C          +----------------------------+                             +-
!C          ! HOUSEHOLDER TRANSFORMATION !                             ! 
!C          +----------------------------+                             +-
!C                                                                       
                                   
          CALL  HUSHLD( X,MJ1,L,K1 )                                      
                                                                       
          IF( N1 .GE. NMK )     RETURN                                      
                                                           !           
      100 L = MIN0( NMK-N1,MJ1-K1 )                                         
                                                           !           
          LK = L + K1                                                       
          N2 = N0 + N1                                                      
!C                                                           !           
!C          +-----------------+                              !         +-
!C          ! MATRIX X SET UP !                              !         ! 
!C          +-----------------+                              !         +-
!C                                                           !           
          CALL  SETX( Z,N2,L,K,MJ1,1,LAG,X )                                
!C                                                           !           
!C          +----------------------------+                   !         +-
!C          ! HOUSEHOLDER TRANSFORMATION !                   !         ! 
!C          +----------------------------+                   !         +-
!C                                                           !           
                                 
          CALL  HUSHLD( X,MJ1,LK,K1 )                                     
                                                                    +-
          N1 = N1 + L                                                       
          IF( N1 .LT. NMK )     GO TO 100                                   
    END SUBROUTINE

#if defined __ICC
    !DIR$ ATTRIBUTES INLINE :: SDCOMP
#endif
    SUBROUTINE  SDCOMP( X,A,N,K,MJ,SD )
      use omp_lib
      implicit none
         
!C                                                                       
!C     THIS SUBROUTINE COMPUTES THE RESIDUAL VARIANCE OF THE REGRESSION M
!C     WITH THE REGRESSION COEFFICIENTS A(I) (I=1,K).                    
!C                                                                       
!C       INPUTS:                                                         
!C         X:   N*(K+1) TRIANGULAR MATRIX, OUTPUT OF SUBROUTINE REDUCT   
!C         A:   VECTOR OF REGRESSION COEFFICIENTS                        
!C         Y:   WORKING AREA                                             
!C         N:   DATA LENGTH                                              
!C         K:   HIGHEST ORDER OF THE MODEL                               
!C         MJ:  ABSOLUTE DIMENSION OF X                                  
!C                                                                       
!C       OUTPUT:                                                         
!C         SD:  RESIDUAL VARIANCE                                        
!C                                                                       

          INTEGER(kind=4) :: N, K, MJ
          REAL(kind=8), dimension(MJ,K+1) :: X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          REAL(kind=8), dimension(K)      :: A
#if defined __ICC
          !DIR$ ASSUME_ALIGNED A:64
#endif
          REAL(kind=8) ::  SD
          ! Locals
          INTEGER(kind=4) :: K1,I,J
          REAL(kind=8) :: SUM
          REAL(kind=8), dimension(K+1) :: Y
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: Y
#endif
          K1 = K + 1                                                        
                                                                       
          DO  20 I=1,K                                                  
             SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif
              DO  10 J=I,K                                                  
!cxx   10 SUM = SUM + X(I,J)*A(J)                                           
                     SUM = SUM + X(I,J)*A(J)
           10 CONTINUE
!cxx   20 Y(I) = SUM
              Y(I) = SUM
       20 CONTINUE
          Y(K1) = 0._8                                                     
                                                                       
          SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif          
          DO  30 I=1,K1                                                 
                                 
              SUM = SUM + (Y(I)-X(I,K1))**2
       30 CONTINUE
          SD = SUM / N                                                      
    END SUBROUTINE
    
    SUBROUTINE  SETX1( Z,N0,L,K,MJ1,JSW,LAG,X )  
        implicit none
!C                                                                       
!C          +-----------------+                                          
!C          ! MATRIX X SET UP !                                          
!C          +-----------------+                                          
!C                                                                       
!C     THIS SUBROUTINE PREPARES DATA MATRIX X FROM DATA VECTOR Z(I) (I=N0
!C     N0+LAG+L) FOR AUTOREGRESSIVE MODEL FITTING.  X IS THEN USED AS INP
!C     SUBROUTINE HUSHLD.                                                
!C                                                                       
!C       INPUTS:                                                         
!C          Z:     ORIGINAL DATA VECTOR                                  
!C          N0:    INDEX OF THE END POINT OF DISCARDED FORMER OBSERVATION
!C                 (NEW OBSERVATION STARTS AT N0+LAG+1 AND ENDS AT N0+LAG
!C          L:     DIMENSION OF THE VECTOR OF NEW OBSERVATIONS           
!C          K:     NUMBER OF REGRESSORS (=LAG OR LAG+1)                  
!C          MJ1:   ABSOLUTE DIMENSION OF X                               
!C          JSW:   =0   TO CONSTRUCT INITIAL L*(K+1) DATA MATRIX         
!C                 =1   TO AUGUMENT ORIGINAL (K+1)*(K+1) MATRIX X BY AN  
!C                      L*(K+1) DATA MATRIX OF ADDITIONAL OBSERVATIONS   
!C          LAG:   MAXIMUM TIME LAG OF THE MODEL                         
!C                 =K   CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR   
!C                 <K   CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSO
!C                                                                       
!C       OUTPUT:                                                         
!C          X:      L*(K+1) MATRIX          IF  JSW = 0                  
!C                 (K+1+L)*(K+1) MATRIX     IF  JSW = 1                  
!C                                                                       

          INTEGER(kind=4) :: N0, L, K, MJ1, JSW, LAG 
          REAL(kind=8), dimension(N0+LAG+L)  :: Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64
#endif
          REAL(kind=8), dimension(MJ1,LAG+1) ::  X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED X:64
#endif
          ! Locals
          INTEGER(kind=4) :: KSW,K1,I0,I,II,JJ,J,JKSW
          KSW = 0                                                           
          IF( K .NE. LAG )     KSW = 1                                      
          K1 = K + 1                                                        
          I0 = 0                                                            
          IF( JSW .EQ. 1 )     I0 = K1                                      

          DO  20 I=1,L
                 II = I + I0                                                       
                 JJ = N0 + LAG + I                                                 
                 X(II,K1) = Z(JJ)                                                  
                 DO  10 J=1,LAG                                                  
                        JJ = JJ - 1                                                       
                        JKSW = J + KSW                                                    
                                           
                        X(II,JKSW) = Z(JJ)
             10 CONTINUE
       20 CONTINUE
                                                                       
          IF( KSW .NE. 1 )     RETURN                                       

          X(1:L,1) = 1._8
    END SUBROUTINE
    
    SUBROUTINE  SOLVE( C,R,ID,II,MJ2,MJ3,G )   
      use omp_lib
      implicit none
!C                                                                       
!C     THIS SUBROUTINE SOLVES THE MATRIX EQUATION  C*G=R,  WHERE THE MATR
!C     IS UPPER TRIANGULAR.                                              
!C                                                                       
!C       INPUTS:                                                         
!C          C:      ID*ID COEFFICIENT MATRIX                             
!C          R:      ID*ID MATRIX                                         
!C          ID:     NUMBER OF ROWS AND COLUMNS OF C AND R                
!C          II:     DESIGNATION OF POSITION WHERE THE SOLUSION TO BE STOR
!C          MJ2:    ABSOLUTE DIMENSION OF C AND R                        
!C          MJ3:    ABSOLUTE DIMENSION OF G AND H                        
!C                                                                       
!C       OUTPUT:                                                         
!C          G:      SOLUTION OF THE MATRIX EQUATION                      
!C                                                                       

          INTEGER(kind=4) :: ID, II, MJ2, MJ3 
          REAL(kind=8), dimension(MJ2,ID) :: C, R
#if defined __ICC
          !DIR$ ASSUME_ALIGNED C:64,R:64
#endif
          REAL(kind=8), dimension(MJ3,MJ3,II) ::  G
#if defined __ICC
          !DIR$ ASSUME_ALIGNED G:64
#endif
          ! Locals
          INTEGER(kind=4) :: IDM1,J,JJ,I,IP1
          REAL(kind=8) ::  SUM
                                                                       
          IDM1 = ID - 1
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO  10 J=1,ID                                                   
!cxx   10 G(J,ID,II) = R(ID,J)/C(ID,ID)
              G(J,ID,II) = R(ID,J)/C(ID,ID)
       10 CONTINUE
                                            
          DO  40 JJ=1,IDM1
                 I = ID - JJ                                                       
                 IP1 = I + 1                                                       
                 DO  30  J=1,ID                                                   
                    SUM = 0._8
#if defined __ICC
!DIR$ VECTOR ALIGNED
                    !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
          !$OMP SIMD REDUCTION(+:SUM)
#endif                    
                        DO  20   L=IP1,ID                                                 
!cxx   20 SUM = SUM + G(J,L,II)*C(I,L)
                                 SUM = SUM + G(J,L,II)*C(I,L)
                     20 CONTINUE
!cxx   30 G(J,I,II) = (R(I,J)-SUM) / C(I,I)                                 
                        G(J,I,II) = (R(I,J)-SUM) / C(I,I)
             30 CONTINUE
       40 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  SRCOEF( X,M,K,N,MJ,JND,A,SD,AIC )
        
!C                                                                       
!C     SUBSET REGRESSION COEFFICIENTS AND RESIDUAL VARIANCE COMPUTATION. 
!C                                                                       
!C                                                                       
!C       INPUTS:                                                         
!C         X:     TRIANGULAR MATRIX                                      
!C         M:     NUMBER OF REGRESSORS                                   
!C         K:     HEIGHEST ORDER OF THE MODELS                           
!C         N:     DATA LENGTH                                            
!C        JND(I):   (I=1,...,M)  SPECIFICATION OF I-TH REGRESSOR         
!C       OUTPUTS:                                                        
!C         A:     REGRESSION COEFFICIENTS                                
!C         SD:    INNOVATION VARIANCE                                    
!C                                                                       

          INTEGER(kind=int4) :: M, K, N, MJ, 
          INTEGER(kind=int4), dimension(M)   :: JND
          !DIR$ ASSUME_ALIGNED JND:64
          REAL(kind=dp), dimension(MJ,K+1) :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(M)      :: A
          !DIR$ ASSUME_ALIGNED A:64
          REAL(kind=dp) :: SD, AIC
          ! Locals
          INTEGER(kind=int4) :: K1,M1,MM1,II,I,I1,L
          REAL(kind=dp) :: SUM, OSD
          K1 = K + 1                                                        
          M1 = M + 1                                                        
!C                                                                       
!C                                                                       
!C          REGRESSION COEFFICIENTS COMPUTATION                          
!C                                                                       
          L = JND(M)                                                        
          A(M) = X(M,K1) / X(M,L)                                           
          MM1 = M - 1                                                       
          IF( MM1 .EQ. 0 )     GO TO  60                                    
          DO  10 II=1,MM1                                               
                 I = M - II                                                        
                 SUM = X(I,K1)                                                     
                 I1 = I + 1                                                        
                 DO  20  J=I1,M                                                 
                         L = JND(J)                                                        
!cxx   20 SUM = SUM - A(J) * X(I,L)                                         
                        SUM = SUM - A(J) * X(I,L)
             20 CONTINUE
                L = JND(I)                                                        
!cxx   10 A(I) = SUM / X(I,L)                                               
                A(I) = SUM / X(I,L)
       10 CONTINUE
!C                                                                       
!C                                                                       
!C          RESIDUAL VARIANCE AND AIC COMPUTATION                        
!C                                                                       
       60 CONTINUE                                                          
                SD = 0.0_dp
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD REDUCTION(+:SD)
          DO  30 I=M1,K1                                                
!cxx   30 SD = SD + X(I,K1) * X(I,K1)                                       
                 SD = SD + X(I,K1) * X(I,K1)
       30 CONTINUE
          OSD = SD / N                                                      
          AIC = N * DLOG( OSD ) + 2._dp * M                                
    END SUBROUTINE
    
    SUBROUTINE  TRIINV( X,M,MJ,MJ1,Y )  
         
!C                                                                       
!C       LOWER TRIANGULAR MATRIX INVERSION                               
!C                                                                       
!C       INPUTS:                                                         
!C          X:    TRIANGULAR MATRIX, DIAGONAL ELEMENTS ARE ASSUMED TO BE 
!C          M:    DIMENSION OF MATRIX X                                  
!C          MJ:   ABSOLUTE DIMENSION OF X                                
!C          MJ1:  ABSOLUTE DIMENSION OF Y                                
!C       OUTPUT:                                                         
!C          Y:    INVERSE OF X                                           
!C                                                                       

          INTEGER(kind=int4) :: M, MJ, MJ1 
          REAL(kind=dp), dimension(MJ,M)  :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(MJ1,M) ::  Y
          !DIR$ ASSUME_ALIGNED Y:64
          ! Locals
          INTEGER(kind=int4) :: I,J,J1,IJ,II,JJ,MM1
          REAL(kind=dp)    :: SUM                                     
          MM1 = M - 1                                                       

          Y(1:MM1,1:M) = 0._dp
          DO  20 I=1,M                                                  
!cxx   20 Y(I,I) = 1.D0
                  Y(I,I) = 1._dp
      20 CONTINUE

         DO  41 J=1,MM1
                J1 = J + 1                                                        
                DO  40 I=J1,M                                                 
                       SUM = 0._dp                                                       
                       IJ = I - J                                                        
                       DO  30 II=1,IJ                                                
                              JJ = II + J - 1                                                   
!cxx   30 SUM = SUM + X(I,JJ) * Y(JJ,J)
                              SUM = SUM + X(I,JJ) * Y(JJ,J)
                    30 CONTINUE

                       Y(I,J) = -SUM
             40 CONTINUE
        41 CONTINUE
    END SUBROUTINE
    

    REAL(kind=dp) FUNCTION DMIN( X,N )
         
!C                                                                       
!C       THIS FUNCTION RETURNS THE MINIMUM VALUE AMONG X(I) (I=1,N).     
!C                                                                       
!C       INPUTS:                                                         
!C          X:     VECTOR                                                
!C          N:     DIMENSION OF VECTOR X                                 
!C                                                                       
!C       OUTPUT:                                                         
!C          DMIN:  MINIMUM OF X(I) (I=1,N)                               
!C                                                                       

          INTEGER(kind=int4) :: N                                                    
          REAL(kind=dp), dimension(N)  :: X                                                    
          !DIR$ ASSUME_ALIGNED X:64                                                             
          DMIN = X(1)                                                       
          DO  10 I=2,N                                                    
          IF( DMIN .GT. X(I) )  DMIN = X(I)                          
      10 CONTINUE                                                          
    END FUNCTION
    
    SUBROUTINE COVGENF(L,K,F,G,C,CN)
         
     
!C
!cc	PROGRAM COVGEN
!C     PROGRAM 74.1.3. COVARIANCE GENERATION FROM GAIN FUNCTION.
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(1
!C         BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C         NO.5, MARCH 1975, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** FOR THE BASIC THEORY SEE "CANONICAL CORRELATION ANALYSIS OF TIM
!C         AND THE USE OF AN INFORMATION CRITERION" BY H. AKAIKE, IN
!C         "SYSTEM IDENTIFICATION: ADVANCES AND CASE STUDIES" R. K. MEHRA
!C         D. G. LAINIOTIS EDS. ACADEMIC PRESS, NEW YORK, 1976
!C-----------------------------------------------------------------------
!C     THIS PROGRAM PRODUCES THE FOURIER TRANSFORM OF A POWER
!C     GAIN FUNCTION IN THE FORM OF AN AUTOCOVARIANCE SEQUENCE.
!C     THE GAIN FUNCTION IS DEFINED AS A RECTILINEAR FUNCTION WITH
!C     THE VALUES G(I) SPECIFIED AT THE FREQUENCIES F(I),I=1,K.
!C     THE OUTPUTS OF THIS PROGRAM ARE USED AS THE INPUTS TO THE CANONICA
!C     CORRELATION ANALYSIS PROGRAM CANARM, TO REALIZE A FILTER WITH
!C     THE DESIRED GAIN FUNCTION.
!C
!C     THE FOLLOWING INPUTS ARE REQUIRED:
!C     (L,K): L, DESIRED MAXIMUM LAG OF COVARIANCE (AT MOST 1024)
!C            K, NUMBER OF DATA POINTS (LESS THAN OR EQUAL TO 500)
!C     (F(I),G(I))(I=1,K): F(I), FREQUENCY. BY DEFINITION F(1)=0.0 AND F(
!C                           F(I)'S ARE ARRANGED IN INCREASING ORDER.
!C                           G(I), POWER GAIN OF THE FILTER AT THE FREQUEN
!C
!C     OUTPUTS:
!C     (N,LAGH): N=2048
!C     C(I)(I=0,LAGH):
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: COVGENF
!C
          INTEGER(kind=int4), PARAMETER :: LMAX=1024

          INTEGER(kind=int4) :: L, K
          REAL(kind=dp), dimension(K) :: F, G
          !DIR$ ASSUME_ALIGNED F:64,G:64
          REAL(kind=dp), dimension(L+1) :: C, CN
          !DIR$ ASSUME_ALIGNED C:64,CN:64
          ! Locals
          INTEGER(kind=int4) :: N2P,I,NN,J,J1,I1,I2,LAGH1
          REAL(kind=dp) :: CX0, Q00, AN, BN, CM, Q1, Q2, Q3, Q4, Q25
          COMPLEX(kind=dp), dimension(LMAX*2) :: A

          Q00=0.0_dp

          N=LMAX*2
          N2P=11

          AN=N
          NN=LMAX-1
          DO  200 I=1,NN
                  BN=I
                  CM=BN/AN
                  J=K

              106 CONTINUE
                  IF(CM-F(J) .GE. 0) GO TO 108

                  J=J-1
                  GO TO 106
              108 J1=J+1
              Q1=(F(J1)-CM)*G(J)
              Q2=(CM-F(J))*G(J1)
              Q3=F(J1)-F(J)
              Q4=(Q1+Q2)/Q3
              I1=I+1
              Q1=Q4
              A(I1)=DCMPLX(Q1,Q00)
              I2=N-I+1
!cxx  200 A(I2)=A(I1)
              A(I2)=A(I1)
      200 CONTINUE
          Q25=G(1)
          A(1)=DCMPLX(Q25,Q00)
          Q25=G(K)
          A(NN+2)=DCMPLX(Q25,Q00)
!C     FAST FOURIER TRANSFORM OF A
!C     COMMON SUBROUTINE CALL
          CALL MIXRAD(A,N,N2P,+1)
          LAGH1=L+1
          DO  201 I=1,LAGH1
!cxx  201 C(I)=DREAL(A(I))
                  C(I)=DREAL(A(I))
      201 CONTINUE
!C     C(I+1),I=0,L     ARE THE DESIRED AUTOCOVARIANCES.
!C     NORMARIZED COVARIANCES ARE GIVEN AS CN(I+1),I=0,L.
          CX0=C(1)

          CALL CORNOM(C,CN,LAGH1,CX0,CX0)
    END SUBROUTINE
    
    SUBROUTINE  DECOMPF(DATA,N,IPAR,TREND,SEASNL,AR,   &
                          TRAD,NOISE,para,imiss,omaxx,ier )
                    

    

          INTEGER(kind=int4), PARAMETER ::  IOPT=1
          INTEGER(kind=int4), PARAMETER ::  NIP=9, NPA=26

          INTEGER(kind=int4) :: N,  imiss, ier
          INTEGER(kind=int4), dimension(NIP) :: IPAR
          !DIR$ ASSUME_ALIGNED IPAR:64
          REAL(kind=dp), dimension(N)   :: DATA, TREND, SEASNL, AR, TRAD, NOISE
          !DIR$ ASSUME_ALIGNED DATA:64,TREND:64,SEASNL:64,AR:64,TRAD:64,NOISE:64
          REAL(kind=dp), dimension(NPA) :: para
          !DIR$ ASSUME_ALIGNED para:64
          REAL(kind=dp) :: omaxx
          ! Locals
          
          INTEGER(I32P) :: PERIOD, SORDER,M1,M2,M3,M4,M5,M,L,LM1
          INTEGER(I32P) :: ISW,ISMT,IDIF,LOG,MESH
          
          COMMON    /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER,    
          COMMON    /CCC/     ISW, ISMT, IDIF, LOG, MESH

         

          para(1:NPA) = 0.0_dp

          CALL  SPARAM0( IPAR,NIP )
          LM1 = L+M+1

          call decompff (DATA,N,TREND,SEASNL,AR,TRAD,NOISE,    &
                            para,iopt,imiss,omaxx,LM1,ier)
    END SUBROUTINE
                          

      

    SUBROUTINE  DECOMPFF(DATA,N,TREND,SEASNL,AR,TRAD,NOISE,   &
                          para,iopt,imiss,omaxx,LM1,ier )
        
                         
!C
!C                                                                       
!c  Bug fixed (97/10/17)
!c
!c  99/8/12
!c  iopt < 0 -> use para. not optimized. 
!c  input 
!c  para(1):tau21, para(2):tau22, para(3):tau23,
!c  para(4,5,6,...): ARCOEF
!c
!c  m4 = 0(no trade), 1(2-TDF model), 6(7-TDF model) 
!c
!c  99/9/2  if iopt < 0 , need ispan (=ipar(9))
!c 

!C  ...  TIME SERIES DECOMPOSITION (SEASONAL ADJUSTMENT) ...             
!C                                                                       
!C     THE BASIC MODEL:                                                  
!C                                                                       
!C          y(n) = T(n) + AR(n) + S(n) + TD(n) + R(n) + W(n)             
!C                                                                       
!C       where                                                           
!C            T(n):       trend component                                
!C            AR(n):      AR process                                     
!C            S(n):       seasonal component                             
!C            TD(n):      trading day factor                             
!C            R(n):       any other explanetory variables                
!C            W(n):       observational noise                            
!C                                                                       
!C     COMPONENT MODELS:                                                 
!C                                                                       
!C       Trend component                                                 
!C            T(N) =  T(N-1) + V1(N)                             :M1 = 1 
!C            T(N) = 2T(N-1) - T(N-2) + V1(N)                    :M1 = 2 
!C            T(N) = 3T(N-1) -3T(N-2) + T(N-2) + V1(N)           :M1 = 3 
!C                                                                       
!C       AR componet:                                                    
!C            AR(n) = a(1)AR(n-1) + ... + a(m2)AR(n-m2) + V2(n)          
!C                                                                       
!C       Seasonal component:                                             
!C            S(N) =  -S(N-1) - ... - S(N-PERIOD+1) + V3(N)    :SORDER=1 
!C            S(N) = -2S(N-1) - ... -PERIOB*S(N-PERIOD+1)      :SORDER=2 
!C                            - ... - S(n-2PERIOD+2) + V3(n)             
!C       Trading day effect:                                             
!C            TD(n) = b(1)*TRADE(n,1) + ... + b(7)*TRADE(n,7)            
!C                                                                       
!C            TRADE(n,i):  number of i-th days of the week in n-th data  
!C            b(1) + ... + b(7) = 0                                      
!C                                                                       
!C     REFERENCES                                                        
!C                                                                       
!C       G. KITAGAWA (1981), A Nonstationary Time Series Model and Its   
!C            Fitting by a Recursive Filter, Journal of Time Series      
!C            Analysis, Vol.2, 103-116.                                  
!C                                                                       
!C       W. GERSCH and G. KITAGAWA (1983), The prediction of time series 
!C            with Trends and Seasonalities, Journal of Business and     
!C            Economic Statistics, Vol.1, 253-264.                       
!C                                                                       
!C       G. KITAGAWA (1984), A smoothness priors-state space modeling of 
!C            Time Series with Trend and Seasonality, Journal of American
!C            Statistical Association, VOL.79, NO.386, 378-389.          
!C                                                                       
!C     STRUCTURE OF THE PROGRAM                                          
!C                                                                       
!C       <DECOMP>                                                        
!C          |---<SPARAM>                                                 
!C          |      |---<ID>                                              
!C          |      +---<PARCOR>                                          
!C          |---<REDATA>                                                 
!C          |---<AREA>                                                   
!C          |---<LOGTRF>                                                 
!C          |---<TRADE>                                                  
!C          |---<EPARAM>                                                 
!C          |      |---<SETFGH>                                          
!C          |      |---<OPTMIZ>                                          
!C          |      |      +---<LINEAR>                                   
!C          |      |             +---<FUNCND>                            
!C          |      |                    +---<FUNCSA>                     
!C          |      |                           |---<ARCOEF>              
!C          |      |                           |---<SMOTH3>              
!C          |      |                           |      |---<HUSHL7>       
!C          |      |                           |      |---<HUSHL4>       
!C          |      |                           |      |---<RECOEF>       
!C          |      |                           |      +---<ID>           
!C          |      |                           +---<STATE>               
!C          |      +---<PPARA>                                          
!C          |             +---<ARCOEF>                                   
!C          |---<FUNCSA>                                                 
!C          +---<PLOTDD>                                                 
!C                 |---<MAXMIN>                                          
!C                 |---<XYAXIS>                                          
!C                 +---<PLOTD>                                           
!C                                                                       
!C     THE FOLLOWING CONTROL PARAMETERS ARE PRESET AS DEFAULT OPTION     
!C          M1     = 2    :trend order(0, 1, 2 or 3)                     
!C          M2     = 0    :AR order (less than 11, try 2 first)          
!C          PERIOD = 12   :number of seasons in one period               
!C          SORDER = 1    :seasonal order (0, 1 or 2)                    
!C          TRADE  = 0    :trading day adjustment (if TRADE = 1)         
!C          MT     = 1    :original data input device, MT = 5:card reader
!C          BSPAN  = 300  :maximum data length in filtering              
!C          ISPAN  = 100  :number of data for backward filtering         
!C          MISING                                                       
!C          TAU2(I)       :system noise variances (i=1,2,3)              
!C          PAC(I)        :PARCOR (i=1,...,M2)                           
!C          IPR    = 7    :print out control                             
!C          IDIF   = 1    :numerical differencing (1 sided or 2 sided)   
!C          LOG    = 0    :log transformation of data (if LOG = 1)       
!C          YEAR          :the first year of the data                    
!C          MESH   = 1    :draw mesh on the figure (if MESH > 0)         
!C                                                                       
!C     These options can be changed by using NAMELIST 'PARAM'            
!C                                                                       
!C          EXAMPLE:                                                     
!C             &PARAM M2=2,LOG=1,&END                                    
!C                                                                       
!C                                                                       
!C     -----  WRITTEN BY GENSHIRO KITAGAWA  ----END S                    
!C                                                                       


          INTEGER(kind=int4), PARAMETER :: NIP=9, NPA=26

          INTEGER(kind=int4) :: N, iopt, imiss, LM1, ier 
          REAL(kind=dp), dimension(N)  :: DATA, TREND, SEASNL, AR, TRAD, NOISE
          !DIR$ ASSUME_ALIGNED DATA:64,TREND:64,SEASNL:64,AR:64,TRAD:64,NOISE:64
          REAL(kind=dp), dimension(NPA) ::           para
          !DIR$ ASSUME_ALIGNED para:64
          REAL(kind=dp) :: omaxx
          ! Locals
         
          INTEGER(kind=int4) :: PERIOD, SORDER,M1,M2,M3,M4,M5,M,L,NYEAR,nmonth,LLL,ISMT
          INTEGER(kind=int4) :: ISW, ISMT, IDIF, LOG, MESH 
          REAL(kind=dp) :: YMEAN,FF
          INTEGER(kind=int4), dimension(N)    :: IMIS 
          REAL(kind=dp), dimension(L+M2)    :: A 
          REAL(kind=dp), dimension(N)       :: Z 
          REAL(kind=dp), dimension(L,LM1,N) :: E 
          REAL(kind=dp), dimension(N,7)     :: TDAY
!DIR$ ATTRIBUTES ALIGN : 64 :: IMIS,A,Z,E,TDAY
          COMMON     /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER, &
                               NYEAR, nmonth
          COMMON     /CCC/     ISW, ISMT, IDIF, LOG, MESH              
!C                                                                       
!C           ...  set control parameters  ...                            
!C

          LLL = L+M2

          CALL  SPARAM( A,LLL,para,NPA,iopt )
                    
          do 123 i=1,n                      
                 imis(i) = 0

                 if (imiss .gt. 0) then
                    if(data(i) .gt. omaxx)  imis(i) = 1
                 else if (imiss .lt. 0) then
                   if(data(i) .lt. omaxx)  imis(i) = 1
                 end if
     123  continue
!C                                                                       
!C           ...  read original data  ...                                
!C                                                                       

          CALL  REDATAD( DATA,ISW,Z,N,YMEAN )
                                                                       

          CALL  LOGTRF( Z,IMIS,N,LOG,ier )
          if(ier .ne. 0) return
!C                                                                       
!C           ...  prepare calender for trading day adjustment  ...       
!C                                                                       
          IF( M4 .NE. 0)  then

               if( period .eq. 12 )  CALL  TRADE( NYEAR,nmonth,N,TDAY )
               if( period .eq. 4 )  CALL  TRADE2( NYEAR,nmonth,N,TDAY )
          endif
!C                                                                       
!C           ...  estimation of parameters  ...                          
!C                                                                           


          CALL  EPARAM( Z,E,TDAY,IMIS,N,A,iopt)
                                                                      
          ISMT = 1                                                          
                                      
          CALL  FUNCSA( Z,E,TDAY,IMIS,N,LM1,LLL,A,FF,IFG)
!C                                                                       
!C           ...  plot estimated components  ...                         
!C                                   


          call trpar( A,LLL,para,NPA)


          CALL PLOTDD(N,Z,E,LM1,TDAY,TREND,SEASNL,AR,TRAD,NOISE)
    END SUBROUTINE
                          

                                                              
                                
    SUBROUTINE  ARCOEFD( PAC,K,AR )  
       
!C                                                                       
!C  ...  TRANSFORMATION FROM PARCOR TO AR COEFFICIENTS  ...              
!C                                                                       
!C       INPUTS:                                                         
!C         PAC:  VECTOR OF PARTIAL AUTOCORRELATIONS                      
!C         K:    ORDER OF THE MODEL                                      
!C                                                                       
!C       OUTPUTS:                                                        
!C         AR:   VECTOR OF AR-COEFFICIENTS                               
!C                                                                       
!C                                                                       

          INTEGER(kind=int4) :: K
          REAL(kind=dp), dimension(K) :: PAC, AR
          !DIR$ ASSUME_ALIGNED PAC:64,AR:64
          ! Locals
          INTEGER(kind=int4) :: II,IM1,J,JJ
          REAL(kind=dp), dimension(K) :: W
!DIR$ ATTRIBUTES ALIGN : 64 :: W                                                                      
          DO  30 II=1,K                                                 
                AR(II) = PAC(II)                                                  
                W(II)  = PAC(II)                                                  
                IM1 = II - 1                                                      
                IF( IM1 .LE. 0 )     GO TO 30                                     
                DO  10  J=1,IM1                                                
                        JJ = II - J                                                       
                                   
                        AR(J) = W(J) - PAC(II)*W(JJ)
            10 CONTINUE
               IF( II .EQ. K )     GO TO 40                                      
               DO  20 J=1,IM1                                                
                                                     
                   W(J) = ar(J)
            20 CONTINUE
       30 CONTINUE                                                          
       40 CONTINUE                                                          
    END SUBROUTINE
    
                                  
    SUBROUTINE  EPARAM( Z,E,TDAY,IMIS,N,A,iopt)
         
!C                                                                       
!C  ...  Estimation of parameters  ...                                   
!C                                                                       
          INTEGER(kind=int4) ::  N, iopt
          INTEGER(kind=int4), dimension(N)  :: IMIS
          !DIR$ ASSUME_ALIGNED IMIS:64
          REAL(kind=dp), dimension(N) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          REAL(kind=dp), dimension(L,(L+M+1),N) :: E
          !DIR$ ASSUME_ALIGNED E:64
          REAL(kind=dp), dimension(N,7)         :: TDAY
          !DIR$ ASSUME_ALIGNED TDAY:64
          REAL(kind=dp), dimension(L+M2)        :: A
          !DIR$ ASSUME_ALIGNED A:64
          ! Locals
          INTEGER(kind=int4) :: PERIOD, SORDER,M1,M2,M3,M4,M5,M,L,   &
                       NYEAR,nmonth,ISW,ISMT,IDIF,LOG,MESH, &
                       LM,I
          REAL(kind=dp) :: DI, DJACOB, FC, SIG2, AIC, FI, SIG2I, AICI
          REAL(kind=dp), dimension(L+M2) :: AI 
          REAL(kind=dp), dimension(10) :: F1, F2, A1, A2
          REAL(kind=dp), dimension(300) :: F3,A3            
          REAL(kind=dp), dimension(200) ::  GI, GC
          REAL(kind=dp), dimension(3) :: UI
          REAL(kind=dp), dimension(7) :: TDF
          COMMON    /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER,  &
                          NYEAR, nmonth
          COMMON  /COMSM3/  F1, F2, F3, A1, A2, A3,  DI, UI, TDF  
                                                 
          COMMON /CMFUNC/  DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,GI,GC
          COMMON    /CCC/     ISW, ISMT, IDIF, LOG, MESH
          EXTERNAL   FUNCSA                                                 
                                                                       
          LM = L + M2                                                       
          ISMT = 0                                                          
                                       
          DO 10 I=1,LM                                                      
                                            
                AI(I) = A(I)
       10 CONTINUE
                                                                       
          CALL  SETFGH                                                      
          if(iopt .ge. 0) then

              CALL  OPTMIZ( FUNCSA,Z,E,TDAY,IMIS,N,A,LM,L,L+M+1 )               
          end if
    END SUBROUTINE
    
                                                         
                         
    SUBROUTINE  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,M,A,F,G,IFG,L,LM1 )
         
!C                                                                       
!C  ...  FUNCTION EVALUATION AND NUMERICAL DIFFERENCING  ...             
!C                                                                       

          INTEGER(kind=int4), dimension(N) :: IMIS
          !DIR$ ASSUME_ALIGNED IMIS:64
          INTEGER(kind=int4) :: N, M, IFG, L, LM1
          REAL(kind=dp), dimension(N) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          REAL(kind=dp), dimension(L,LM1,N) ::  E
          !DIR$ ASSUME_ALIGNED E:64
          REAL(kind=dp), dimension(N,7) :: TDAY
          !DIR$ ASSUME_ALIGNED TDAY:64
          REAL(kind=dp), dimension(M) :: A, G
          !DIR$ ASSUME_ALIGNED A:64,G:64
          REAL(kind=dp) :: F
          ! Locals
          INTEGER(kind=int4) :: ISW,ISMT,IDIF,LOG,MESH,I,II,ICNT
          REAL(kind=dp) :: CONST, FB, FF, DJACOB, FC, SIG2, AIC, FI, SIG2I, AICI
          REAL(kind=dp), dimension(M) :: B  
          REAL(kind=dp), dimension(200) ::  GI, GC

          COMMON     /CCC/    ISW, ISMT, IDIF, LOG, MESH              
          COMMON   /CMFUNC/ DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,GI,GC

          DATA       ICNT /0/                                               
          CONST = 0.0001_dp                                                 
                                        
          CALL  FUNCT( Z,E,TDAY,IMIS,N,LM1,M,A,F,IFG )                      
          FB = F                                                            
          IF( ISW .GE. 1 )   RETURN                                         
                                  
          DO 10  I=1,M                                                      
                                                   
                 B(I) = A(I)
       10 CONTINUE
                                                                       
          DO 30 II=1,M                                                     
                B(II) = A(II) + CONST                                             
                                      
                CALL  FUNCT( Z,E,TDAY,IMIS,N,LM1,M,B,FF,IFG )
                IF( IDIF .EQ. 1 )  GO TO 20                                       
                B(II) = A(II) - CONST                                             

                CALL  FUNCT( Z,E,TDAY,IMIS,N,LM1,M,B,FB,IFG )                    
             20 G(II) = (FF-FB)/(CONST*IDIF)                                      
                IF( G(II) .GT. 1.0E+20_dp )  G(II) = (F-FB)/CONST                     
                IF( G(II) .LT.-1.0E+20_dp )  G(II) = (FF-F)/CONST                     
                IF( FB.GT.F .AND. FF.GT.F )  G(II) = 0.0_dp                      
                                                    
                B(II) = A(II)
       30 CONTINUE
                                  
          DO 40 I=1,M                                                       
                                                
               GC(I) = G(I)
       40 CONTINUE
          ICNT = ICNT + 1                                                   
          IF(ICNT .GT. 1)  RETURN                                           
                                                                       
          AICI  = AIC                                                       
          SIG2I = SIG2                                                      
          FI    = FC                                                        
          DO 50 I=1,M                                                       
                                                 
               GI(I) = G(I)
       50 CONTINUE
    END SUBROUTINE
    
                            
    SUBROUTINE  FUNCSA( Z,E,TDAY,IMIS,N,LM1,KK,A,FF,IFG )
       
!C                                                                       
!C  ...  Initial setting, filtering and smoothing  ...                   
!C                                                                       
                                    


          INTEGER(kind=int4), dimension(N) :: IMIS
          !DIR$ ASSUME_ALIGNED IMIS:64
          REAL(kind=dp) ::  N, LM1, KK, IFG 
          REAL(kind=dp), dimension(N) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          REAL(kind=dp), dimension(L,LM1,N) ::  E
          !DIR$ ASSUME_ALIGNED E:64
          REAL(kind=dp), dimension(N,7) ::  TDAY
          !DIR$ ASSUME_ALIGNED TDAY:64
          REAL(kind=dp), dimension(KK) :: A
          !DIR$ ASSUME_ALIGNED A:64
          REAL(kind=dp) :: FF
          ! Locals
          INTEGER(kind=int4) :: PERIOD, SORDER,M1,M2,M3,M4,M5,M,L,NYEAR,nmonth, &
                           ISW,ISMT,IDIF,LOG,MESH,MJ,M12,I,NI,K,MJ,NI
          REAL(kind=dp) :: DI,TAU2,SUM
          INTEGER(kind=int4), dimension(N) :: IMISR
          REAL(kind=dp), dimension(N) :: ZZ 
          REAL(kind=dp), dimension(M) :: Y 
          REAL(kind=dp), dimension(LM1+1,LM1) :: R 
          REAL(kind=dp), dimension(M+1,M+1)   :: S
          REAL(kind=dp), dimension(10)  :: F1,F2,A1,A2
          REAL(kind=dp), dimension(300) :: F3,A3
          REAL(kind=dp), dimension(3) :: UI
          REAL(kind=dp), dimension(7) :: TDF
!DIR$ ATTRIBUTES ALIGN : 64 :: IMISR,ZZ,Y,R,S     
 
         COMMON    /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER,   &
                     NYEAR, nmonth
         COMMON  /COMSM3/  F1, F2, F3, A1, A2, A3,  DI, UI, TDF 
                    
         COMMON    /CCC/     ISW, ISMT, IDIF, LOG, MESH              
                                                                       
         IFG = 0                                                           
                                
         M12 = M1 + M2
                                                        
         MJ=M+1


!C                                                                       
!C  ...  Backward Filtering  ...                                         
!C                                                                       

          NI=N
          DO 10  I=1,NI                                                     
               imisr(i) = imis(NI-I+1)
                                           
               ZZ(I) = Z(NI-I+1)
10             CONTINUE
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          DO 20  I=1,L                                                      
               TAU2 = 0.5_dp*(1.0_R64P + DSIN( A(I) ))  + 0.0001_dp
               IF(TAU2 .LT. 1.0E-20_dp)  TAU2 = 1.0E-20_dp                           
                                   
               UI(I) = 1.0_dp/DSQRT( TAU2 )
       20 CONTINUE

          IF( M2 .EQ. 0 )  GO TO 40
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD     
          DO 30  I=1,M2                                                     
                                    
             Y(I) = 0.90_dp*DSIN( A(L+I) )
       30 CONTINUE
                                        
          CALL  ARCOEFD( Y,M2,A2 )

       40 CONTINUE
          S(1:MJ,1:MJ) = 0.0_dp
          R(1:LM1+1,1:LM1) = 0.0_dp
          DI = 1.0_dp                                                      
                                          
          IF( M2 .EQ. 0 )  GO TO 90                                         
          F2(1) = 1.0_dp/A2(M2)                                              
          IF(M2.EQ.1)  GO TO 90
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          DO 80  I=2,M2                                                     
                                       
               F2(I) = -A2(I-1)/A2(M2)
       80 CONTINUE
       90 CONTINUE                                                          

          CALL  SMOTH3( ZZ,R,S,E,TDAY,IMISR,N,LM1,FF,0,0 )

!C                                                                       
!C  ...  Transformation of State Vector  ...                             
!C                                                                       
                                  
          CALL  RECOEF( S,M,M,M+1,Y )
          CALL  STATE( Y,A1,M1 )
          CALL  STATE( Y(M1+1),A2,M2 )
          CALL  STATE( Y(M12+1),A3,M3 )
                                              
          DO 210  I=1,M
                SUM = 0.0_dp                                                       
                !DIR$ VECTOR ALIGNED
                !DIR$ SIMD REDUCTION(+:SUM)
                DO 220  J=I,M

                     SUM = SUM + S(I,J)*Y(J)
            220 CONTINUE

                S(I,M+1) = SUM
       210 CONTINUE
!C                                                                       
!C  ...  Forward Filtering and/or Smoothing  ...                         
!C                                                                       
   
          CALL  SMOTH3( Z,R,S,E,TDAY,IMIS,N,LM1,FF,1,ISMT )
                                                                      
          FF = -FF                                                          
    END SUBROUTINE
    
    SUBROUTINE  HUSHL4( X,MJ1,N,K,M,ISW )  
        
!C                                                                       
!C          HOUSEHOLDER TRANSFORMATION;   TYPE 4                         
!C                                                                       

          INTEGER(kind=int4) :: MJ1, N, K, M, ISW
          REAL(R64P), dimension(MJ1,K) :: X
          !DIR$ ASSUME_ALIGNED X:64
      ! Locals
          INTEGER(kind=int4) :: II,J
          REAL(kind=dp) ::  TOL, D0, D1, H, G, S
          REAL(kind=dp), dimension(K) :: D 
!DIR$ ATTRIBUTES ALIGN : 64 :: D
          DATA     TOL /1.0E-30_dp/                                            
                                                                       
          IF( ISW .EQ. 1 )   GO TO 110                                      
                                                 
          DO 101  II=M,K
                 D0 = X(II,II)                                                     
                 D1 = X(N,II)                                                      
                 H = D0**2 + D1**2                                                 
                 IF( H .GT. TOL )  GO TO 20                                        
                 G = 0.0_R64P                                                         
                 GO TO  100                                                        
              20 G = DSQRT( H )                                                    
                 IF( D0 .GE. 0.0_R64P )   G = -G                                      
                 H = H - D0*G                                                      
                 D0 = D0 - G                                                       
                 D(II) = D0                                                        
                                                                       
                 IF( II .EQ. K )  GO TO 100
                 !DIR$ VECTOR ALIGNED
                 !DIR$ SIMD
                DO 60  J=II+1,K                                                   
                       S = (D0*X(II,J) + D1*X(N,J))/H                                    
                       X(II,J) = X(II,J) - D0*S                                          
                       X(N,J) = X(N,J) - D1*S                                            
            60 CONTINUE                                                          
           100 X(II,II) = G                                                      
      101 CONTINUE
          RETURN                                                            
                                                                       
110       CONTINUE
!DIR$ VECTOR ALWAYS
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 120  J=M,K-1                                                   
                  S = (D(J)*X(J,K)+X(N,J)*X(N,K))                                   
                  H = -X(J,J)*D(J)                                                  
                  S = S/H                                                           
                  X(J,K) = X(J,K)-D(J)*S                                            

                  X(N,K) = X(N,K)-X(N,J)*S
      120 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  HUSHL7( X,D,MJ1,K,M,KE ) 
       
!C                                                                       
!C     Householder Transformation,  TYPE 7                               
!C                                                                       
                                  
          INTEGER(kind=int4) :: MJ1, K, M, KE
          REAL(kind=dp), dimension(MJ1,K)  :: X
          !DIR$ ASSUME_ALIGNED X:64
          REAL(kind=dp), dimension(MJ1)    :: D
          !DIR$ ASSUME_ALIGNED D:64
          ! Loclas
          INTEGER(kind=int4) :: II,I,II1,NE,J
          REAL(kind=dp) :: TOL, H, G, F, S
                                                                       
          TOL = 1.0E-30_dp                                               
                                               
          DO 101  II=1,KE
                  NE = MAX(M,II) + 1                                                
                  H = 0.0_dp
                  !DIR$ VECTOR ALWAYS
                  !DIR$ SIMD REDUCTION(+:H)
                  DO 10  I=II,NE                                                 
                        D(I) = X(I,II)                                              

                        H = H + D(I)*D(I)
           10    CONTINUE
                 IF( H .GT. TOL )  GO TO 20                                     
                 G = 0.0_dp                                                    
                 GO TO 100                                                      
           20    G = DSQRT( H )                                                 
                 F = X(II,II)                                                   
                 IF( F .GE. 0.0_dp)   G = -G                                   
                 D(II) = F - G                                                  
                 H = H - F*G                                                    
!C                                                                       
!C          FORM  (I - D*D'/H) * X, WHERE H = D'D/2                      
!C                                                                       
                 II1 = II+1                                                     
                 DO 30 I=II1,NE                                                    

                       X(I,II) = 0.0_dp
              30 CONTINUE
                 IF( II .EQ. K )  GO TO 100                                     
                                                                       
                 DO 60  J=II1,K                                                 
                    S = 0.0_dp
!DIR$ VECTOR ALWAYS
!DIR$ SIMD REDUCTION(+:S)
                       DO 40  I=II,NE                                              
                                       
                             S = S + D(I)*X(I,J)
              40       CONTINUE
                       S = S/H                                                     
                       DO 50  I=II,NE                                              
                                    
                       X(I,J) = X(I,J) - D(I)*S
              50       CONTINUE
          60    CONTINUE                                                       
            100 X(II,II) = G                                                      
      101 CONTINUE
    END SUBROUTINE
    
    FUNCTION  ID( K )  
        
!C                                                                       
!C  ...  ID = 1:    IF K > 0                                             
!C       ID = 0:    OTHERWISE                                            
!C                                                                       
      ID = 0                                                            
      IF( K .GT. 0 )  ID = 1                                            
    END FUNCTION
    
    
                  
    SUBROUTINE  LINEA1( FUNCT,Z,E,TDAY,IMIS,N,L,LM1,      &
         X,H,RAM,EE,G,K,IG )
      
    
!C                                                                       
!C  ...  LINE SEARCH (WOLFE'S ALGORITHM)  ...                            
!C                                                                       

          INTEGER(kind=int4), dimension(N) :: IMIS
          !DIR$ ASSUME_ALIGNED IMIS:64
          INTEGER(kind=int4) :: N, L, LM1, K, IG
          REAL(kind=dp), dimension(N)       :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          REAL(kind=dp), dimension(L,LM1,N) :: E
          !DIR$ ASSUME_ALIGNED E:64
          REAL(kind=dp), dimension(N,7)     :: TDAY
          !DIR$ ASSUME_ALIGNED TDAY:64
          REAL(kind=dp), dimension(K)       ::  X, H, G
          !DIR$ ASSUME_ALIGNED X:64,H:64,G:64
          REAL(kind=dp) ::  RAM,EE
     
          INTEGER(kind=int4) :: RET, SUB, ISW, ISMT, IDIF, LOG, MESH, &
                           IFG,I,IPR
          REAL(kind=dp) ::  C1, C2, F0, SUM0, CONST2, HNORM,               &
                         RAM1, RAM2, RAM3, A1, A2, A3, B1, B2, E1, E2,  &
                         E3, H1, H2, SUM
          REAL(kind=dp), dimension(K) :: X1 
          !DIR$ ATTRIBUTES ALIGN : 64 :: X1
          COMMON     /CCC/     ISW, ISMT, IDIF, LOG, MESH
          EXTERNAL   FUNCT              
          C1 = 0.01_dp                                                      
          C2 = 0.5_dp                                                       

          IFG = 0

          F0 = EE                                                           
          SUM0 = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM0)          
          DO 15 I=1,K                                                       
                                       
               SUM0 = SUM0 + G(I)*H(I)
       15 CONTINUE
          ISW = 1                                                           
          RAM = 0.5_dp                                                      
          CONST2 = 1.0E-60_dp                                                  
          HNORM = 0._dp
!DIR$ VECTOR ALWAYS
!DIR$ SIMD REDUCTION(+:HNORM)          
          DO 10  I=1,K                                                      
                                        
             HNORM = HNORM + H(I)**2
       10 CONTINUE
          HNORM = DSQRT( HNORM )                                            
                                                                       
          RAM2 = RAM                                                        
          E1 =EE                                                            
          RAM1 = 0._dp                                                     
                                                                       
          IF( RAM2*HNORM .GT. 5.0_dp )  GO TO 48
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          DO 20  I=1,K                                                      
                                         
                X1(I) = X(I) + RAM2*H(I)
       20 CONTINUE
                                
          CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,K,X1,E2,G,IG,L,LM1 )
                             
          IF( IG .EQ. 1 )  GO TO  50                                        
          IF( E2 .GT. E1 )  GO TO 50                                        
                                              
          H1 = E2 - F0 - C1*RAM2*SUM0                                       
          SUM = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)          
          DO 25 I=1,K                                                       
                                          
              SUM = SUM + G(I)*H(I)
       25 CONTINUE
          H2 = SUM - C2*SUM0                                                
          IF(H1.LE.0.0_dp .AND. H2.GE.0.0_dp)  RETURN                         
                                                 
30        RAM3 = RAM2*4._dp
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          DO 40  I=1,K                                                      

                 X1(I) = X(I) + RAM3*H(I)
       40 CONTINUE
                             
          CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,K,X1,E3,G,IG,L,LM1 )
          IF( IG.EQ.1 )  GO TO  500                                         
                          
          IF( E3 .GT. E2 )  GO TO 70                                        
          IF(RAM3.GT.1.0E+10_dp .AND. E3.LT.E1)  GO TO 45                       
          IF(RAM3.GT.1.0E+10_dp .AND. E3.GE.E1)  GO TO 46                       
          RAM1 = RAM2                                                       
          RAM2 = RAM3                                                       
          E1 = E2                                                           
          E2 = E3                                                           
          GO TO 30                                                          
                                                                       
       45 RAM = RAM3                                                        
          EE = E3                                                           
          RETURN                                                            
                                                                      
       46 RAM = 0.0_dp                                                      
          RETURN                                                            
                                                                       
       48 E2 = 1.0E+30_dp                                                       
                                                                       
       50 RAM3 = RAM2                                                       
          E3 = E2                                                           
          RAM2 = RAM3*0.1_dp                                                 
          IF( RAM2*HNORM .LT. CONST2 )  GO TO  400
          !DIR$ VECTOR ALIGNED
          !DIR$ SIMD
          DO 60  I=1,K                                                      
                               
               X1(I) = X(I) + RAM2*H(I)
       60 CONTINUE
                               
          CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,K,X1,E2,G,IG,L,LM1 )
                               
          IF( E2.GT.E1 )  GO TO 50                                          
                                         
          H1 = E2 - F0 - C1*RAM2*SUM0                                       
          SUM = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)
          DO 65 I=1,K                                                       
                                          
            SUM = SUM + G(I)*H(I)
      65 CONTINUE
         H2 = SUM - C2*SUM0                                                
         IF(H1.GT.0.0_dp .OR. H2.LT.0.0_dp)  GO TO 70                        
         RAM = RAM2                                                        
         RETURN                                                            
                                            
      70 RET = 80
         GO TO 200                                                         
         !DIR$ VECTOR ALIGNED
         !DIR$ SIMD
      80 DO 90  I=1,K                                                      
                       
              X1(I) = X(I) + RAM*H(I)
      90 CONTINUE
                         
         CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,K,X1,EE,G,IG,L,LM1 )
                                                      
         IFG = 0                                                           
                                       
         SUB = 300
         SUB = 200
      95 RET = 130
         IF( RAM .GT. RAM2 )  GO TO 110                                    
         IF( EE .GE. E2 )  GO TO 100                                       
         RAM3 = RAM2                                                       
         RAM2 = RAM                                                        
         E3 =E2                                                            
         E2 =EE                                                            
                                 
         IF( SUB .EQ. 200 ) GO TO 200
         IF( SUB .EQ. 300 ) GO TO 300
                                                                       
     100 RAM1 = RAM                                                        
         E1 = EE                                                           
                                     
         IF( SUB .EQ. 200 ) GO TO 200
         IF( SUB .EQ. 300 ) GO TO 300
                                                                       
     110 IF( EE .LE. E2 )  GO TO 120                                       
         RAM3 = RAM                                                        
         E3 = EE                                                           
                                    
          IF( SUB .EQ. 200 ) GO TO 200
          IF( SUB .EQ. 300 ) GO TO 300
                                                                       
      120 RAM1 = RAM2                                                       
          RAM2 = RAM                                                        
          E1 = E2                                                           
          E2 = EE                                                           
                                 
          IF( SUB .EQ. 200 ) GO TO 200
          IF( SUB .EQ. 300 ) GO TO 300
                                                                       
      130 DO 140  I=1,K                                                     
                              
              X1(I) = X(I) + RAM*H(I)
      140 CONTINUE
                            
          CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,K,X1,EE,G,IG,L,LM1 )
                                          
          SUB = 200
          IFG = IFG+1                                                       
                                                                 
          H1 = EE - F0 - C1*RAM*SUM0                                        
          SUM = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)        
          DO 145 I=1,K                                                      
                                
              SUM = SUM + G(I)*H(I)
      145 CONTINUE
          H2 = SUM - C2*SUM0                                                
          IF( H1.LE.0.0_dp .AND. H2.LE.0.0_dp)  GO TO 150                    
          IF( IFG .LE. 20 )  GO TO 95                                       
                                                                       
      150 IF( E2 .LT. EE )  RAM = RAM2                                      
          RETURN                                                            
                                                                       
!C      -------  INTERNAL SUBROUTINE SUB1  -------                       
      200 IF( RAM3-RAM2 .GT. 5.0_dp*(RAM2-RAM1) )  GO TO 202                 
          IF( RAM2-RAM1 .GT. 5.0_dp*(RAM3-RAM2) )  GO TO 204                 
          A1 = (RAM3-RAM2)*E1                                               
          A2 = (RAM1-RAM3)*E2                                               
          A3 = (RAM2-RAM1)*E3                                               
          B2 = (A1+A2+A3)*2.D0                                              
          B1 = A1*(RAM3+RAM2) + A2*(RAM1+RAM3) + A3*(RAM2+RAM1)             
          IF( B2 .EQ. 0._dp )  GO TO 210                                     
          RAM = B1 /B2                                                      
                                      
        IF( RETURN .EQ. 80 ) GO TO 80
        IF( RETURN .EQ. 130 ) GO TO 130
    202 RAM = (4.0_dp*RAM2 + RAM3)/5.0_dp                                  
                                    
        IF( RETURN .EQ. 80 ) GO TO 80
        IF( RETURN .EQ. 130 ) GO TO 130
    204 RAM = (RAM1 + 4.0_dp*RAM2)/5.0_dp                                  
                                         
        IF( RETURN .EQ. 80 ) GO TO 80
        IF( RETURN .EQ. 130 ) GO TO 130
                                                                       
    210 IG = 1                                                            
        RAM = RAM2                                                        
        RETURN                                                            
!C                                                                       
!C      -------  INTERNAL SUBROUTINE SUB2  -------                       
!C                                                                       
    300 IF( RAM3-RAM2 .GT. RAM2-RAM1 )  GO TO 310                         
        RAM = (RAM1+RAM2)*0.5_dp                                           
                                      
        IF( RETURN .EQ. 80 ) GO TO 80
        IF( RETURN .EQ. 130 ) GO TO 130
                                                                       
    310 RAM = (RAM2+RAM3)*0.5_dp                                           
                                   
        IF( RETURN .EQ. 80 ) GO TO 80
        IF( RETURN .EQ. 80 ) GO TO 130
                                                                    
    400 RAM = 0._dp                                                        
        RETURN                                                            
                                                                      
500     RAM = (RAM2+RAM3)*0.5_dp
        !DIR$ VECTOR ALIGNED
        !DIR$ SIMD
    510 DO 520  I=1,K                                                     
                                          
           X1(I) = X(I) + RAM*H(I)
    520 CONTINUE
                             
        CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,N,K,X1,E3,G,IG,L,LM1 )
                         
        IF( IG.EQ.1 )  GO TO 540                                          
        IF( E3.GT.E2 )  GO TO 530                                         
        RAM1 = RAM2                                                       
        RAM2 = RAM                                                        
        E1 = E2                                                           
        E2 = E3                                                           
        GO TO 500                                                         
                                                                       
    530 RAM3 = RAM                                                        
        GO TO 70                                                          
                                                                       
    540 RAM = (RAM2+RAM)*0.5_dp                                           
        GO TO 510                                                         
                   
    END SUBROUTINE
                             

    SUBROUTINE  LOGTRF( Z,IMIS,N,ilog,ier )
         
!C                                                                       
!C ... LOG TRANSFORMATION ...                                            
!C                                                                       
                                            
          INTEGER(kind=int4), dimension(N) :: IMIS 
          REAL(kind=dp) :: N, ilog, ier
          REAL(kind=dp), dimension(N) :: Z 
          ! Locals
          INTEGER(kind=int4) :: I
          REAL(kind=dp) :: DJACOB, FC, SIG2, AIC, FI, SIG2I, AICI
          REAL(kind=dp), dimension(200) :: GI,GC
          COMMON  /CMFUNC/  DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,GI,GC
                                                                       
          ier = 0
          DJACOB = 0.0_dp                                                  
          if(ilog .eq. 0) return
          ier = -1
          DO 10 I=1,N                                                       
                                        
             if(IMIS(i) .ne. 1) then
                 if(Z(I) .le. 0) return
                 DJACOB = DJACOB - DLOG(Z(I)) 
                 Z(I) = DLOG( Z(I) )
            end if
    10   continue
        ier = 0
    END SUBROUTINE
    
    
                               
    SUBROUTINE  OPTMIZ( FUNCT,Z,E,TDAY,IMIS,NN,X,N,L,LM1 )
         
!C                                                                       
!C  ...  NUMERICAL OPTIMIZATION  ...                                     
!C            LATEST REVISION:  JUNE 20, 1983                            
!C                                                                       

          INTEGER(kind=4), dimension(NN) :: IMIS
          !!DIR$ ASSUME_ALIGNED IMIS:64
          INTEGER(kind=4) ::  NN, N, L, LM1
          REAL(kind=8), dimension(NN) :: Z
          !DIR$ ASSUME_ALIGNED Z:64
          REAL(kind=8), dimenSion(L,LM1,NN) :: E
          !DIR$ ASSUME_ALIGNED E:64
          REAL(kind=8), dimension(NN,7)     :: TDAY
          !DIR$ ASSUME_ALIGNED TDAY:64
          REAL(kind=8), dimension(N)        ::  X
          !DIR$ ASSUME_ALIGNED X:64
          ! Locals
          INTEGER(kind=int4) ::   ISW, ISMT, IDIF, LOG, MESH, ICOUNT, &
                             I,ICC,J
          REAL(kind=dp)    ::   DJACOB, FC, SIG2, AIC, FI, SIG2I, AICI, &
                             TAU2, EPS1, EPS2, CONST1, XM, SUM, S1, S2, STEM, &
                             SS, DS2, GTEM, ED, RAMDA, XMB
          REAL(kind=dp), dimension(N)   :: DX, G, G0, Y, WRK, S
          REAL(kind=dp), dimension(N,N) :: H
          REAL(kind=dp), dimension(200) :: GI,GC
!DIR$ ATTRIBUTES ALIGN : 64 :: DX,G,G0,Y,WRK,S,H,GI,GC            

          COMMON    /CCC/     ISW, ISMT, IDIF, LOG, MESH              
          COMMON  /CMFUNC/    DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,GI,GC
          EXTERNAL   FUNCT
      
          DATA  TAU2  /  0.1_dp  /
          DATA  EPS1 , EPS2  / 0.01_dp, 0.01_dp  /                           
          CONST1 = 1.0E-50_dp                                                 
          ISW = 0                                                           

          XM = 0
          CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,NN,N,X,XM,G,IG,L,LM1 )
!C                                                                       
!C          INITIAL ESTIMATE OF INVERSE OF HESSIAN                       
!C                                                                       
          ICOUNT=0


     1000 CONTINUE
          H(1:N,1:N) = 0.0_dp                                                   
          S(1:N)     = 0.0_dp                                                    
          DX(1:N)    = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 20  I=1,N
             H(I,I) = 1.0_dp
       20 CONTINUE
          ICC = 0                                                           

          ICOUNT=ICOUNT+1
          IF(ICOUNT .GT. 4) THEN

             RETURN
          ENDIF
                            
!C  ...  QUASI NEWTON ALGORITHM  ...                                     
!C                                                                       
    2000  ICC = ICC + 1                                                     
          IF( ICC .EQ. 1 )   GO TO 120
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                       
          DO 40  I=1,N                                                      
                                       
             Y(I) = G(I) - G0(I)
      40  CONTINUE
             DO 60  I=1,N
                !DIR$ VECTOR ALIGNED
                !DIR$ SIMD REDUCTION(+:SUM)
               SUM = 0.0_dp                                                      
               DO 50  J=1,N                                                      
                                      
                     SUM = SUM + Y(J)*H(I,J)
            50 CONTINUE
                                                    
               WRK(I) = SUM
       60 CONTINUE
          S1 = 0.0_dp                                                      
          S2 = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S1)
!DIR$ SIMD REDUCTION(+:S2)          
          DO 70  I=1,N                                                      
               S1 = S1 + WRK(I)*Y(I)                                             
                                            
               S2 = S2 + DX(I) *Y(I)
       70 CONTINUE
          IF( S1.LE.CONST1 .OR. S2.LE.CONST1 )  GO TO 900                   
!C                                                                       
!C  ...  BFGS FORMULA FOR UPDATING INVERSE OF HESSIAN MATRIX  ...        
!C                                                                       
          STEM = S1 / S2 + 1.0_dp                                          
                                                  
          DO 111  I=1,N
             !DIR$ VECTOR ALIGNED
             !DIR$ SIMD
             DO 110  J=I,N                                                     
                H(I,J) = H(I,J)- (DX(I)*WRK(J)+WRK(I)*DX(J)-DX(I)*DX(J)*STEM)/S2  
                                                  
                H(J,I) = H(I,J)
        110 CONTINUE
      111 CONTINUE
                                                                       
      120 SS = 0.0_dp                                                        
          DO 150  I=1,N                                                     
             SUM = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)
                DO 140  J=1,N                                                     
                                         
                     SUM = SUM + H(I,J)*G(J)
            140 CONTINUE
          SS = SS + SUM * SUM                                               
                                                    
          S(I) = -SUM
      150 CONTINUE
                                                                       
          S1 = 0.0_dp                                                        
          S2 = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S1)
!DIR$ SIMD REDUCTION(+:S2)           
          DO 170  I=1,N                                                     
               S1 = S1 + S(I)*G(I)                                               
                                               
               S2 = S2 + G(I)**2
      170 CONTINUE
          DS2 = DSQRT(S2)                                                   
          GTEM = DABS(S1) / DS2                                             
    
          IF( S1 .GE. 0.0_dp)  GO TO  1000                                  
          ED = XM                                                           
!C                                                                       
!C  ...  LINE SEARCH  ...                                                
!C                                                                       
                      
          CALL LINEA1(FUNCT,Z,E,TDAY,IMIS,NN,L,LM1,X,S,RAMDA,ED,G,N,IG)
                                                                       
          S1 = 0.0_dp                                                       
          DO 210  I=1,N                                                     
                DX(I) = S(I)*RAMDA                                                
                S1 = S1 + DX(I)**2                                                
                G0(I) = G(I)                                                      
                                       
                X(I) = X(I) + DX(I)
      210 CONTINUE
          XMB  = XM                                                         
          ISW  = 0                                                          

          CALL  FUNCND( FUNCT,Z,E,TDAY,IMIS,NN,N,X,XM,G,IG,L,LM1 )
                                                                       
          S2 = 0._dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S2)
          DO 220  I=1,N                                                     

               S2 = S2 + G(I)**2
      220 CONTINUE
          IF( DSQRT(S2) .LT. TAU2 )   GO TO 900                             
          IF( XMB-XM .LT. EPS1  .AND.  DSQRT(S1) .LT. EPS2 )  GO TO 900     
          IF( XMB-XM .LT. 0.0001_dp .AND. ICC .GT. N ) GO TO 900
                               
          GO TO 2000                                                        
                                                                       
      900 CONTINUE                                                          
          S2 = 0.0_dp                                                      
          DO 230 I=1,N                                                      
                                            
             S2 = S2 + G(I)**2
      230 CONTINUE
          IF( DSQRT(S2) .GT. 1.0_dp )  GO TO 1000                            
    END SUBROUTINE
    


    SUBROUTINE  PLOTDD( N,Z,E,LM1,TRADE,COMP1,COMP2,COMP3, COMP4,COMP5)
                        
                                     

!C  ...  PLOT ESTIMATED PARAMETRS, ORIGINAL DATA AND ESTIMATED PARAMETERS
!C

          INTEGER(kind=4) :: N, LM1
          REAL(kind=8), dimension(N) :: Z, COMP1, COMP2, COMP3,COMP4,COMP5
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64,COMP1:64,COMP2:64,COMP3:64,COMP4:64,COMP5:64
#endif
          REAL(8), dimenSion(L,LM1,N) :: E
#if defined __ICC
          !DIR$ ASSUME_ALIGNED E:64
#endif
          REAL(8), dimension(N,7) :: TRADE
#if defined __ICC          
          !DIR$ ASSUME_ALIGNED TRADE:64
#endif
          ! Locals 
          INTEGER(kind=4) ::  PERIOD, SORDER,M1, M2, M3, M4, M5, M, L,NYEAR,nmonth &
                            ISW, ISMT, IDIF, LOG, MESH, M12, M123, M1234,  &
                            I,J,
          REAL(kind=8)    ::  SUM, tmp
          REAL(kind=8), dimension(N,M5) :: REG 
!DIR$ ATTRIBUTES ALIGN : 64 :: REG        
          COMMON     /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER, NYEAR, nmonth
                      
          COMMON     /CCC/     ISW, ISMT, IDIF, LOG, MESH              



                                                     
          M12 = M1 + M2                                                     
          M123= M1 + M2 + M3                                                
          M1234=M1 + M2 + M3 + M4
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                
          DO 5 I=1,N
               COMP1(I) = 0.0_dp
               COMP2(I) = 0.0_dp
               COMP3(I) = 0.0_dp
               COMP4(I) = 0.0_dp
        5 CONTINUE
!C
!C  ...  PLOT ORIGINAL DATA AND TREND  ...                               
               !C
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                         
          DO 10 I=1,N                                                       
                                            
             COMP1(I) = E(1,1,I)
       10 CONTINUE
                                                                     
             IF( SORDER .NE. 0) THEN
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))               
               DO 20 I=1,N                                                       

                    COMP2(I) = E(1,M1+M2+1,I)
            20 CONTINUE
          END IF
                                         
                                          

          IF( M4 .EQ. 6 )  then
             DO 35 I=1,N                                                       
                SUM = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)
                   DO 30 J=1,6                                                       
             
                        SUM = SUM + E(1,M123+J,N)*(TRADE(I,J)-TRADE(I,7))
                30 CONTINUE
                                                 
                   E(2,1,I) = SUM
          35 CONTINUE
          end if
          if(m4 .eq. 1) then
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))              
                 DO 37 I=1,N
                      tmp=trade(I,2)+trade(I,3)+trade(I,4)+trade(I,5)+trade(I,6)

                      e(2,1,i) = (trade(I,1)+trade(I,7)-0.4*tmp)*e(1,M123+1,n)
           37   CONTINUE
          end if


                                   
          IF( M5 .EQ. 0 )  GO TO 60                                         
          DO 55 I=1,N                                                       
             SUM = 0.0_8
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUM)
                 DO 50 J=1,M5                                                      
                           
                   SUM = SUM + E(1,M1234+J,N)*REG(I,J)
              50 CONTINUE
                                                 
                 E(2,2,I) = SUM
       55 CONTINUE
       60 CONTINUE                                                          
    
          DO 70 I=1,N                                                       

             COMP5(I) = Z(I) - E(1,1,I)*ID(M1) - E(1,M1+1,I)*ID(M2) - &            
             E(1,M12+1,I)*ID(M3) - E(2,1,I)*ID(M4) - E(2,2,I)*ID(M5)
       70 CONTINUE
                                                                       
          IF( M2 .EQ. 0 )  GO TO 100                                        
      
          DO 80 I=1,N                                                       
                                       
               COMP3(I) = E(1,M1+1,I)
       80 CONTINUE
                                                                    
100            IF( M4 .EQ. 0 )  GO TO 130
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))     
          DO 110 I=1,N                                                      
                                                  
             COMP4(I) = E(2,1,I)
      110 CONTINUE
                                                     
      130 CONTINUE                                                          
    END SUBROUTINE
    
                                                                 
                
    SUBROUTINE  REDATAD( DATA,ISW,X,N,XM ) 
        
!C                                                                       
!C     THIS SUBROUTINE IS USED FOR THE LOADING OF ORIGINAL DATA,         
!C     THE DATA IS LOADED THROUGH THE DEVICE SPECIFIED BY @MT@.          
!C     EACH DATA SET IS COMPOSED OF TITLE, DATA LENGTH, DATA FORMAT      
!C     AND ORIGINAL DATA.  IF ISW IS SET EQUAL TO 0, THE MEAN VALUE      
!C     IS SUBTRACTED FROM THE ORIGINAL DATA.                             
!C                                                                       
!C       INPUTS:                                                         
!C         MT:     INPUT DEVICE SPECIFICATION                            
!C         ISW:    =0 MEAN VALUE IS SUBTRACTED FROM THE ORIGINAL DATA    
!C                 =1 MEAN VALUE IS NOT SUBTRACTED                       
!C         IPR:    =1 TO PRINT OUT DATA BY D-FORMAT                      
!C                 =2 TO PRINT OUT DATA BY F-FORMAT                      
!C         TITLE:  TITLE OF DATA                                         
!C         N:      DATA LENGTH                                           
!C         FORM:   INPUT DATA FORMAT SPECIFICATION                       
!C         X(I) (I=1,N):  ORIGINAL DATA                                  
!C                                                                       
!C       OUTPUTS:                                                        
!C         X:      ORIGINAL DATA                                         
!C         N:      DATA LENGTH                                           
!C         TITLE:  TITLE OF DATA                                         
!C         XM:     MEAN                                                  
!C                                                                       

          INTEGER(kind=4) :: ISW, N         
          REAL(kind=8), dimension(N) :: DATA, X
#if defined __ICC
          !DIR$ ASSUME_ALIGNED DATA:64,X:64
#endif
          REAL(kind=8) ::  XM
          ! Locals
          INTEGER(kind=4)  :: I
          REAL(kind=8) :: FN, S1, S2, S3, S4, XX
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                      
          DO 53 I=1,N

               X(I)=DATA(I)
     53   CONTINUE



          FN = N                                                            
          S1 = 0.0_dp
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:S1)
          DO 10 I=1,N                                                   
                                               
                S1 = S1 + X(I)
       10 CONTINUE
          XM = S1 / FN                                                      
          S2 = 0.0_8                                                       
          S3 = 0.0_8                                                        
          S4 = 0.0_8                                                        
          DO 20  I=1,N                                                      
                XX = X(I) - XM                                                    
                S2 = S2 + XX**2                                                   
                S3 = S3 + XX**3                                                   
                                              
                S4 = S4 + XX**4
       20 CONTINUE
                                                                       
          S2 = S2 / FN                                                      
          S3 = S3 / (FN*S2*DSQRT(S2))                                       
          S4 = S4 / (FN*S2*S2)                                              
                                  
          IF( ISW .EQ. 1 )  RETURN                                          
!C                                                                       
!C       MEAN DELETION                                                   
!C                                                                       
          DO 30  I=1,N                                                      
                                            
              X(I) = X(I) - XM
       30 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  SETFGH                                                
!C                                                                       
!C  ...  SET F, G AND H MATRICES OF STATE SPACE MODEL  ...               
!C                                                                       

          INTEGER(kind=4) :: PERIOD, SORDER, M1, M2, M3, M4, M5, M, L, NYEAR, nmonth, &
                           I,ISEA
          REAL(kind=8)       ::  DI
          REAL(kind=8), dimension(10)  :: F1,F2,A1,A2
          REAL(kind=8), dimension(312) :: F3,A3
          REAL(kind=8), dimension(3)   :: UI
          REAL(kind=8), dimension(7)   :: TDF
          COMMON    /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER, NYEAR, nmonth
                         
          COMMON  /COMSM3/  F1, F2, F3, A1, A2, A3
                        ,DI, UI(3), TDF(7)
                                  
                                                                       
          DI = 1.0_8                                                        
                                                                       
          IF( M1 .EQ. 0 )  GO TO 40                                         
                                            
          IF( M1 .EQ. 1 ) GO TO 10
          IF( M1 .EQ. 2 ) GO TO 20
          IF( M1 .EQ. 3 ) GO TO 30                                               
                                                                       
       10 F1(1) =  1.0_8                                                   
          A1(1) =  1.0_8                                                   
          GO TO 40                                                          
       20 F1(1) = -1.0_8                                                    
          F1(2) =  2.0_8                                                    
          A1(1) =  2.0_8                                                    
          A1(2) = -1.0_8                                                    
          GO TO 40                                                          
       30 F1(1) =  1.0_8                                                   
          F1(2) = -3.0_8                                                   
          F1(3) =  3.0_8                                                    
          A1(1) =  3.0_8                                                    
          A1(2) = -3.0_8                                                    
          A1(3) =  1.0_8                                                    
                                   
       40 IF( SORDER .EQ. 0 )  GO TO 160                                    
          IF( SORDER .EQ. 2 )  GO TO 130                                    
          IF( SORDER .EQ. -1 ) GO TO 80                                     
          DO 70  I=1,M3                                                     
               A3(I) = -1.0_8                                                    

               F3(I) = -1.0_8
       70 CONTINUE
          GO TO 150                                                         

       80 CONTINUE                                                      
          A3(1:M3) = 0.0_8                                                    
          F3(1:M3) = 0.0_8                                                    
          A3(M3)= 1.0_8                                                    
          F3(1) = 1.0_8                                                     
          GO TO 150                                                         
                                              
      130 DO 140  I=1,PERIOD-1
                 F3(I) = -I                                                        
                 A3(I) = -I - 1                                                    
                                          
                 F3(PERIOD+I-1) = I - PERIOD - 1                                   

                 A3(PERIOD+I-1) = I - PERIOD
      140 CONTINUE
      150 CONTINUE                                                          
      160 CONTINUE                                                          
    END SUBROUTINE
    
    SUBROUTINE  SMOTH3( Z,R,S,T,TRADE,IMIS,N,LM1,F,ILKF,ISMT )
                        
!C                                                                       
!C     ...  INFORMATION SQUARE ROOT FILTER & SMOOTHER  ...               
!C          FOR SEASONAL ADJUSTMENT                                      
!C                                                                       

      INTEGER(kind=4), dimension(N) :: IMIS
#if defined __ICC
      !DIR$ ASSUME_ALIGNED IMIS:64
#endif
          INTEGER(kind=4) ::  N, LM1, ILKF, ISMT
          REAL(kind=8), dimension(N) :: Z
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Z:64
#endif
          REAL(kind=8), dimension(LM1+1,LM1) :: R
#if defined __ICC
          !DIR$ ASSUME_ALIGNED R:64
#endif
          REAL(kind=8), dimension(M+1,M+1) :: S
#if defined __ICC
          !DIR$ ASSUME_ALIGNED S:64
#endif
          REAL(kind=8), dimension(L,LM1,N) ::  T
#if defined __ICC
          !DIR$ ASSUME_ALIGNED T:64
#endif
          REAL(kind=8), dimension(N,7) :: TRADE
#if defined __ICC
          !DIR$ ASSUME_ALIGNED TRADE:64
#endif
          REAL(kind=8) :: F
          INTEGER :: PERIOD, SORDER, M1, M2, M3, M4, M5, M, L, NYEAR, nmonth, &
                     M12,M123,M45,LM,L12,L123,L1234,LL2,NNN,II,J,I,JJ,III
          REAL(kind=8) :: DI, DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,SUM,tmpp,tmp,PAI, SDET
          REAL(kind=8), dimension(N,M5)  ::  REG 
          REAL(kind=8), dimension(LM1+1) ::  D 
          REAL(kind=8), dimension(3,3)   ::  WI 
          REAL(kind=8), dimension(LM1)   ::  X 
          REAL(kind=8), dimension(L)     ::  TT 
          REAL(kind=8), dimension(M)     ::  E
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: REG,D,WI,X,TT,E
#endif         
          REAL(kind=8), dimension(312) :: F3,A3
          REAL(kind=8), dimension(200) :: GI,GC
          REAL(kind=8), dimension(10)  :: F1,F2,A1,A2
          REAL(kind=8), dimension(3)   :: UI
          REAL(kind=8), dimension(7)   :: TDF
     

          COMMON    /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER,   NYEAR, nmonth
                      
          COMMON  /COMSM3/  F1, F2, F3, A1, A2, A3, DI, UI, TDF   
                                              
          COMMON  /CMFUNC/  DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,GI,GC

          DATA  PAI/3.1415926535_8/                                         
                                                                       
                                 
          M12  = M1 + M2                                                    
          M123 = M1 + M2 + M3                                               
          M45 = M4 + M5                                                     
          LM   = L + M                                                      
          L1   = L + M1                                                     
          L12  = L + M1 + M2                                                
          L123 = L + M1 + M2 + M3                                           
          L1234= L + M1 + M2 + M3 + M4                                      
          LL2  = ID(M1) + ID(M2)                                            
          SIG2 = 0.0_8                                                   
          SDET = 0.0_8
          NNN = 0                                                      

          DO 500  II=1,N
!C                                                                       
!C     ...  TIME  UPDATE (PREDICTION)  ...                               
!C                                                                       
                IF( M1 .EQ. 0 )  GO TO 140                                        
                IF(M1.EQ.1)  GO TO 115                                            
                                                 
               DO 111  J=2,M1
                       DO 110  I=1,J                                                     
                                           
                           R(L+I,L+J-1) = S(I,J)
                   110 CONTINUE
           111 CONTINUE
           115 DO 130  I=1,M1                                                    
                              SUM = 0.0_8

                       DO 120  J=I,M1                                                    
                                       
                              SUM = SUM + S(I,J)*F1(J)
                   120 CONTINUE
                                                
                       R(L+I,L1) = SUM
           130 CONTINUE
                                                                       
           140 IF( M2 .EQ. 0 )  GO TO 5                                          
               IF(M2 .EQ. 1)  GO TO 155                                          
                                                 
               DO 151  J=2,M2
                       JJ = M1 + J                                                       
                       DO 150  I=1,JJ                                                    
                                    
                              R(L+I,L1+J-1) = S(I,M1+J)
                   150 CONTINUE
           151 CONTINUE
           155 DO 170  I=1,M2                                                    
                       SUM = 0.0_8

                       DO 160  J=I,M2                                                    
                                   
                               SUM = SUM + S(M1+I,M1+J)*F2(J)
                   160 CONTINUE
                                              
                               R(L1+I,L12) = SUM
                   170 CONTINUE
               DO 190  I=1,M1                                                    
                      SUM = 0.0_8                                                      
                           DO 180  J=1,M2                                                    
                                      
                            SUM = SUM + S(I,M1+J)*F2(J)
                       180 CONTINUE
                                                
                           R(L+I,L12) = SUM
           190 CONTINUE
                                                                      
             5 IF( M3 .EQ. 0 )  GO TO 55                                         
                                                  
               DO 11  J=2,M3
                      JJ = M12 + J                                                      
                           DO 10  I=1,JJ                                                     
                                   
                                  R(L+I,L12+J-1) = S(I,M12+J)
                        10 CONTINUE
            11 CONTINUE
               DO 30  I=1,M3                                                     
                      SUM = 0.0_8                                                  
                      DO 20  J=I,M3                                                     
                               
                             SUM = SUM + S(M12+I,M12+J)*F3(J)
                   20 CONTINUE
                                             
                      R(L12+I,L123) = SUM
            30 CONTINUE

               DO 50  I=1,M12                                                    
                       SUM = 0.0_dp                                                     
                       DO 40  J=1,M3                                                     
                                    
                              SUM = SUM + S(I,M12+J)*F3(J)
                    40 CONTINUE
                                               
                       R(L+I,L123) = SUM
            50 CONTINUE
                                                                       
            55 IF( M45 .EQ. 0 )  GO TO 70                                        

               DO 61  J=1,M45
                      JJ = M123 + J                                                     
                      DO 60  I=1,JJ                                                     

                             R(L+I,L123+J) = S(I,M123+J)
                   60 CONTINUE
            61 CONTINUE
            70 CONTINUE                                                          
                                                                       
               IF( M1 .EQ. 0 )  GO TO 215                                        
               DO 210  I=1,M1                                                    
                                          
                       R(L+I,1) = -R(L+I,L+1)
           210 CONTINUE
           215 IF( M2 .EQ. 0 ) GO TO 225                                         
               DO 220  I=1,M12                                                   

                       R(L+I,LL2) = -R(L+I,L+M1+1)
           220 CONTINUE
                                                                       
           225 IF( M3 .EQ. 0 )  GO TO 235                                        
               DO 230  I=1,M123                                                  
                                   
                       R(L+I,L) = -R(L+I,L+M12+1)
           230 CONTINUE

           235 CONTINUE
               R(1:L,1:LM+1) = 0.0_dp
               DO 240  I=1,M                                                     
                                         
                       R(L+I,L+M+1) = S(I,M+1)
           240 CONTINUE
                                                                       
               DO 260 I=1,L                                                      
                                                   
                      R(I,I) = UI(I)
           260 CONTINUE
                     
               CALL  HUSHL7( R,D,LM1+1,LM1,L12+1,L+M123 )
                                                   
               DO 301  I=1,L
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                       DO 300  J=1,LM+1                                                  

                              T(I,J,II) = R(I,J)
                   300 CONTINUE
           301 CONTINUE
!C                                                                       
!C     ...  MEASUREMENT  UPDATE (FILTERING)  ...                         
!C                                                                       
!c    modified at 96.10 by S.S.

              IF( IMIS(II) .EQ. 1 )  GO TO 420

              NNN=NNN+1
                                              
              DO 411  J=1,M+1
                      S(M+1,J) = 0.0_dp                                               
                      DO 410  I=1,J                                                     
                                            
                              S(I,J) = R(L+I,L+J)
                  410 CONTINUE
          411 CONTINUE
                                                                       
              S(M+1,1)    = DI                                                  
              S(M+1,M1+1) = DI                                                  
              S(M+1,M12+1)= DI                                                  
              S(M+1,M+1)  = DI*Z(II)                                            
              IF( M4 .EQ. 6 )  then
                   DO 414  I=1,6                                                     
                         JJ = II                                                           
                         IF( ILKF .EQ. 0 )  JJ = N - II + 1                                
                
                               S(M+1,M123+I) = DI*(TRADE(JJ,I) - TRADE(JJ,7))
               414 CONTINUE
             end if

             if(M4 .eq. 1) then

                    JJ = II                                                           
                    IF( ILKF .EQ. 0 )  JJ = N - II + 1                                
                    tmpp=TRADE(jj,2)+TRADE(jj,3)
                    tmpp=tmpp+TRADE(jj,4)+TRADE(jj,5)+TRADE(jj,6)
                    s(m+1,m123+1)=di*(TRADE(jj,1)+TRADE(jj,7)-0.4_dp*tmpp)
             end if

                                     
             IF( M5 .EQ. 0 )  GO TO 418
             DO 417  I=1,M5
                                  
                    S(M+1,M123+M4+I) = REG(I,II)
         417 CONTINUE
         418 CONTINUE                                                          
                             
             CALL  HUSHL4( S,M+1,M+1,M+1,1,0 )
                 
             IF(ILKF .EQ. 0)  GO TO 500                                        
             SIG2 = SIG2 + S(M+1,M+1)**2                                       
             DO 440  I=1,M                                                     
          
                  SDET = SDET + DLOG( S(I,I)**2 ) - DLOG( R(L+I,L+I)**2 )
         440 CONTINUE
             GO TO 500                                                         
!C                                                                       
!C  ...  LONG RANGE PREDICTION  ...                                      
!C                                                                       

             CALL  RECOEF( R,LM,LM,LM1+1,X )
             SUM = ID(M1)*X(L+1) + ID(M2)*X(L1+1) + ID(M3)*X(L12+1)            
             IF( M4 .EQ. 6 )  then
                   DO 431 J=1,6                                                      

                        SUM = SUM + (TRADE(II,J)-TRADE(II,7))*X(L123+J)
               431 CONTINUE
             end if
             if(m4 .eq. 1) then
                tmp=TRADE(II,2)+TRADE(II,3)+TRADE(II,4)+TRADE(II,5)+TRADE(II,6)
                sum=sum+(TRADE(II,1)+TRADE(II,7)-0.4*tmp)*x(L123+1)
            end if
                                        
!C                                                                       
!C  ...  MISSING OBSERVATION  ...                                        
!C                                                                       

         420 DO 426  I=1,M
                   DO 425  J=1,M+1                                                   

                        S(I,J) = R(L+I,L+J)
              425 CONTINUE
         426 CONTINUE
      500 CONTINUE                                                          
!C                                                                       
!C     ... LIKELIHOOD COMPUTATION  ...                                   
!C                                                                       

!C   99/8/12
          IF(ILKF .EQ. 0)  GO TO 600                                        

          SIG2 = SIG2/(2.0_dp*nnn)                                           
          F = -0.5_dp*(nnn*( DLOG(PAI*2._dp) + DLOG(SIG2) + 1.0_dp ) + SDET)   
                                                      
          FC = F                                                            

          AIC = -2.0_dp*(F+DJACOB) + 2.0_dp*(M2 + L + 1 + m)                  
                                                                     
!C     ...  SMOOTHING  ...                                               
!C                                                                       
      600 IF(ISMT .EQ.  0) RETURN                                           

          CALL  RECOEF( S,M,M,M+1,X )                                      
                                                                       
          DO 610 I=1,M                                                      

             E(I) = X(I)
      610 CONTINUE
                                                                       
          DO 1200  III=1,N-1                                                
                                                                       
                    II = N-III+1                                                      
!C                                                                       
!C  ...  WI = INVERSE OF T(I,J)  ...                                     
!C                                                                       
                    WI(1,1) = 1.0_dp/T(1,1,II)                                         
                    IF( L .EQ. 1 )  GO TO 615                                         
                    WI(2,2) = 1.0_dp/T(2,2,II)                                         
                    WI(1,2) = -T(1,2,II)*WI(2,2)*WI(1,1)                              
                    IF( L .EQ. 2 )  GO TO 615                                         
                    WI(3,3) = 1.0_dp/T(3,3,II)                                         
                    WI(2,3) = -T(2,3,II)*WI(2,2)*WI(3,3)                              
                    WI(1,3) = -(T(1,2,II)*WI(2,3) + T(1,3,II)*WI(3,3))*WI(1,1)        
                615 DO 630  I=1,L                                                     
                            SUM = T(I,LM1,II)                                                 
                            DO 620  J=1,M                                                     

                                   SUM = SUM - T(I,L+J,II)*X(J)
                        620 CONTINUE

                            TT(I) = SUM
                630 CONTINUE
                                                                       
                    DO 650  I=1,L                                                     
                             SUM = 0.0_dp                                                      
                             DO 640  J=I,L                                                     
                                      
                                     SUM = SUM + WI(I,J)*TT(J)
                         640 CONTINUE

                             D(I) = SUM
              650 CONTINUE
                  X(1) = X(1) - D(1)                                                
                  IF(M1.GT.0 .AND. M2.GT.0)  X(M1+1) = X(M1+1) - D(2)               
                  X(M12+1) = X(M12+1) - D(L)                                        
                 DO 660  I=1,M                                                     

                         D(I) = X(I)
             660 CONTINUE
                                                                       
                 IF( M1 .EQ. 0 )  GO TO 715                                        
                 DO 710  I=1,M1                                                    
                                             
                         X(I) = F1(I)*D(M1)
             710 CONTINUE
             715 IF(M1.LE.1)  GO TO  730                                           
                 DO 720  I=2,M1                                                    
                                           
                 X(I) = X(I) + D(I-1)
             720 CONTINUE
                                                                       
             730 IF( M2 .EQ. 0 )  GO TO 760                                        
                 DO 740  I=1,M2                                                    

                         X(M1+I) = F2(I)*D(M12)
             740 CONTINUE
                 IF(M2 .LE. 1)  GO TO 760                                          
                 DO 750  I=2,M2                                                    
                                    
                         X(M1+I) = X(M1+I) + D(M1+I-1)
             750 CONTINUE
                                                                       
             760 IF( M3 .LE. 0 )  GO TO 775                                        
                 DO 770  I=1,M3                                                    
                                      
                         X(M12+I) = F3(I)*D(M123)
             770 CONTINUE
             775 IF( M3 .LE. 1 )  GO TO 785                                        
                 DO 780  I=2,M3                                                    

                         X(M12+I) = X(M12+I) + D(M12+I-1)
             780 CONTINUE
                                                                       
             785 CONTINUE                                                          
                                                       
                 DO 790 I=1,M                                                      
                        T(1,I,II) = E(I)                                                  
                                                     
                        E(I) = X(I)
             790 CONTINUE
                                                                       
     1200 CONTINUE                                                          
                                                                       
          DO 1210 I=1,M                                                     
                                                 
                   T(1,I,1) = E(I)
     1210 CONTINUE
          IF( M4 .EQ. 6 ) then
             SUM = 0.0_dp                                                      
             DO 1220 I=1,6                                                     
                     TDF(I) = X(M123+I)                                                
                                             
                     SUM = SUM + TDF(I)
       1220 CONTINUE
            TDF(7) = -SUM                                                     
         end if
         IF( M4 .EQ. 1 ) then
             TDF(1) = X(M123+1)
             TDF(7) = X(M123+1)
             do 1222 i=2,6

                 TDF(i) = -0.4_dp*TDF(1)
        1222 continue
      end if
    END SUBROUTINE
    
                                                                 

    SUBROUTINE  SPARAM0( IPAR,NIP )
         
!C                                                                       
!C  ...  Set or read control parameters ...                              
!C                                                                       

          INTEGER(kind=4), dimension(NIP)  :: IPAR 
          INTEGER(kind=4) :: NIP
          INTEGER(kind=4) :: PERIOD, SORDER, TRADE, ISW, ISMT, IDIF, LOG, MESH, &
                           M1, M2, M3, M4, M5, M, L, NYEAR, nmonth
          COMMON     /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER, NYEAR, nmonth   
                         
        
          COMMON    /CCC/     ISW, ISMT, IDIF, LOG, MESH              
!C                                                                       
!C  ...  SET DEFAULT VALUES  ...                                         
!C                                                                       
          M1 = IPAR(1)       
          M2 = IPAR(2)
          M4 = 0
          M5 = 0                        
          LOG  = IPAR(5)                            
                                       
          ISW  = 1                                                          
          IDIF = IPAR(7)
          if(idif .gt. 2) idif=1
          if(idif .lt. 1) idif=1
          MESH = 1                                                          
          PERIOD = IPAR(3)                               
          SORDER = IPAR(4)                                                 
          TRADE  = IPAR(6)                
          if(TRADE .EQ. 1) TRADE = 7
          IF(TRADE .GE. 1)  NYEAR=IPAR(8)
          IF(TRADE .GE. 1)  nmonth=IPAR(9)
          M3 = (PERIOD - 1)*SORDER                                          
          IF(SORDER.EQ.-1)  M3 = PERIOD                                     
          IF(TRADE .GE. 1)  M4 = TRADE-1                                   
          M = M1 + M2 + M3 + M4 + M5                                        
          L = ID(M1) + ID(M2) + ID(M3)                                      
          L = MAX(2,L)
    END SUBROUTINE
    
                                                               

    SUBROUTINE  SPARAM( A,NA,para,NPA,iopt )
          implicit none
!C                                                                       
!C  ...  Set or read control parameters ...                              
!C                                                                       

          INTEGER(4) :: NA, NPA, iopt
          REAL(8), dimension(NA) :: A 
          REAL(8), dimension(NPA) :: para
          INTEGER(4) :: PERIOD, SORDER, M1, M2, M3, M4, M5, M, L, NYEAR, nmonth , &
                           ISW, ISMT, IDIF, LOG, MESH 
          REAL(8) :: DI
          REAL(8), dimension(3)   :: TAU2 
          REAL(8), dimension(M2)  :: PAC, ARCC
          REAL(8), dimension(300) :: F3,A3
          REAL(8), dimension(10)  ::  F1,F2,A1,A2
          REAL(8), dimension(3)   :: UI
          REAL(8), dimension(7)   :: TDF
   
          COMMON     /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER,   NYEAR, nmonth   
                        
       
          COMMON  /COMSM3/  F1, F2, F3, A1, A2, A3, &    
                        DI, UI, TDF
          COMMON    /CCC/     ISW, ISMT, IDIF, LOG, MESH              
                                                 
          TAU2(1) = 0.005_8                                                
          TAU2(2) = 0.800_8                                                

!C 99/8/12    
          TAU2(3) = 0.001_8                                               

          if(M2 .eq. 0) TAU2(2) = 0.001_8


          TDF(1:7) = 0.0_8
                                               
          DO 20  I=1,M2
                        
                PAC(I) = 0.88_8*(-0.6_8)**(I-1)
       20 CONTINUE

          if(iopt .lt. 0) then
              do 21 i=1,3
                  TAU2(i)=para(i) - 0.0001_8
                  if(TAU2(i) .ge. 1.0_8) TAU2(i)=1.0D0 - 0.00000000000000000001_8
                  if(TAU2(i) .le. 0.0_8) TAU2(i)=0.0D0 + 0.00000000000000000001_8
     21       continue


             if(M2 .gt. 0) then
                 do 22 i=1,m2

                      ARCC(i) = para(3+i)
      22         continue
                 call PARCOR( ARCC,m2,PAC )

            end if
          end if
                
          DO 30 I=1,L                                                       
                    
             A(I) = DASIN( TAU2(I)*2.0_8 - 1.0_8)
       30 CONTINUE
                                     
         IF(M2.EQ.0)  RETURN                                               
                                                                       
         DO 40 I=1,M2                                                      

              A(L+I) = DASIN( PAC(I)/0.90_8 )
      40 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  STATE( X,A,K )  
          implicit none
!C                                                                       
!C  ...  TRANSFORMATION OF STATE VECTOR FOR TIME REVERSED MODEL  ...     
!C                                                                       

          INTEGER(4) :: K
          REAL(8), dimension(K) :: X, A
          ! Locals
          INTEGER(4) :: I,J
          REAL(8) :: SUM
          REAL(8), dimension(K) :: Y
                                                                       
          IF( K .EQ. 0 )  RETURN                                            

          DO 21  I=1,K
                 SUM = A(I)*X(1)                                                   
                 IF( I .LT. K )  SUM = SUM + X(I+1)                                
                 IF( I .EQ. 1 )  GO TO 20                                          
                 DO 10  J=1,I-1                                                    

                       SUM = SUM + A(J)*Y(I-J)
             10 CONTINUE
             20 Y(I) = SUM                                                        
       21 CONTINUE
                                                                       
          X(1) = Y(1)                                                       
          IF( K .EQ. 1 ) RETURN                                             
          DO 40  I=2,K                                                      
              SUM = 0.0_8                                                       
              DO 30  J=I,K                                                      
                               
                  SUM = SUM + A(J)*Y(J-I+2)
          30 CONTINUE

             X(I) = SUM
      40 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE  TRADE( JSYEAR,nmonth,N,TDAY )
          implicit none
                                   

!C
!C  ...  This subroutine computes the number of days of the week
!C       in each month, Nov.1981
!C    modified at '96 by S.S.
!C    This subroutine should not be used after 2099.
!C

          INTEGER(4) :: JSYEAR, nmonth, N
          REAL(8), dimension(N,7) :: TDAY
          ! Locals
          INTEGER(4) :: JS,I2,JJ,II,I1,J,I,IE,I0
          INTEGER(4), dimension(12) :: IX
          DATA   IX  /3,0,3,2,3,2,3,3,2,3,2,3/

          JS = JSYEAR - 1900

          I2 = MOD( JS+(JS-1)/4,7 ) + 1
          JJ = 2-nmonth
          II = 0
 5        II = II + 1
          I1 = II + JS - 1
          IX(2) = 0
          IF( MOD(I1,4) .EQ. 0 )  IX(2) = 1
          IF( MOD(I1+1900,100).EQ.0 )  IX(2) = 0
          IF( MOD(I1+1900,400).EQ.0 )  IX(2) = 1
          DO 30  J=1,12
                DO 10  I=1,7

                   if( JJ.gt.0 ) TDAY(JJ,I) = 4.0_8
           10   CONTINUE

                IE = IX(J)
                IF( IE .EQ. 0 )  GO TO 28
                I0 = I2
                DO 20  I=1,IE
                       I2 = I0 + I
                       IF( I2 .GT. 7 ) I2 = I2 - 7

                       if( JJ.gt.0 ) TDAY(JJ,I2) = 5.0_R64P
           20   CONTINUE



           28   JJ = JJ + 1
                IF( JJ .GT.N ) then 



                   RETURN
                end if
     30   continue
          GO TO 5
    END SUBROUTINE
    

    SUBROUTINE  TRADE2( JSYEAR,nquart,N,TDAY )
          implicit none
                                     

!C
!C  ...  This subroutine computes the number of days of the week
!C       in each quarter.
!C    modified at '96 by S.S.
!C    This subroutine should not be used after 2099.
!C

          INTEGER(4) :: JSYEAR, nquart, N
          REAL(8), dimension(N,7) :: TDAY
          ! Locals
          INTEGER(4) ::  JS,I2,II,JJ,I1,I0,I,J,IE
          INTEGER(4), dimension(4) :: IX
          DATA   IX  /6,7,8,8/

          JS = JSYEAR - 1900

          I2 = MOD( JS+(JS-1)/4,7 ) + 1
          JJ = 2-nquart
          II = 0
    5     II = II + 1
          I1 = II + JS - 1
          IX(1) = 6
          IF( MOD(I1,4) .EQ. 0 )  IX(1) = 7
          IF( MOD(I1+1900,100).EQ.0 )  IX(1) = 6
          IF( MOD(I1+1900,400).EQ.0 )  IX(1) = 7
          DO 30  J=1,4
                 DO 10  I=1,7

                    if( jj.gt.0 ) TDAY(JJ,I) = 12.0_8
           10   CONTINUE

                IE = IX(J)

                IF( IE .EQ. 0 )  GO TO 28
                I0 = I2
                DO 20  I=1,IE
                       I2 = I0 + I
                       IF( I2 .GT. 7 ) I2 = I2- 7
                       IF( I2 .GT. 7 ) I2 = I2- 7

                          if( JJ.gt.0 ) TDAY(JJ,I2) = TDAY(JJ,I2) + 1.0_8
           20   CONTINUE

           28   JJ = JJ + 1
                IF( JJ .GT.N ) RETURN
      30   continue
           GO TO 5
    END SUBROUTINE
    


    subroutine trpar( a,na,para,npa )
          IMPLICIT NONE
          
          INTEGER(4) :: na, npa
          REAL(8), dimension(na)  :: A 
          REAL(8), dimension(npa) :: para
          ! Locals
          INTEGER(4) :: PERIOD, SORDER, M1, M2, M3, M4, M5, M, L, NYEAR, nmonth, &
                           I
         
          REAL(8) ::   tau1, tau2, tau3, DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI, DI
          REAL(8), dimension(M2)  :: ar, atmp 
          REAL(8), dimension(312) :: F3,A3
          REAL(8), dimension(200) :: GI,GC 
          REAL(8), dimension(10)  :: F1,F2,A1,A2
          REAL(8), dimension(7)   :: TDF
          REAL(8), dimension(3)   :: UI
          COMMON    /COMSM2/  M1, M2, M3, M4, M5, M, L, PERIOD, SORDER,  NYEAR, nmonth
                        
          COMMON  /CMFUNC/  DJACOB,FC,SIG2,AIC,FI,SIG2I,AICI,GI,GC
          COMMON  /COMSM3/  F1, F2, F3, A1, A2, A3, DI, UI, TDF
                                                
          tau1 = 0.0_8
          tau2 = 0.0_8
          tau3 = 0.0_8



          para(1) = AIC                                                     
                                                  
          para(2) = FC
          para(3) = SIG2                                                    
    
          TAU1 = 0.5_8*(1.0_8 + DSIN( A(1) )) + 0.0001_8

          IF(L.GE.2)  TAU2 = 0.5_8*(1.0_8 + DSIN( A(2) )) + 0.0001_8
                    
          IF(L.GE.3)  TAU3 = 0.5_8*(1.0_8 + DSIN( A(3) )) + 0.0001_8          
                                                                      
          para(4) = tau1
          para(5) = tau2
          para(6) = tau3
          IF( M2 .EQ. 0 )  GO TO 40                                         
          DO 30  I=1,M2                                                     
                             
              atmp(I) = 0.90_8*DSIN( A(L+I) )
       30 CONTINUE

          CALL  ARCOEFD( atmp,M2,AR )
          do 35 I=1,M2

                para(i+6) = AR(i)
     35   continue
     40   continue
          do 41 i=1,7

                para(i+6+m2) = TDF(i)
     41   continue
    END SUBROUTINE
    
    SUBROUTINE  EXSARF( Z1,N,LAG,ZMEAN,SUM,SD,AIC,DIC,M1,AMIN,SDM1,A1, SDM2,A2,JER )
          implicit none
                        

!cc      PROGRAM  EXSAR                                                    
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  JUN. 29, 1979.......................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.5.1                                                     
!C     __                                 _      __                      
!C     EXACT MAXIMUM LIKELIHOOD METHOD OF SCALAR AR-MODEL FITTING        
!C                                                                       
!C     THIS PROGRAM PRODUCES EXACT MAXIMUM LIKELIHOOD ESTIMATES OF THE   
!C     PARAMETERS OF A SCALAR AR-MODEL.                                  
!C                                                                       
!C     THE AR-MODEL IS GIVEN BY                                          
!C                                                                       
!C               Z(I) = A(1)*Z(I-1) + ... + A(K)*Z(I-K) + E(I)           
!C                                                                       
!C     WHERE E(I) IS A ZERO MEAN WHITE NOISE.                            
!C                                                                       
!C     --------------------------------------------------------------    
!C     THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:    
!C             REDATA                                                    
!C             REDUCT                                                    
!C             ARMFIT                                                    
!C             RECOEF                                                    
!C             ARMLE                                                     
!C             PRINTA                                                    
!C     --------------------------------------------------------------    
!C     INPUTS REQUIRED:                                                  
!C          MT:      INPUT DEVICE SPECIFICATION (MT=5: CARD READER)      
!C          LAG:     UPPER LIMIT OF AR-ORDER, MUST BE LESS THAN 51       
!C                                                                       
!C     --  THE FOLLOWING INPUTS ARE REQUESTED BY SUBROUTINE REDATA  --   
!C          TITLE:  TITLE OF DATA                                        
!C          N:      DATA LENGTH, MUST BE LESS THAN OR EQUAL TO 10000     
!C          DFORM:  INPUT DATA FORMAT SPECIFICATION STATEMENT            
!C                  -- EXAMPLE --     (8F10.5)                           
!C          (Z(I),I=1,N):  ORIGINAL DATA                                 
!C     ---------------------------------------------------------------   
!C                                                                       
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: EXSARF
!C


          INTEGER(4) :: N, LAG, M1, JER
          REAL(8), dimension(N) :: Z1 
          REAL(8) ::  ZMEAN, SUM 
          REAL(8), dimension(LAG+1) :: SD, AIC, DIC 
          REAL(8), dimension(LAG) :: A1,A2
          REAL(8) :: AMIN, SDM1, SDM2 
          ! Locals
          INTEGER(4) :: MJ1,ISW,K,NMK,IPR,
          REAL(8), dimension(N) :: Z 
          REAL(8), dimension(N-LAG,LAG+1) ::  X
          REAL(8), dimension(LAG,LAG) :: A22 
          REAL(8), dimension(LAG) :: SDM22
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: Z,X,A22,SDM22
#endif
                                                                    
         !EXTERNAL   SETX1                                                  

                                                      
          MJ1 = N-LAG
          ISW = 1                                                           

          CALL  REDATA( Z1,Z,N,ZMEAN,SUM )
          K = LAG                                                           
          NMK = N - K                                                       
!C                                                                       
!C          +-----------------------+                                    
!C          ! HOUSEHOLDER REDUCTION !                                    
!C          +-----------------------+                                    
!C                                                                       
                    
          CALL  REDUCT( SETX1,Z,NMK,0,K,MJ1,LAG,X )                       
!C                                                                       
!C          +------------------+                                         
!C          ! AR MODEL FITTING !                                         
!C          +------------------+                                         
!C                                                                       

          CALL  ARMFIT( X,K,LAG,NMK,ISW,MJ1,A1,M1,SD,AIC,DIC,SDM1,AMIN )
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 5  I = 1,K

                A2(I) = A1(I)
        5 CONTINUE
!C                                                                       
!C          +-------------------------------------------+                
!C          ! MAXIMIZATION OF EXACT LIKELIHOOD FUNCTION !                
!C          +-------------------------------------------+                
!C                                                                       
          JER = 0
          IF( ISW .EQ. 2 )  GO TO 10                                        
                                                                       
          IPR = 7                                                           

          CALL  ARMLE( Z,N,M1,K,A2,SDM2,ISW,JER )

          RETURN
                                                                       
       10 DO 20  M=1,K                                                      
                                    
                CALL  RECOEF( X,M,K,MJ1,A2 )
                IPR = 5                                                           

                CALL  ARMLE( Z,N,M,K,A2,SDM2,ISW,JER )
                IF( JER .NE. 0 ) RETURN
                DO 15  I = 1,M

                      A22(I,M) = A2(I)
             15 CONTINUE
                SDM22(M) = SDM2
       20 CONTINUE
    END SUBROUTINE
    
                                                            

    SUBROUTINE  ARMLE( Z,N,K,L,A,SDM,ISW,JER )
          implicit none
!C.....DATE OF THE LATEST REVISION:  JUN. 29, 1979.......................
!C                                                                       
!C     THIS SUBROUTINE PRODUCES EXACT MAXIMUM LIKELIHOOD ESTIMATES OF THE
!C     PARAMETERS OF AN AUTOREGRESSIVE MODEL                             
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             DAVIDN                                                    
!C             PRINTA                                                    
!C       ----------------------------------------------------------------
!C          INPUTS:                                                      
!C             Z:       ORIGINAL DATA                                    
!C             N:       DATA LENGTH                                      
!C             K:       ORDER OF THE AR-MODEL                            
!C             L:       HIGHEST POSSIBLE ORDER OF THE MODEL              
!C             TITLE:   TITLE OF DATA                                    
!C                                                                       
!C          OUTPUTS:                                                     
!C             A:       MAXIMUM LIKELIHOOD ESTIMATES OF AR-COEFFICIENTS  
!C                                                                       
!C                                                                       

                                  
          INTEGER(4) :: N, K, L, ISW, JER 
          REAL(8), dimension(N) :: Z 
          REAL(8), dimension(K) :: A  
          REAL(8) ::  SDM
          ! Locals
          INTEGER(4) :: IHES,NMLP1,K1,L1,NML,II,J,IMJ,KMI,NMI, &
                           KI,KK,I
          REAL(8)    :: SUM, F0, AIC, SD
          REAL(8), dimension(K+1,K+1) :: R 
          REAL(8), dimension(L+1)     ::  C
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: R,C
#endif
         ! EXTERNAL  FUNCT                                                   
          !EXTERNAL  HESIAN                                                  
                                                                       
          IHES = 1                                                          

          NMLP1 = N - L + 1                                                 
          K1 = K + 1                                                        
          L1 = L + 1                                                        
          N1 = N + 1                                                        
          NML = N - L                                                       
          DO  20  II=1,L1                                                   
                  J = II - 1                                                        
                  SUM = 0._8
#if defined __ICC
                  !DIR$ VECTOR ALIGNED
                  !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                  !$OMP SIMD REDUCTION(+:SUM)
#endif
                  DO 10  I=L1,NML                                                   
                         IMJ = I - J                                                       
                                       
                         SUM = SUM + Z(I)*Z(IMJ)  
               10 CONTINUE
                                                     
                  C(II) = SUM
       20 CONTINUE
!C                                                                       
!C       COVARIANCE MATRIX R COMPUTATION                                 
!C                                                                       
                                               
          DO 71  II=1,K1 
                 KMI = K1 - II + 1                                                 
                 NMI = N1 - II                                                     
                 DO 70  JJ=II,K1                                                   
                        JMI = JJ - II                                                     
                        SUM = C(JMI+1)                                                    
                        IF( KMI .GT. L )  GO TO 40
#if defined __ICC
                  !DIR$ VECTOR ALIGNED
                  !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                  !$OMP SIMD REDUCTION(+:SUM)
#endif                        
                        DO 30  KK=KMI,L                                                   
                               KI = KK - JMI                                                     
                                        
                               SUM = SUM + Z(KK)*Z(KI) 
                     30 CONTINUE
                     40 CONTINUE                                                          
                               IF( NMLP1 .GT. NMI )  GO TO 60
#if defined __ICC
                  !DIR$ VECTOR ALIGNED
                  !DIR$ SIMD REDUCTION(+:SUM)
#elif defined __GFORTRAN__
                  !$OMP SIMD REDUCTION(+:SUM)
#endif                              
                        DO 50  KK=NMLP1,NMI                                               
                               KI = KK - JMI                                                     
                                       
                               SUM = SUM + Z(KK)*Z(KI)
                     50 CONTINUE
                     60 R(II,JJ) = SUM                                                    
                        R(JJ,II) = SUM                                                    
              70 CONTINUE
       71 CONTINUE                                                          
!C                                                                       
!C       DAVIDON'S MINIMIZATION PROCEDURE                                
!C                                                                       
          F0 = 1.0E+60_8                                                      
          DO  80   I=1,5                                                    

                   CALL  DAVIDN( FUNCT,HESIAN,Z,N,A,K,R,IHES,ISW,AIC,SD,JER )
                   IF( JER .NE. 0 ) RETURN
                                                                       
                   IF( F0-AIC .LT. 0.001_8 )     GO TO 90                              

                   F0 = AIC
       80 CONTINUE                                                          
       90 CONTINUE                                                          
                          
          SDM = SD
    END SUBROUTINE
    
                                                
                                                                   

    SUBROUTINE  DAVIDN( FUNCT,HESIAN,Z,NZ,X,N,R,IHES,ISW,AIC,SD,JER )
          implicit none
!C.....DATE OF THE LATEST REVISION:  JUN. 29, 1979.......................
!C                                                                       
!C          MINIMIZATION BY DAVIDON-FLETCHER-POWELL PROCEDURE            
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             FUNCT                                                     
!C             HESIAN                                                    
!C             LINEAR                                                    
!C       ----------------------------------------------------------------
!C          INPUTS:                                                      
!C             FUNCT:   EXTERNAL FUNCTION SPECIFICATION                  
!C             HESIAN:  EXTERNAL FUNCTION SPECIFICATION                  
!C             X:       VECTOR OF INITIAL VALUES                         
!C             N:       DIMENSION OF THE VECTOR X                        
!C             IHES:    =0   INVERSE OF HESSIAN MATRIX IS NOT AVAILABLE  
!C                      =1   INVERSE OF HESSIAN MATRIX IS AVAILABLE      
!C                                                                       
!C          OUTPUT:                                                      
!C             X:       VECTOR OF MINIMIZING SOLUTION                    
!C                                                                       

          INTEGER(4) :: NZ, N, IHES, ISW, JER
          REAL(8), dimension(NZ) :: Z 
          REAL(8), dimension(N) ::  X 
          REAL(8), dimension(N+1,N+1) ::  R 
          REAL(8) :: AIC, SD
          ! Locals
          INTEGER(4) :: I,ICC,IC,J
          REAL(8) :: TAU1, TAU2, EPS1, EPS2, RAMDA, CONST1, SUM,  &
                        S1, S2, STEM, SS, DS2, GTEM, ED, F, XM, XMB 
          REAL(8), dimension(N)   :: DX, G, G0, Y, WRK, S
          REAL(8), dimension(N,N) :: H
                                                                          
                          
          DATA  TAU1 , TAU2  /  0.00001_8 , 0.00001_8  /                          
          DATA  EPS1 , EPS2  / 0.00001_8 ,  0.00001_8  /                           
          !EXTERNAL  FUNCT

          RAMDA = 0.5_8                                                     
          CONST1 = 1.0E-70_8                                                  
!C                                                                       
!C          INITIAL ESTIMATE OF INVERSE OF HESSIAN                       
!C
          H(1:N,1:N) = 0.0_8
          S(1:N) = 0.0_8                                                    
          DX(1:N) = 0.0_8  
          
          DO  20   I=1,N                                                    
                                               
                 H(I,I) = 1.0_8
                 
       20 CONTINUE
          ISW = 0                                                           

          CALL  FUNCT( Z,NZ,N,X,R,ISW,XM,G,AIC,SD,F,IG,JER )
          IF( JER .NE. 0 ) RETURN
                    
          IF( IHES .EQ. 1 )   CALL  HESIAN( X,N,NZ,R,SD,H )
                                                                       
          ICC = 0                                                           
                                                    
    11110 CONTINUE                                                          
          ICC = ICC + 1                                                     
          DO  11111   IC=1,N                                                
                      IF( IC .EQ. 1 .AND. ICC .EQ. 1 )     GO TO 120                    
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                      
                      DO  40   I=1,N                                                    
                                            
                         Y(I) = G(I) - G0(I)
                  40 CONTINUE
                     DO  60   I=1,N                                                    
                              SUM = 0.0_8
!DIR$ SIMD REDUCTION(+:SUM)
                              DO  50   J=1,N                                                    
                                         
                                 SUM = SUM + Y(J) * H(I,J)
                          50 CONTINUE
                                                  
                             WRK(I) = SUM
                 60 CONTINUE
                    S1 = 0.0_8                                                      
                    S2 = 0.0_8
!DIR$ SIMD REDUCTION(+:S1)
!DIR$ SIMD REDUCTION(+:S2)                    
                    DO  70   I=1,N                                                    
                          S1 = S1 + WRK(I) * Y(I)                                           
                                           
                          S2 = S2 + DX(I) * Y(I)
                70 CONTINUE
                   IF( S1.LE.CONST1 .OR. S2.LE.CONST1 )  GO TO 900                   
                   IF( S1 .LE. S2 )     GO TO 100                                    
!C                                                                       
!C          UPDATE THE INVERSE OF HESSIAN MATRIX                         
!C                                                                       
!C               ---  DAVIDON-FLETCHER-POWELL TYPE CORRECTION  ---       
!C                                                                       
                                               
                   DO  91   I=1,N 
                         DO  90   J=I,N                                                    
                               H(I,J) = H(I,J) + DX(I)*DX(J)/S2 - WRK(I)*WRK(J)/S1               
                                                   
                               H(J,I) = H(I,J)
                      90 CONTINUE
               91 CONTINUE
                  GO TO  120                                                        
!C                                                                       
!C               ---  FLETCHER TYPE CORRECTION  ---                      
!C                                                                       
              100 CONTINUE                                                          
                 STEM = S1 / S2 + 1.0_8                                          
                                             
                 DO  111   I=1,N
                        DO  110   J=I,N                                                   
                             H(I,J) = H(I,J)- (DX(I)*WRK(J)+WRK(I)*DX(J)-DX(I)*DX(J)*STEM)/S2  
                                                
                             H(J,I) = H(I,J)
                    110 CONTINUE
             111 CONTINUE
                                                                       
             120 CONTINUE                                                          
                 SS = 0.0_8                                                      
                 DO  150   I=1,N                                                   
                           SUM = 0.0_8
!DIR$ SIMD REDUCTION(+:SUM)
                           DO  140   J=1,N                                                   
                                       
                               SUM = SUM + H(I,J)*G(J) 
                       140 CONTINUE
                          SS = SS + SUM * SUM                                               
                                                    
                          S(I) = -SUM
             150 CONTINUE
                                                                       
                 S1 = 0.0_8                                                      
                 S2 = 0.0_8  
!DIR$ SIMD REDUCTION(+:S1)
!DIR$ SIMD REDUCTION(+:S2)                   
                 DO  170   I=1,N                                                   
                      S1 = S1 + S(I)*G(I)                                               

                      S2 = S2 + G(I)*G(I)
             170 CONTINUE                                               
                 DS2 = DSQRT(S2)                                                   
                 GTEM = DABS(S1) / DS2                                             
                 IF( GTEM .LE. TAU1  .AND.  DS2 .LE. TAU2 )     GO TO  900         
                 IF( S1 .LT. 0.0_8 )     GO TO  200                               
                 H(1:N,1:N) = 0.0_8
                 DO  190   I=1,N                                                   
                                                
                        H(I,I) = 1.0_8                                                  
                                                    
                        S(I) = -S(I)
             190 CONTINUE
             200 CONTINUE                                                          
                                                                       
                 ED = XM                                                           
!C                                                                       
!C          LINEAR  SEARCH                                               
!C                                                                       

                 CALL  LINEAR( FUNCT,Z,NZ,X,S,RAMDA,ED,N,R,AIC,SD,F,ISW,IG,JER )
                 IF( JER .NE. 0 ) RETURN
                                                                      
                 S1 = 0.0_8  
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                 DO  210   I=1,N                                                   
                          DX(I) = S(I) * RAMDA                                              
                          S1 = S1 + DX(I) * DX(I)                                           
                          G0(I) = G(I)                                                      
                                            
                          X(I) = X(I) + DX(I)
             210 CONTINUE
                 XMB = XM                                                          
                 ISW = 0                                                           

                 CALL  FUNCT( Z,NZ,N,X,R,ISW,XM,G,AIC,SD,F,IG,JER )
                 IF( JER .NE. 0 ) RETURN
                                                                       
                 S2 = 0._8                                                        
                 DO  220     I=1,N                                                 

                      S2 = S2 + G(I)*G(I)
             220 CONTINUE                                               
                 IF( DSQRT(S2) .GT. TAU2 )   GO TO  11111                          
                 IF( XMB/XM-1.0_8 .LT. EPS1  .AND.  DSQRT(S1) .LT. EPS2 )  GO TO 900
     11111 CONTINUE                                                          
           IF( ICC .GE. 5 )     GO TO 900                                    
            GO TO 11110                                                       
       900 CONTINUE                                                          
    END SUBROUTINE
    
     

    SUBROUTINE  FUNCT( Z,N,M,A,R,ISW,F,G,AIC,SD,FF,IFG,JER )
          implicit none
!C                                                                       
!C     THIS SUBROUTINE COMPUTES THE EXACT LIKELIHOOD AND ITS GRADIENT OF 
!C     THE M-TH ORDER AR-MODEL.                                          
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             ARCOEF                                                    
!C             PARCOR                                                    
!C             SUBDET                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C          INPUTS:                                                      
!C             M:    ORDER OF THE AR MODEL                               
!C             A:    VECTOR OF AR-COEFFICIENTS                           
!C                                                                       
!C          OUTPUTS:                                                     
!C             F:    LIKELIHOOD OF THE AR-MODEL                          
!C             G:    GRADIENT OF THE LIKELIHOOD FUNCTION                 
!C             IFG:  =0    ;IF MODEL IS STATIONALY                       
!C                   =1    ;IF MODEL IS NON-STATIONALY                   
!C                                                                       
!C                                                                       
                                 
          INTEGER(4) :: N, M, ISW, IFG, JER
          REAL(8), dimension(N) :: Z 
          REAL(8), dimension(M) ::  A,G 
          REAL(8), dimension(M+1,M+1) :: R
          REAL(8) :: F,AIC,SD,FF
      ! lOCALS
          INTEGER(4) :: MJ,M1,MP1,I,IM1,II,J,JJ,JM1,JE,JE1,J1, &
                       IM1,K,JC,KM1,KK
          REAL(8) ::   DN, DN1, SUM, DSD, USUM, DETT, UDET
          REAL(8), dimension(M+1,M+1) :: T, U, S 
          REAL(8), dimension(M) :: B
!DIR$ ATTRIBUTES ALIGN : 64 :: T,U,S,B               
                                                       
          MJ = M+1                                                           
                                                                       
      280 IFG = 0                                                           
                                                                       
          DN = N                                                            
          DN1 = 1.0_8 / DN                                                 
          MP1 = M + 1                                                       
          M1 = MP1 / 2                                                      
!C                                                                       
!C   **  COMPUTATION OF F  **                                            
!C                                                                       
!C                                                                       
!C          INVERSE OF COVARIANCE MATRIX COMPUTATION                     
!C                                                                       
!C                                                                       
          T(1,1) = 1.0_8 - A(M) * A(M)                                     
          IF( M .EQ. 1 )     GO TO 45                                       
          DO  10     I=2,M                                                  
                     IM1 = I - 1                                                       
                     II = M - IM1                                                      
                               
                     T(I,1) = - ( A(IM1)+A(M)*A(II) ) 
       10 CONTINUE
          IF( M .EQ. 2 )     GO TO 25                                       
                                               
          DO  21 J=2,M1
                 JM1 = J - 1                                                       
                 JJ = M - JM1                                                      
                 DO  20 I=J,JJ                                                 
                        IM1 = I - 1                                                       
                        II = M - IM1                                                      
                
                        T(I,J) = T(IM1,JM1) + A(IM1)*A(JM1) - A(II)*A(JJ)
             20 CONTINUE
       21 CONTINUE
                                             
       25 DO  31 J=1,M1 
                 JE = MP1 - J                                                      
                 JE1 = JE - 1                                                      
                 DO  30  I=J,JE1                                                
                         II = MP1 - I                                                      
                                                
                         T(JE,II) = T(I,J)
             30 CONTINUE
       31 CONTINUE
                                              
          DO  41 I=2,M
                 IM1 = I - 1                                                       
                 DO  40     J=1,IM1                                                
                                                
                        T(J,I) = T(I,J)
              40 CONTINUE
       41 CONTINUE
                                                                       
       45 CONTINUE                                                          
!C                                                                       
!C         INNOVATION VARIANCE COMPUTATION                               
!C                                                                       
          SD = R(1,1)                                                       
          DO  60 J=1,M                                                  
                 J1 = J + 1                                                        
                 SUM = 0.0_8                                                   
                 DO  50     K=1,M                                                  
                                       
                       SUM = SUM + A(K)*R(J1,K+1)
              50 CONTINUE
                                             
                 SD = SD + SUM*A(J)
       60 CONTINUE
          SUM = 0.0_8                                                      
          DO  70 K=1,M                                                  
                                      
                 SUM = SUM + A(K)*R(1,K+1)
       70 CONTINUE
          SD = SD - 2.0_8*SUM                                              
                                                                       
          DO  80 J=1,M                                                  
                 SUM = 0.0_8
!DIR$ SIMD REDUCTION(+:SUM)
                DO  85  K=1,M                                                  
                                         
                  SUM = SUM + T(J,K)*Z(K)
              85 CONTINUE
                                             
                 SD = SD + SUM*Z(J)
       80 CONTINUE
          SD = SD * DN1                                                     
                                              
         DO  91     I=1,M
              DO  90     J=1,M                                                  
                                                 
                   U(I,J) = T(I,J)
           90 CONTINUE
       91 CONTINUE
          CALL  SUBDET( U,DETT,M,MJ )                                       
!C                                                                       
!C         CHECK THE STATIONARITY                                        
!C                                                                       
!C                                                                       
          CALL  PARCOR( A,M,B )                                             
                                                                       
          DO  210     I=1,M                                                 
                 IF( DABS(B(I)) .LT. 1.D0 )     GO TO  210                         
                 IF( ISW .EQ. 0 )   B(I) = 0.999_8*DABS(B(I))/B(I)                 
                 IFG = 1                                                           
      210 CONTINUE                                                          
          IF( IFG .EQ. 0 )     GO TO  220                                   
          IF( ISW .EQ. 1 )     RETURN                                       
                                                                       
          CALL  ARCOEF( B,M,A )                                             
          GO TO  280                                                        
      220 CONTINUE                                                          
          IF( SD .GT. 0.0_R64P ) GO TO 221
          JER = 11111
          RETURN
      221 CONTINUE
!C                                                                       
!C         LIKELIHOOD                                                    
!C                                                                       
          F = 0.5_8 * ( DN*DLOG(SD) - DLOG(DETT) )                         
          FF = F                                                            
          AIC = 2._8*F + 2*(M+1)                                            
                                                                       
          IF( ISW .EQ. 1 )     RETURN                                       
!C                                                                       
!C       COMPUTATION OF GRADIENT OF F                                    
!C                                                                       
          DO  1000  JC=1,M                                               
!C                                                                       
                 S(1,1) = 0.0_8                                                  
                 IF( JC .EQ. M )     S(1,1) = -2.0_8*A(M)                         
                 IF( M .EQ. 1 )     GO TO 145                                      
!C                                                                       
                 DO  100 I=2,M                                                 
                         II = MP1 - I                                                      
                         IM1 = I - 1                                                       
                         S(I,1) = 0.0_8                                                  
                         IF( II .EQ. JC )      S(I,1) = -A(M)                               
                         IF( M .EQ. JC )       S(I,1) = -A(II)                               
                         IF( IM1 .EQ. JC )     S(I,1) = S(I,1) - 1.0_R64P                    
      100 CONTINUE                                                          
          IF( M .EQ. 2 )     GO TO 120                                      
                                              
          DO  111  K=2,M1
                   KM1 = K - 1                                                       
                   KK = MP1 - K                                                      
                   DO  110  I=K,KK                                                
                            IM1 = I - 1                                                       
                            II = MP1 - I                                                      
                            S(I,K) = S(IM1,KM1)                                               
                            IF( KM1 .EQ. JC )     S(I,K) = S(I,K) + A(IM1)                    
                            IF( IM1 .EQ. JC )     S(I,K) = S(I,K) + A(KM1)                    
                            IF( II .EQ. JC )     S(I,K) = S(I,K) - A(KK)                      
                            IF( KK .EQ. JC )     S(I,K) = S(I,K) - A(II)                      
              110 CONTINUE
      111 CONTINUE                                                          
                                              
      120 DO  131   J=1,M1
                    JE=  MP1 - J                                                      
                    JE1 = JE - 1                                                      
                    DO  130 I=J,JE1                                               
                           II = MP1 - I                                                      
                                               
                           S(JE,II) = S(I,J)
                130 CONTINUE
      131 CONTINUE
                                           
          DO  141   I=2,M
                    IM1 = I - 1                                                       
                    DO  140 J=1,IM1                                               
                                               
                           S(J,I) = S(I,J)
                140 CONTINUE
      141 CONTINUE
      145 CONTINUE                                                          
                                                                       
          J1 = JC + 1                                                       
          DSD = R(1,J1)                                                     
          DO  150   K=1,M                                                 
                                   
                   DSD = DSD - A(K) * R(J1,K+1)
      150 CONTINUE
                                                                       
          DSD = -2.0_8*DSD                                                 
          DO  170 I=1,M                                                 
                  SUM = 0.0_8  
!DIR$ SIMD REDUCTION(+:SUM)
                  DO  160   J=1,M                                                 

                         SUM = SUM + S(I,J)*Z(J)
             160 CONTINUE                                           

                 DSD = DSD + SUM*Z(I)
      170 CONTINUE                                              
          DSD = DSD * DN1                                                   
          USUM = 0.0_8                                                     
          DO  200   K=1,M                                                 

                  DO  181  I=1,M                                                 
                       DO  180  J=1,M                                                 

                             U(I,J) = T(I,J)
                   180 CONTINUE
             181 CONTINUE                                                   
                 DO  190 J=1,M                                                 
                                                
                        U(K,J) = S(K,J)
             190 CONTINUE
!C                                                                       
                 CALL  SUBDET( U,UDET,M,MJ )                                       

                 USUM = USUM + UDET
      200 CONTINUE                                                
!C                                                                       
!C         GRADIENT OF LIKELIHOOD FUNCTION                               
!C                                                                       
          G(JC) = 0.5_8*( -DN*DSD/SD + USUM/DETT )                         
     1000 CONTINUE                                                          
          DO  300  I=1,M                                                 

                 G(I) = -G(I)
      300 CONTINUE                                                      
    END SUBROUTINE
    
                                   
    SUBROUTINE  HESIAN( X,K,N,R,SD,H )
          implicit none
!C                                                                       
!C     THIS SUBROUTINE RETURNS THE INVERSE OF AN APPROXIMATION TO THE HES
!C     OF LOG-LIKELIHOOD FUNCTION OF THE AUTOREGRESSIVE MODEL OF ORDER K.
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             INVDET                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          X:     VECTOR OF AR-COEFFICIENTS                             
!C          K:     ORDER OF THE AR-MODEL                                 
!C          N:     DATA LENGTH                                           
!C          Z:     VECTOR OF ORIGINAL DATA                               
!C          R:     SQUARE ROOT OF THE COVARIANCE MATRIX, OUTPUT OF SUBROU
!C                 ARMLE                                                 
!C          SD:    ESTIMATE OF INNOVATION VARIANCE                       
!C                                                                       
!C       OUTPUT:                                                         
!C          H:     INVERSE OF THE HESSIAN                                

          INTEGER(4) :: K, N
          REAL(8), dimension(K)       :: X 
          REAL(8), dimension(K+1,K+1) ::  R 
          REAL(8) ::  SD 
          REAL(8), dimension(K,K) ::  H
          ! Locals
          INTEGER(4) :: I,II,J
          REAL(8)    :: SUM, HDET
          REAL(8), dimension(K) :: S 
!DIR$ ATTRIBUTES ALIGN : 64 :: S
          DO 10  I=1,K                                                      
                 SUM = R(1,I+1)                                                    
                 DO 20  II=1,K                                                     
                                  
                      SUM = SUM - X(II)*R(II+1,I+1)
              20 CONTINUE                                     

                 S(I) = SUM / SD                                                   
       10 CONTINUE
                                                  
          DO 31  I=1,K 
                 DO 30  J=1,K                                                      
                
                       H(I,J) = 0.5_R64P * (R(I+1,J+1)/SD - S(I)*S(J)/N)
              30 CONTINUE
       31 CONTINUE
                                   
          CALL  INVDET( H,HDET,K,K )                                       
    END SUBROUTINE
    
                 
    SUBROUTINE  LINEAR( FUNCT,Z,N,X,H,RAM,EE,K,R,AIC,SD,F,ISW,IG,JER )
          implicit none
!C                                                                       
!C     THIS SUBROUTINE PERFORMS THE LINEAR SEARCH ALONG THE DIRECTION SPE
!C     BY THE VECTOR H                                                   
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             FUNCT                                                     
!C       ----------------------------------------------------------------
!C                                                                       
!C     INPUTS:                                                           
!C        FUNCT:   EXTERNAL FUNCTION SPECIFICATION                       
!C        X:       VECTOR OF POSITION                                    
!C        H:       SEARCH DIRECTION                                      
!C        K:       DIMENSION OF VECTOR X                                 
!C                                                                       
!C     OUTPUTS:                                                          
!C        RAM:     OPTIMAL STEP WIDTH                                    
!C        E2:      MINIMUM FUNCTION VALUE                                
!C        IG:      ERROR CODE                                            
!C                                                                       


          INTEGER(4) :: N, K, ISW, IG, JER
          REAL(8), dimension(N) :: Z 
          REAL(8), dimension(K) ::  X, H 
          REAL(8) ::  RAM, EE 
          REAL(8), dimension(K+1,K+1) :: R 
          REAL(8) :: AIC, SD, F
         ! Locals
         
          INTEGER(4) :: RET, SUB,I
          REAL(8)    :: CONST2, HNORM, E1, E2, E3, &
                       RAM1, RAM2, RAM3, A1, A2, A3, B1, B2
          REAL(8), dimension(K) :: X1, G 
                                                                       
          ISW = 1                                                           
          IF( RAM .LE. 1.0E-30_8 )  RAM = 0.01_8                           
          CONST2 = 1.0E-60_8                                                
          HNORM = 0._R64P                                                     
          DO 10  I=1,K                                                      
                                       
               HNORM = HNORM + H(I)**2
       10 CONTINUE
          HNORM = DSQRT( HNORM )                                            
                                                                       
          RAM2 = RAM                                                        
          E1 =EE                                                            
          RAM1 = 0._8                                                     
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                       
          DO 20  I=1,K                                                      
                                        
                 X1(I) = X(I) + RAM2*H(I)
       20 CONTINUE

          CALL  FUNCT( Z,N,K,X1,R,ISW,E2,G,AIC,SD,F,IG,JER )
          IF( JER .NE. 0 ) RETURN
                                                                       
          IF( IG .EQ. 1 )  GO TO  50                                        
          IF( E2 .GT. E1 )  GO TO 50                                        
30        RAM3 = RAM2*2._R64P 
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))            
          DO 40  I=1,K                                                      
                                     
             X1(I) = X(I) + RAM3*H(I)
       40 CONTINUE

          CALL  FUNCT( Z,N,K,X1,R,ISW,E3,G,AIC,SD,F,IG,JER )
          IF( JER .NE. 0 ) RETURN
          IF( IG.EQ.1 )  GO TO  500                                         

          IF( E3 .GT. E2 )  GO TO 70                                        
          RAM1 = RAM2                                                       
          RAM2 = RAM3                                                       
          E1 = E2                                                           
          E2 = E3                                                           
          GO TO 30                                                          
                                                                       
       50 RAM3 = RAM2                                                       
          E3 = E2                                                           
          RAM2 = RAM3*0.1_R64P                                                 
          IF( RAM2*HNORM .LT. CONST2 )  GO TO  400
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))            
          DO 60  I=1,K                                                      

               X1(I) = X(I) + RAM2*H(I)
       60 CONTINUE                                          

          CALL  FUNCT( Z,N,K,X1,R,ISW,E2,G,AIC,SD,F,IG,JER )
          IF( JER .NE. 0 ) RETURN

          IF( E2.GT.E1 )  GO TO 50                                          
                                            
       70 RET = 80
          GO TO 200                                                         
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                         
       80 DO 90  I=1,K                                                      
                                      
                X1(I) = X(I) + RAM*H(I) 
       90 CONTINUE

          CALL  FUNCT( Z,N,K,X1,R,ISW,EE,G,AIC,SD,F,IG,JER )
          IF( JER .NE. 0 ) RETURN
                                                                      
          IFG = 0                                                           
                                          
          SUB = 300
          SUB = 200
       95 RET = 130
          IF( RAM .GT. RAM2 )  GO TO 110                                    
          IF( EE .GE. E2 )  GO TO 100                                       
          RAM3 = RAM2                                                       
          RAM2 = RAM                                                        
          E3 =E2                                                            
          E2 =EE                                                            
                                         
          IF( SUB .EQ. 200 ) GO TO  200
          IF( SUB .EQ. 300 ) GO TO  300
                                                                       
      100 RAM1 = RAM                                                        
          E1 = EE                                                           
                                      
          IF( SUB .EQ. 200 ) GO TO  200
          IF( SUB .EQ. 300 ) GO TO  300
                                                                      
      110 IF( EE .LE. E2 )  GO TO 120                                       
          RAM3 = RAM                                                        
          E3 = EE                                                           
                                       
          IF( SUB .EQ. 200 ) GO TO  200
          IF( SUB .EQ. 300 ) GO TO  300
                                                                       
      120 RAM1 = RAM2                                                       
          RAM2 = RAM                                                        
          E1 = E2                                                           
          E2 = EE                                                           
                                      
          IF( SUB .EQ. 200 ) GO TO  200
          IF( SUB .EQ. 300 ) GO TO  300
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                                                                         
      130 DO 140  I=1,K                                                     
                                         
                X1(I) = X(I) + RAM*H(I)
      140 CONTINUE

          CALL  FUNCT( Z,N,K,X1,R,ISW,EE,G,AIC,SD,F,IG,JER )
          IF ( JER .NE. 0 ) RETURN
                                             
          SUB = 200
          IFG = IFG+1                                                       
          IFG = 0                                                           
          IF( IFG .EQ. 1 )  GO TO 95                                        
                                                                       
          IF( E2 .LT. EE )  RAM = RAM2                                      
          RETURN                                                            
                      
      200 A1 = (RAM3-RAM2)*E1                                               
          A2 = (RAM1-RAM3)*E2                                               
          A3 = (RAM2-RAM1)*E3                                               
          B2 = (A1+A2+A3)*2.D0                                              
          B1 = A1*(RAM3+RAM2) + A2*(RAM1+RAM3) + A3*(RAM2+RAM1)             
          IF( B2 .EQ. 0._R64P )  GO TO 210                                     
          RAM = B1 /B2                                                      
                                     
          IF( RET .EQ. 80 ) GO TO 80
          IF( RET .EQ. 130 ) GO TO 130
                                                                       
      210 IG = 1                                                            
          RAM = RAM2                                                        
          RETURN                                                            
                                                                       
      300 IF( RAM3-RAM2 .GT. RAM2-RAM1 )  GO TO 310                         
          RAM = (RAM1+RAM2)*0.5_R64P                                           
                                        
          IF( RET .EQ. 80 ) GO TO 80
          IF( RET .EQ. 130 ) GO TO 130
                                                                       
      310 RAM = (RAM2+RAM3)*0.5_R64P                                           
                                      
          IF( RET .EQ. 80 ) GO TO 80
          IF( RET .EQ. 130 ) GO TO 130
                                                                       
      400 RAM = 0._R64P                                                       
          RETURN                                                            
                                                                       
500       RAM = (RAM2+RAM3)*0.5_R64P 
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))            
      510 DO 520  I=1,K                                                     

                X1(I) = X(I) + RAM*H(I)
      520 CONTINUE                                           

          CALL  FUNCT( Z,N,K,X1,R,ISW,E3,G,AIC,SD,F,IG,JER )
          IF( JER .NE. 0 ) RETURN

          IF( IG.EQ.1 )  GO TO 540                                          
          IF( E3.GT.E2 )  GO TO 530                                         
          RAM1 = RAM2                                                       
          RAM2 = RAM                                                        
          E1 = E2                                                           
          E2 = E3                                                           
          GO TO 500                                                         
                                                                       
      530 RAM3 = RAM                                                        
          GO TO 70                                                          
                                                                       
      540 RAM = (RAM2+RAM)*0.5_R64P                                          
          GO TO 510                                                         
    END SUBROUTINE
    
    SUBROUTINE FFTCORF(LD,LAGH1,N,N2P,ISW,X1,Y1,XA,X,Y,    &
                       CNA1,CN1,CN2,AMEAN)
          implicit none
!C
!C     PROGRAM 5.1.3   AUTO AND/OR CROSS CORRELATIONS VIA FFT.
!C-----------------------------------------------------------------------
!C     ** THIS PROGRAM IS AN ADAPTED VERSION OF THE ALGOL PROCEDURE
!C         //CROSS CORRELATE// PREPARED BY DR GORDON SANDE AT PRINCETON
!C         UNIVERSITY IN 1966-7.
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: FEB. 16, 1978
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES AUTO AND/OR CROSS
!C     COVARIANCES AND CORRELATIONS VIA FFT.
!C     IT REQUIRES FOLLOWING INPUTS:
!C     ISW: ISW=1...AUTO CORRELATION OF X (ONE-CHANNEL)
!C           ISW=2...AUTO CORRELATIONS OF X AND Y (TWO-CHANNEL)
!C           ISW=4...AUTO,CROSS CORRELATIONS OF X AND Y (TWO-CHANNEL)
!C     LD: LENGTH OF DATA
!C     LAGH: MAXIMUM LAG
!C     DFORM: INPUT FORMAT SPECIFICATION STATEMENT IN ONE CARD,
!C     FOR EXAMPLE
!C     (8F10.4)
!C     (X(I); I=1,LD): DATA OF CHANNEL X
!C     (Y(I); I=1,LD): DATA OF CHANNEL Y (FOR ISW=2 OR 4 ONLY)
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: FFTCORF

          INTEGER(4) :: LD, LAGH1, N, N2P, ISW
          REAL(8), dimension(LD)      ::   X1, Y1 
          REAL(8), dimension(N,2)     ::   XA 
          REAL(8), dimension(N)       ::   X, Y 
          REAL(8), dimension(LAGH1,2) ::   CNA1
          REAL(8), dimension(LAGH1)   ::   CN1, CN2 
          REAL(8), dimension(2)       ::   AMEAN
          ! Locals
          INTEGER(4) ::  LAGH,ND,NP1,NP2,M,M1,I,ISG,NI,II,I1,J1
          REAL(8)    ::  CST0, CST1, CST2, AN, ALD, ALD1, RF, SF,  &
                            RG, SG, XI, XNI, YI, YNI, X0, XMEAN, YMEAN,      &
                            CX0, Y0                   
          COMPLEX(8) ::  ZI, ZNI
          COMPLEX(8), dimension(N)     :: Z 
          COMPLEX(8), dimension(N/2+1) :: ZS
!DIR$ ATTRIBUTES ALIGN : 64 :: Z,ZS
          LAGH=LAGH1-1
          ND=LD+LAGH1

          NP1=N+1
          NP2=N+2
          M=N/2
          M1=M+1
          CST0=0.0_8
          CST1=1.0_8
          CST2=0.25_8
          AN=N
          ALD=LD
          ALD1=CST1/(AN*ALD)
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 20 I=1,N
                X(I)=CST0
                Y(I)=CST0
       20 CONTINUE
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 1200 I=1,LD

               X(I)=X1(I)
     1200 CONTINUE
          IF(ISW.EQ.1) GO TO 200
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 1201 I=1,LD

              Y(I)=Y1(I)
     1201 CONTINUE

      200 CONTINUE

          CALL DMEADL(X,LD,XMEAN)
          IF(ISW.EQ.1) GO TO 203
          CALL DMEADL(Y,LD,YMEAN)
!C     DOUBLE PRECISION COMPLEX REPRESENTATION
      203 DO 31 I=1,N

             Z(I)=DCMPLX(X(I),Y(I))
       31 CONTINUE
!C     FOURIER TRANSFORM OF Z
          ISG=-1
          CALL MIXRAD(Z,N,N2P,ISG)
          IF(ISW.NE.1) GO TO 204
!C     RAW SPECTRUM COMPUTATION
          DO 32 I=2,M
               X(I)=DREAL(Z(I))**2+DIMAG(Z(I))**2
               NI=NP2-I

               X(NI)=X(I)
       32 CONTINUE
          X(1)=DREAL(Z(1))**2
          X(M1)=DREAL(Z(M1))**2
          GO TO 205
!C     DECOMPOSITION AND RAW SPECTRUM COMPUTATION
      204 DO 125 I=2,M
            NI=NP2-I
            ZI=Z(I)
            ZNI=Z(NI)
            RF=DREAL(ZI)
            SF=DIMAG(ZI)
            RG=DREAL(ZNI)
            SG=DIMAG(ZNI)
            XI=RF+RG
            XNI=SF-SG
            Z(I)=DCMPLX(XI,XNI)
            X(I)=CST2*(XI**2+XNI**2)
            X(NI)=X(I)
            YI=SF+SG
            YNI=RF-RG
            Z(NI)=DCMPLX(YI,YNI)
            Y(I)=CST2*(YI**2+YNI**2)
            Y(NI)=Y(I)
      125 CONTINUE
            X(1)=DREAL(Z(1))**2
            Y(1)=DIMAG(Z(1))**2
            X(M1)=DREAL(Z(M1))**2
            Y(M1)=DIMAG(Z(M1))**2
            IF(ISW.NE.4) GO TO 205
!C     RAW CROSS SPECTRUM COMPUTATION
            DO 126 I=2,M
                 NI=NP2-I

                ZS(I)=CST2*Z(I)*Z(NI)
       126 CONTINUE
           ZS(1)=DREAL(Z(1))*DIMAG(Z(1))
           ZS(M1)=DREAL(Z(M1))*DIMAG(Z(M1))
!C     AUTO COVARIANCE COMPUTATION
       205 DO 33 I=1,N

               Z(I)=DCMPLX(X(I),Y(I))
        33 CONTINUE
!C     FOURIER TRANSFORM

          CALL MIXRAD(Z,N,N2P,ISG)
          II=1
          DO 34 I=1,LAGH1
               X(I)=DREAL(Z(I))*ALD1

               XA(I,II)=X(I)
       34 CONTINUE
          X0=X(1)

          AMEAN(II)=XMEAN
!C     NORMALIZATION
       36 CX0=X(1)

          CALL CORNOM(X,CNA1(1,II),LAGH1,CX0,CX0)

          IF(ISW.EQ.1) GO TO 300
          IF(II.EQ.2) GO TO 216
          II=2
          DO 35 I=1,LAGH1
                X(I)=DIMAG(Z(I))*ALD1

                XA(I,II)=X(I)
       35 CONTINUE
          Y0=X(1)

          AMEAN(II)=YMEAN
          GO TO 36
      216 IF(ISW.NE.4) GO TO 300
!C     CROSS COVARIANCE COMPUTATION
          DO 127 I=2,M
               NI=NP2-I
               Z(I)=ZS(I)

               Z(NI)=DCONJG(ZS(I))
      127 CONTINUE
          Z(1)=ZS(1)
          Z(M1)=ZS(M1)
!C     FOURIER TRANSFORM
          CALL MIXRAD(Z,N,N2P,ISG)
          DO 41 I=1,LAGH
                I1=I+1
                J1=NP1-I
                X(I1)=DREAL(Z(I1))*ALD1

                Y(I1)=DREAL(Z(J1))*ALD1
       41 CONTINUE
          X(1)=DREAL(Z(1))*ALD1
          Y(1)=X(1)
!C     NORMALIZATION
          CALL CORNOM(X,CN1,LAGH1,X0,Y0)
          CALL CORNOM(Y,CN2,LAGH1,X0,Y0)

      300 CONTINUE
    END SUBROUTINE
                       
    SUBROUTINE FPEAUTF(L,N,SD,CXX,SSD,FPE,RFPE,D,CHI2,      &
                       OFPE1,OFPE2,ORFPE,MO,OSD,A,AO)
          implicit none
!C
!C     PROGRAM 5.3.1   FPE AUTO
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM PERFORMS FPE(FINAL PREDICTION ERROR) COMPUTATION FOR
!C     ONE-DIMENSIONAL AR-MODEL. A CARD CONTAINING THE FOLLOWING
!C     INFORMATION OF L, UPPER LIMIT OF MODEL ORDER, SHOULD BE ADDED ON
!C     TOP OF THE OUTPUT OF PROGRAM 5.1.1 AUTCOR TO FORM THE INPUT TO
!C     THIS PROGRAM.
!C     CXX(0) IS READ AS INITIAL SD.
!C     THE OUTPUTS ARE THE COEFFICIENTS A(I) OF AR-PROCESS
!C     X(N)=A(1)X(N-1)+...+A(M)X(N-M)+E(N)
!C     AND THE VARIANCE SIGMA**2 OF E(N).
!C     CHI**2 SHOWS THE SIGNIFICANCE OF PARCOR=A(M) AS A CHI-SQUARED
!C     VARIABLE WITH D.F.=1.
!C

          INTEGER(4) :: L, N, MO
          REAL(8) :: SD, OFPE1, OFPE2, ORFPE, OSD
          REAL(8), dimension(L) :: CXX, SSD, FPE, RFPE, D, CHI2, AO
          REAL(8), dimension(L,L) :: A 
          !Locals
          INTEGER(4) :: NP1,NM1,OOFPE,M,I,LM,IM,MP1
          REAL(8)    ::  AN, ANP1, ANM1, CST1, OOFPE, SE, SD0, D2
          REAL(8), dimension(L) :: B

          AN=N
          NP1=N+1
          NM1=N-1
          ANP1=NP1
          ANM1=NM1

          OFPE1=(ANP1/ANM1)*SD
          CST1=1.0_8

          OOFPE=CST1/OFPE1
          ORFPE=CST1
          OSD=SD
          MO=0
          OFPE2=OFPE1

          SE=CXX(1)
          SD0=SD
!C
          DO 400 M=1,L
              MP1=M+1

              D(M)=SE/SD0
              A(M,M)=D(M)
              D2=D(M)*D(M)
              SSD(M)=(CST1-D2)*SD0
              SD0=SSD(M)
              ANP1=NP1+M
              ANM1=NM1-M

              FPE(M)=(ANP1/ANM1)*SSD(M)
              RFPE(M)=FPE(M)*OOFPE
              CHI2(M)=D2*ANM1
              IF(M.EQ.1) GO TO 410

              LM=M-1
              DO 420 I=1,LM

                   A(I,M)=A(I,M-1)-D(M)*B(I)
          420 CONTINUE

          410 CONTINUE
              DO 421 I=1,M
                     IM=MP1-I

                     B(I)=A(IM,M)
          421 CONTINUE

              IF(OFPE2.LT.FPE(M)) GO TO 440
              OFPE2=FPE(M)
              ORFPE=RFPE(M)
              OSD=SSD(M)
              MO=M
              DO 430 I=1,M

                    AO(I)=A(I,M)
          430 CONTINUE
          440 IF(M.EQ.L) GO TO 400
              SE=CXX(MP1)
              DO 441 I=1,M

                     SE=SE-B(I)*CXX(I)
          441 CONTINUE
      400 CONTINUE
    END SUBROUTINE
                       
                   
    SUBROUTINE FPEC7F(N,L,IR,IP,IP0,INW,R1,R2,FPEC,RFPEC,AIC,   &
                             IFPEC,OFPEC,ORFPEC,OAIC,OSD,AO)
          implicit none
!C
!C     PROGRAM 5.3.2   FPEC(AR-MODEL FITTING FOR CONTROL)
!C-----------------------------------------------------------------------
!C      SUBROUTINE FPEC7F(N,L,IR,IP,IP0,LAGH1,INW,MJ,MJ0,
!C      SUBROUTINE RECOVA(X,LAGH1,L1,IP0)
!C      SUBROUTINE SFPEC(SD,N,K,IR,MS,Z,RZ,OOZ,AIC)
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM PERFORMS FPEC(AR-MODEL FITTING FOR CONTROL)
!C     COMPUTATION.
!C     BESIDES THE OUTPUTS OF PROGRAM 5.1.2   MULCOR, THE FOLLOWING
!C     INPUTS ARE REQUIRED:
!C     L: UPPER LIMIT OF MODEL ORDER M (LESS THAN 30)
!C     IR: NUMBER OF CONTROLLED VARIABLES
!C     IL: NUMBER OF MANINPULATED VARIABLES, IL=0 FOR MFPE COMPUTATION
!C     INW(I): INDICATOR; FIRST IR INDICATE THE CONTROLLED VARIABLES
!C     AND THE REST THE MANIPULATE VARIABLES WITHIN THE IP0 VARIABLES
!C     IN THE OUTPUT OF PROGRAM 5.1.2   MULCOR.
!C     THE OUTPUTS ARE THE PREDICTION ERROR COVARIANCE MATRIX OSD AND
!C     THE SET OF COEFFICIENT MATRICES A AND B TO BE USED IN
!C     PROGRAM 5.5.1   OPTIMAL CONTROLLER DESIGN.

          INTEGER(4) :: N, L, IR, IP, IP0,  IFPEC
          INTEGER(4), dimension(IP) :: INW
          REAL(8), dimension(L+1,IP0,IP0) :: R1, R2 
          REAL(8), dimension(0:L) :: FPEC, RFPEC,AIC
          REAL(8) ::  OFPEC, ORFPEC, OAIC 
          REAL(8), dimension(IR,IR) :: OSD 
          REAL(8), dimension(L,IR,IP) :: AO
          ! Locals
          INTEGER(4) ::     L1,II,I,J,JJ,MS0,M
          REAL(8)    ::     OOFPEC, SDDET, SFDET
          REAL(8), dimension(L,IP,IP) :: A1, B1
          REAL(8), dimension(IP0,IP0) :: C1
          REAL(8), dimension(IP,IP) ::  SD,SE,SF,XSD,XSF,D,E,Z1
!DIR$ ATTRIBUTES ALIGN : 64 :: A1,B1,C1,SD,SE,SF,XSD,XSF,D,E,Z1     

          L1=L+1

          DO 10 II=1,L1

                DO 22 I=1,IP0
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                    
                        DO 20 J=1,IP0

                            C1(I,J)=R1(II,I,J)
                        20 CONTINUE
             22 CONTINUE

                CALL REARRA(C1,INW,IP0,IP)

                DO 23 I=1,IP
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                      
                       DO 21 J=1,IP

                         R2(II,I,J)=C1(I,J)
                    21 CONTINUE
             23 CONTINUE
       10 CONTINUE

          DO 331 II=1,IP
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                
              DO 330 JJ=1,IP

                   SD(II,JJ)=R2(1,II,JJ)
                   SF(II,JJ)=SD(II,JJ)

                   SE(II,JJ)=R2(2,II,JJ)
                   XSD(II,JJ)=SD(II,JJ)

                   XSF(II,JJ)=SF(II,JJ)
            330 CONTINUE
      331 CONTINUE
!C     0-TH STEP COMPUTATION
          IFPEC=0
          MS=0

          CALL SFPEC(SD,N,IP,IR,MS,FPEC(0),RFPEC(0),OOFPEC,AIC(0))

          OAIC=AIC(0)
          OFPEC=FPEC(0)
          ORFPEC=RFPEC(0)
!C     ITERATION M=1 TO L
          DO 400 M=1,L
!C     INVERSE OF SD, SF COMPUTATION

                 CALL INVDET(XSD,SDDET,IP,IP)
                 CALL INVDET(XSF,SFDET,IP,IP)
!C     D, E, SD, SF COMPUTATION

                 CALL MULPLY(SE,XSF,D,IP,IP,IP)
                 CALL TRAMDL(SE,XSD,E,IP,IP,IP)
                 CALL TRAMDR(D,SE,Z1,IP,IP,IP)
                 CALL SUBTAL(SD,Z1,IP,IP)
                 CALL MULPLY(E,SE,Z1,IP,IP,IP)
                 CALL SUBTAL(SF,Z1,IP,IP)
                 MS=M

                 DO 411 II=1,IP
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                       
                        DO 410 JJ=1,IP
                               XSD(II,JJ)=SD(II,JJ)

                               XSF(II,JJ)=SF(II,JJ)
                     410 CONTINUE
             411 CONTINUE

                 CALL SFPEC(SD,N,IP,IR,MS,FPEC(M),RFPEC(M),OOFPEC,AIC(M))

                 CALL COEFAB(A1,B1,D,E,MS,L,IP)

                 IF(OFPEC.LE.FPEC(M)) GO TO 440
                 OAIC=AIC(M)
                 OFPEC=FPEC(M)
                 ORFPEC=RFPEC(M)
                 IFPEC=M

                 DO 566 II=1,IR
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                       
                         DO 560 JJ=1,IR

                                 OSD(II,JJ)=SD(II,JJ)
                     560 CONTINUE
              566 CONTINUE
                  DO 561 I=1,M
                         DO 562 II=1,IR
 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))  
                                 DO 563 JJ=1,IP

                                         AO(I,II,JJ)=A1(I,II,JJ)
                             563 CONTINUE
                      562 CONTINUE
                561 CONTINUE
                    440 IF(M.EQ.L) GO TO 400

                         CALL NEWSE(A1,R2,SE,MS,L,IP,L+1)
      400 CONTINUE

    END SUBROUTINE

    SUBROUTINE SFPEC(SD,N,K,IR,MS,Z,RZ,OOZ,AIC)
          implicit none
          INTEGER(4) :: N, K, IR, MS
          REAL(8), dimension(K,K) :: SD 
          REAL(8) :: Z, RZ, OOZ, AIC
          ! lOCALS
          INTEGER(4) :: KM,I,J
          REAL(8)    ::   AN, ANP, ANM, AP, APR, CST1, SDRM, ARM2
          REAL(8), dimension(IR,IR) :: SD1 
          AN=N
          KM=K*MS
          ANP=N+1+KM
          ANM=N-1-KM
          AP=ANP/ANM
          APR=AP**IR
          CST1=1.0_8
          DO 9 I=1,IR

                 DO 8 J=1,IR

                       SD1(I,J)=SD(I,J)
               8 CONTINUE
         9 CONTINUE

           CALL SUBDET(SD1,SDRM,IR,IR)
           Z=APR*SDRM
           ARM2=2*MS*K*IR
           AIC=AN*DLOG(SDRM)+ARM2
           IF(MS.NE.0) GO TO 10
           OOZ=CST1/Z
         10 RZ=Z*OOZ
    
    END SUBROUTINE
    
    SUBROUTINE MARKOVF(N,LAGH3,ID,CYY0,K,NH,JAW,AW1,B1,ICONT,   &
                        IDD,IR,IJ,IK,IPQ,G,A1,A,B,VD,IQM,BM,AU,ZZ,C0,AICD, &
                           MJ3,MJ4,MJ6,MJ7  )
          implicit none

!cc       PROGRAM MARKOV
!C     PROGRAM 74.2.2. MAXIMUM LIKELIHOOD COMPUTATION OF MARKOVIAN MODEL
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: DECEMBER 6, 1978
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C        "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(1
!C        BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C        NO.5, MARCH 1975, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** FOR THE BASIC THEORY SEE "CANONICAL CORRELATION ANALYSIS OF TIM
!C        AND THE USE OF AN INFORMATION CRITERION" BY H. AKAIKE, IN
!C        "SYSTEM IDENTIFICATION: ADVANCES AND CASE STUDIES" R. K. MEHRA
!C        D. G. LAINIOTIS EDS. ACADEMIC PRESS, NEW YORK, 1976
!C-----------------------------------------------------------------------
!C     IN THIS PROGRAM THE MATRICES A,B,C, STAND FOR TRANSITION MATRIX (F
!C     INPUT MATRIX (G), OUTPUT MATRIX (H), RESPECTIVELY.
!C
!C     THE INPUTS REQUIRED ARE AS FOLLOWS:
!C     (N,LAGH0,ID0):
!C         N, LENGTH OF ORIGINAL DATA
!C         LAGH0, MAXIMUM LAG OF COVARIANCE
!C         ID0, DIMENSION OF Y(I)
!C     (CYY(I)(I=0,LAGH0): COVARIANCE MATRIX SEQUENCE OF Y(I). CYY(I) ARE
!C                           THE OUTPUTS OF THE PROGRAM MULCOR OF TIMSAC AND
!C                           ARE USED AS THE INPUT TO THE PROGRAM CANOCA OF
!C                           TIMSAC-74. FOR THE CONSTRUCTION OF CYY(I),
!C                           SEE PROGRAM CANOCA.
!C     THE OUTPUTS OF PROGRAM CANACA:
!C          (ID,K):
!C              ID, DIMENSION OF THE TIME SERIES Y(I) (NOT GREATER THAN 5)
!C              K, DIMENSION OF THE STATE VECTOR (NOT GREATER THAN 10)
!C          (NH(I))(I=1,K): STRUCTURAL CHARACTERISTIC VECTOR
!C          (AW(I))(I=1,IAW): INITIAL ESTIMATE OF THE VECTOR OF FREE
!C                               PARAMETERS IN F (=A)
!C          B(I,J)(I=1,ID+1;J=1,ID): INITIAL ESTIMATES OF THE FREE
!C                                       PARAMETERS IN G (=B)
!C     ICONT: OUTPUT CONTROL
!C          = 0, FOR AR-MA COEFFICIENTS
!C          = 1, FOR SIMCON INPUT
!C          = 2, FOR BOTH
!C
!C     THE OUTPUTS OF THIS PROGRAM ARE;
!C     THE MAXIMUM LIKELIHOOD ESTIMATES
!C          (ID,K):
!C          (NH(I))(I=1,K):
!C          (AW(I))(I=1,IAW):
!C          (B(I,J))(I=1,ID+1;J=1,ID):
!C     AND THE OUTPUTS TO BE USED BY THE PROGRAMS PRDCTR AND SIMCON
!C          (ID,Q,Q-1):
!C          (B(I,J,L))(I,J=1,ID,L=1,Q): AR-COEFFICIENT MATRICES
!C          AND, WHEN ICONT=1 OR 2,
!C          (W(I,J,L))(I,J=1,ID,L=1,Q-1): IMPULSE RESPONSE MATRICES
!C          AND, WHEN ICONT=0 OR 1,
!C          (A(I,J,L))(I,J=1,ID;L=1,Q-1): MA-COEFFICIENT MATRICES
!C     AND
!C          (C0(I,J))(I,J=1,ID): INNOVATION COVARIANCE.
!C
!C     COMMENTS:
!C     ***** IT IS ASSUMED THAT ID0=ID. OTHERWISE USE THE LOADING
!C     PROGRAM OF CYY(I) USED BY THE PROGRAM CANOCA.
!C     ***** THE INPUT TO THIS PROGRAM IS NOT LIMITED TO THE OUTPUT OF
!C     PROGRAM CANOCA. THE FINAL DECISION ON THE STRUCTURAL
!C     CHARACTERISTIC VECTOR NH(I) (I=1,K) SHOULD BE MADE BY COMPARING
!C     THE AIC VALUES OF VARIOUS POSSIBLE CHOICES OF NH WITH
!C     THE MINIMUM AIC OF THE AR-MODEL.
!C     ***** TO KEEP THE ACCURACY OF COMPUTATION THE COMPONENTS OF Y(I)
!C     SHOULD BE SCALED SO THAT THE VARIANCES ARE NEARLY EQUAL TO EACH
!C     OTHER.
!C     *****
!C

      

          INTEGER(4) :: N, LAGH3, ID, K, JAW, ICONT, &
                           IPQ, IQM, MJ3, MJ4, MJ6, MJ7
          INTEGER(4), dimension(K) :: IDD,IR,NH
          INTEGER(4), dimenSion(ID) :: IJ,IK
          REAL(8), dimension(LAGH3,ID,ID)  :: CYY0 
          REAL(8), dimension(JAW) ::  AW1 
          REAL(8), dimension(K,ID) :: B1,B 
          REAL(8), dimension(MJ4) :: G 
          REAL(8), dimension(K,K) ::  A1,A
          REAL(8), dimension(K,ID) ::  B 
          REAL(8), dimension(MJ4,MJ4) :: VD 
          REAL(8), dimension(ID,ID,MJ6) :: BM
          REAL(8), dimension(ID,ID,MJ7) :: AU, ZZ 
          REAL(8), dimension(ID,ID) :: C0 
          REAL(8) :: AICD 
          ! Locals
          INTEGER(4) :: ISWR,KSWR,II,JJ,KK,I,J,IDP1,JS,ISWRO, &
                           IAW,IG,IPQ,ISFIN
          REAL(8) :: AICO , CST0, CST1, CST05, AIPQ, SUM
     
          REAL(8), dimension(MJ3,ID,ID) :: CYY1 
          REAL(8), dimension(K,ID) ::  OB 
          REAL(8), dimension(MJ4) ::  X, R 
          REAL(8), dimension(JAW) ::  AW,OAW
          REAL(8), dimension(50,ID,K) :: O 
          REAL(8), dimension(50,K,ID) ::  Q 
          REAL(8), dimension(50,K,K) :: X1
          REAL(8), dimension(50,ID,ID) :: X2
          REAL(8), dimension(100,ID,ID) :: CXY1
          REAL(8), dimension(51,ID,ID) ::  CXX1 
          REAL(8), dimension( 51,ID,K) :: CXV1 
 !DIR$ ATTRIBUTES ALIGN : 64 :: CYY1,OB,X,R,AW,OAW,O,Q,X1,X2,CXY1,CXX1,CXV1    

          COMMON /COM99/ISWR
          COMMON /COM101/AICO
          COMMON /COM102/KSWR
          CST0=0.0_8
          CST1=1.0_8
          CST05=0.00005_8

          DO 1011 II=1,ID

             DO 1010 JJ=1,ID
                 DO 1008 KK=1,MJ3
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                        CYY1(KK,JJ,II)=0
1008             CONTINUE
 !DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                
                 DO 1009 KK=1,LAGH3
                        CYY1(KK,JJ,II)=CYY0(KK,JJ,II)
         1009    CONTINUE
       1010 CONTINUE
     1011 CONTINUE

          CALL SUBIDR(NH,IDD,IR,IJ,IK,K,ID,IAW)
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))   
          DO 4009 I=1,JAW
                AW(I)=AW1(I)
     4009 CONTINUE
          JS=0

          A(1:K,1:K)=CST0
          A1(1:K,1:K)=CST0
          DO 4011 I=1,K
             IF(IDD(I).NE.0) GO TO 4012
             JJ=IR(I)
             A(I,JJ)=CST1
             A1(I,JJ)=CST1
             GO TO 4011
        4012 JL=IR(I)
                DO 4013 J=1,JL
                        JS=JS+1

                        A(I,J)=AW(JS)
                        A1(I,J)=AW(JS)
          4013 CONTINUE
     4011 CONTINUE

          IDP1=ID+1

          DO 4020 I=1,K
                 DO 4019 J=1,ID
                       B(I,J)=B1(I,J)
         4019    CONTINUE
     4020 CONTINUE
  
          ISWR=0
          ISWRO=0

      400 IPQ=IAW+(K-ID)*ID
          AIPQ=IPQ
          IDP1=ID+1
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 500 I=1,IAW

                X(I)=AW(I)
      500 CONTINUE
          JJ=IAW

          DO 511 I=IDP1,K
                 DO 510 J=1,ID
                         JJ=JJ+1

                         X(JJ)=B(I,J)
             510 CONTINUE
      511 CONTINUE
!C     INNOVATION COVARIANCE MATRIX (CXX0(0)) AND GRADIENT G(X)
!C     OF LOG(DET.CXX0(0)) COMPUTATION
          KSWR=0
          IG=0

          CALL C0GR(CYY1,MJ3,B,AW,IAW,NH,IDD,IR,IJ,IK,X,C0,G,M,L,K,ID,   &
                        MJ4,IG,O,Q,X1,X2,CXY1,CXX1,CXV1)
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))               
          DO 1500 I=1,IAW

                  X(I)=AW(I)
     1500 CONTINUE
          JJ=IAW

          DO 1511 I=IDP1,K
                  DO 1510 J=1,ID
                          JJ=JJ+1

                          X(JJ)=B(I,J)
             1510 CONTINUE
     1511 CONTINUE

          CALL SUBHES(CYY1,IJ,IK,VD,M,L,K,ID,IAW,MJ3,MJ4,O,Q,X1,X2,     &
                               CXY1,CXX1,CXV1)
          IF(ISWRO.GT.0) GO TO 2651

     2651 CALL MATINV(IPQ,VD,MJ4)
          IF(ISWRO.GT.0) GO TO 2650

     2650 DO 100 I=1,IPQ
               SUM=CST0
               DO 110 J=1,IPQ

                       SUM=SUM+VD(I,J)*G(J)
           110 CONTINUE

               R(I)=SUM
100       CONTINUE
!C     ORIGINAL PARAMETER VALUES
 !DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))         
          DO 2655 I=1,IAW

                 OAW(I)=AW(I)
     2655 CONTINUE

          DO 2657 I=IDP1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))         
                  DO 2656 J=1,ID

                        OB(I,J)=B(I,J)
             2656 CONTINUE
     2657 CONTINUE
!C     DAVIDON'S PROCEDURE

          CALL SUBDAV(CYY1,MJ3,B,AW,IAW,NH,IDD,IR,IJ,IK,VD,X,C0,G,R,N,K, &
                       ID,IPQ,AICD,MJ4,ISWRO,O,Q,X1,X2,CXY1,CXX1,CXV1)
     
          ISFIN=0
          IF(ISWRO.GE.20) GO TO 599
          IF (ISWRO.EQ.0) GO TO 599
          DO 150 I=1,IAW
                 IF(DABS(OAW(I)-X(I)).GE.CST05) GO TO 153
      150 CONTINUE
          JJ=IAW

          DO 152 I=IDP1,K
                DO 151 J=1,ID
                       JJ=JJ+1
                       IF(DABS(OB(I,J)-X(JJ)).GE.CST05) GO TO 153
            151 CONTINUE
      152 CONTINUE
          GO TO 599
      153 ISFIN=1
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
      599 DO 600 I=1,IAW

                 AW(I)=X(I)
      600 CONTINUE
          IDP1=ID+1
          JJ=IAW

          DO 611 I=IDP1,K
                DO 610 J=1,ID
                       JJ=JJ+1

                       B(I,J)=X(JJ)
            610 CONTINUE
      611 CONTINUE
          IF(ISFIN.EQ.0) GO TO 1450
          GO TO 400

     1450 CONTINUE

          CALL SUBA(A,AW,IJ,IK,K,ID,IAW)


          CALL ARMACO(B,AW,IAW,NH,IDD,IR,IK,ID,ICONT,K,BM,AU,ZZ,    &
                 IQM,MJ6,MJ7)
    END SUBROUTINE
                           
      

      SUBROUTINE C0GR(CYY1,MJ3,B,AW,IAW,NH,IDD,IR,IJ,IK,X,C0,GR,M,L,K,   &
                        ID,MJ4,IG,O,Q,X1,X2,CXY1,CXX1,CXV1)
          implicit none
                               
!C     THIS SUBROUTINE COMPUTES THE INNOVATION MATRIX CXX(0) AND
!C     THE GRADIENT OF LOG(DET CXX(0))

      

          INTEGER(4) :: MJ3, IAW,M, L,K, ID, MJ4, IG
   
          INTEGER(4), dimension(K)  :: NH,IDD,IR
          INTEGER(4), dimension(ID) :: IJ,IK
          REAL(8), dimension(MJ3,ID,ID) :: CYY1 
          REAL(8), dimension(K,ID)      :: B 
          REAL(8), dimension(IAW)       :: AW 
          REAL(8), dimension(MJ4)       :: X,GR 
          REAL(8), dimension(ID,ID)     :: C0
          REAL(8), dimension(50,ID,K)   :: O         
          REAL(8), dimension(50,K,ID)   :: Q 
          REAL(8), dimension(50,ID,ID)  :: X2  
          REAL(8), dimension(50,K,K)    :: X1         
          REAL(8), dimension(100,ID,ID) :: CXY1
          REAL(8), dimension(51,ID,ID)  :: CXX1
          REAL(8), dimension(51,ID,K)   :: CXV1
          ! LoCALS
          INTEGER(4) :: KSWR,I,IDP1,JJ,J,IG1,IG2,KK
      
          COMMON /COM102/KSWR          

          DO 600 I=1,IAW

              AW(I)=X(I)
      600 CONTINUE
          IDP1=ID+1
          JJ=IAW

          DO 611 I=IDP1,K
               DO 610 J=1,ID
                     JJ=JJ+1

                     B(I,J)=X(JJ)
           610 CONTINUE
      611 CONTINUE
!C     IMPULSE RESPONSE COMPUTATION
          IG1=IG
          IG2=IG

          CALL NSUBX1(B,AW,IAW,NH,IDD,IR,K,ID,M,IG1,X1)
          CALL NSUBX2(B,AW,IAW,IDD,IR,K,ID,KK,IG2,Q,X2)
          IG=IG1+IG2
          IF(KSWR.EQ.0) GO TO 620
          IF(IG.NE.0) GO TO 1000
       620 L=KK

           CALL SBCXY1(CYY1,MJ3,M,L,ID,X2,CXY1)

           CALL SUBCXX(C0,M,KK,ID,X2,CXY1,CXX1)

           CALL GCXV1(M,L,K,ID,Q,CXY1,CXV1)

           CALL NSUBO(C0,K,ID,M,O,X1)

           CALL GRAD(IJ,IK,GR,M,K,ID,IAW,MJ4,O,CXX1,CXV1)
      1000 KSWR=1
    END SUBROUTINE
                        

    SUBROUTINE NSUBX1(B,AW,IAW,NH,IDD,IR,K,ID,M,IG1,X1)
          implicit none
!C     THIS SUBROUTINE COMPUTES THE IMPULSE RESPONSE OF
!C     (INVERSE OF (C*(INVERSE OF PHAI)*B))*C*
!C     (INVERSE OF PHAI). PHAI = INVERSE OF (I-A*EXP(-I*2*PI*F)).
!C     C*(INVERSE OF PHAI): FROM V TO Y
!C     INVERSE OF (C*(INVERSE OF PHAI)*B): FROM Y TO X
!C     K: DIMENSION OF THE STATE VECTOR
!C     ID: DIMENSION OF Y(I)
!C     M: UPPER LIMIT OF THE NUMBER OF IMPULSE RESPONSES.
!C

     

          INTEGER(4) :: IAW, K, ID, M, IG1
          INTEGER(4), dimension(K)    :: NH,IDD,IR
          REAL(8), dimension(K,ID)    :: B 
          REAL(8), dimension(IAW)     :: AW 
          REAL(8), dimension(50,K,K)  :: X1
          ! Locals
          INTEGER(4) :: ISWR,ITINP,I,J,LH,IH,NS,NSM1,IH
          REAL(8) ::    CST0, CST1, CONSTM, CONSTD, SUM, XMAX
          REAL(8), dimension(K,K)     :: V, AV, U, AU 
          REAL(8), dimension(ID,K)    :: X, Y
!DIR$ ATTRIBUTES ALIGN : 64 :: V,AV,U,AU,X,Y               
          COMMON /COM99/ISWR
          CST0=0.0_8
          CST1=1.0_8
          ITINP=0

      199 CONTINUE
          V(1:K,1:K)=CST0
          DO 200 I=1,K
                V(I,I)=CST1
      200 CONTINUE

          Y(1:ID,1:K)=CST0
          DO 300 I=1,ID

               Y(I,I)=CST1
      300 CONTINUE

          DO 401 I=1,ID
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 400 J=1,K
                       X(I,J)=Y(I,J)

                       X1(1,I,J)=X(I,J)
           400 CONTINUE
      401 CONTINUE

          U(1:K,1:K)=CST0
          DO 500 I=1,K
 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                 DO 510 J=1,ID

                      U(I,J)=B(I,J)
            510 CONTINUE
      500 CONTINUE

          CONSTM=0.1_8
          CONSTD=0.0001_8
          LH=6
          IH=0
          NS=1
          NSM1=NS-1
          IF(IG1.EQ.0) GO TO 270
          CONSTD=0.01_8
          IG1=0
      270 IF(ISWR.GE.1) GO TO 280
          CONSTD=0.01_8

      280 CALL SUBAWZ(AW,IAW,IDD,IR,V,AV,K,K)

          DO 231 I=1,K
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 230 J=1,K

                      V(I,J)=AV(I,J)
            230 CONTINUE
      231 CONTINUE


          DO 321 I=1,ID
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))              
                 DO 320 J=1,K

                        Y(I,J)=V(I,J)
             320 CONTINUE
      321 CONTINUE

          CALL SUBAWZ(AW,IAW,IDD,IR,U,AU,K,K)

          DO 451 I=1,ID
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))              
                DO 450 J=1,K

                    X(I,J)=Y(I,J)-AU(I,J)
            450 CONTINUE
      451 CONTINUE

          DO 453 I=1,ID
                DO 452 J=1,K

                     X1(NS+1,I,J)=X(I,J)
            452 CONTINUE
      453 CONTINUE
!C
!C     U(NS)=A*U(NS-1)+B*X(NS) COMPUTATION

          DO 182 I=1,K
                 DO 180 J=1,K
                         SUM=CST0
!DIR$ SIMD REDUCTION(+:SUM)
                           DO 181 JJ=1,ID

                                 SUM=SUM+B(I,JJ)*X(JJ,J)
                       181 CONTINUE

                           U(I,J)=AU(I,J)+SUM
               180 CONTINUE
      182 CONTINUE
!C

          CALL SUBMAX(X,XMAX,ID,K)

          IF(XMAX.GE.CONSTD) GO TO 740
          IH=IH+1
          IF(IH.LT.LH) GO TO 720
          GO TO 760
      740 IH=0
      720 IF(NS.GE.49) GO TO 770
          NS=NS+1
          GO TO 280
      770 M=49

          IG1=1
          IF(ISWR.GE.1) GO TO 771
          IG1=0
!C     RESCALING FOR A FEASIBLE INITIAL
          IF(ITINP.GE.50) GO TO 771
          ITINP=ITINP+1

          CALL RESCAL(B,AW,IAW,NH,IDD,IR,K,ID)

          GO TO 199
      771 ISWR=ISWR+1
          RETURN
      760 M=NS-LH
    END SUBROUTINE
    

    SUBROUTINE NSUBX2(B,AW,IAW,IDD,IR,K,ID,KK,IG2,Q,X2)
          implicit none
!C     THIS SUBROUTINE COMPUTES X2(NS,I,J) AND U(NS),
!C     NS=0,1,2,...,L(=KK).
!C

      

          INTEGER(4) :: IAW,  K, ID, KK, IG2
          INTEGER(4), dimension(K)     :: IDD,IR
          REAL(8), dimension(K,ID)     :: B 
          REAL(8), dimension(IAW)      :: AW 
          REAL(8), dimension(50,K,ID)  :: Q 
          REAL(8), dimension(50,ID,ID) :: X2
      ! Locals
          INTEGER(4) :: ISWR,I,J,LH,IH,NS,NSM1,KMD,IDP1,IPD,IG2
          REAL(8)    ::  XMAX,CST0,CST1,CONSTD,SUM
          REAL(8), dimension(K,ID) :: U,AU
          REAL(8), dimension(ID,ID) :: XX
!DIR$ ATTRIBUTES ALIGN : 64 :: U,AU,XX
          COMMON /COM99/ISWR

          CST0=0.0_8
          CST1=1.0_8
          X2(1,1:ID,1:ID)=CST0

          DO 200 I=1,ID

                  X2(1,I,I)=CST1
      200 CONTINUE

          DO 301 I=1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 300 J=1,ID

                       U(I,J)=B(I,J)
            300 CONTINUE
      301 CONTINUE

          CONSTD=0.0001_8
          LH=6
          IH=0
          NS=1
          NSM1=NS-1
          KMD = K - ID
          IDP1 = ID + 1

          DO 192 I=1,KMD
                 IPD = I + ID
                        DO 191 J=1,ID

                             Q(1,I,J) = U(IPD,J)
                    191 CONTINUE
      192 CONTINUE
          IF(IG2.EQ.0) GO TO 270
          CONSTD=0.01_8
          IG2=0
      270 IF(ISWR.GE.2) GO TO 280
          CONSTD=0.01_8

      280 CALL SUBAWZ(AW,IAW,IDD,IR,U,AU,K,ID)

          DO 451 I=1,ID
                 DO 450 J=1,ID

                           XX(I,J)=-AU(I,J)
             450 CONTINUE
      451 CONTINUE
!C
!C     U(NS)=A*U(NS-1)+B*X(NS) COMPUTATION

          DO 182 I=1,K
                DO 180 J=1,ID
                       SUM=CST0
 !DIR$ SIMD REDUCTION(+:SUM)                      
                          DO 181 JJ=1,ID

                                SUM=SUM+B(I,JJ)*XX(JJ,J)
                      181 CONTINUE

                          U(I,J)=AU(I,J)+SUM
            180 CONTINUE
      182 CONTINUE

          DO 193 I=1,KMD
                 IPD = I + ID
                   DO 190 J=1,ID

                          Q(NS+1,I,J) = U(IPD,J)
               190 CONTINUE
      193 CONTINUE

          DO 531 I=1,ID
                 DO 530 J=1,ID

                       X2(NS+1,I,J)=XX(I,J)
             530 CONTINUE
      531 CONTINUE
!C
!C     MAXIMUM ABSOLUTE VALUE OF XX(I,J) SEARCH

          CALL SUBMAX(XX,XMAX,ID,ID)

          IF(XMAX.GE.CONSTD) GO TO 740
          IH=IH+1
          IF(IH.LT.LH) GO TO 720
          GO TO 760
      740 IH=0
      720 IF(NS.GE.49) GO TO 770
          NS=NS+1
          GO TO 280
      770 KK=49

          IG2=1
          RETURN
      760 KK=NS-LH
    END SUBROUTINE
    

    SUBROUTINE NSUBO(C0,K,ID,M,O,X1)
          implicit none
!C     THIS SUBROUTINE COMPUTES O(NS).
!C     O(NS)=(INVERSE OF C0)*X1(NS)

          INTEGER(4) :: K, ID, M
          REAL(8), dimension(ID,ID)    :: C0 
          REAL(8), dimension(50,ID,K)  :: O 
          REAL(8), dimension(50,K,K)   :: X1
          ! Locals
          INTEGER(4) :: I,J,MP1,NS,NSM1
          REAL(8) :: C0DET
          REAL(8), dimension(ID,ID) :: C0I 
          REAL(8), dimension(ID,K)  :: X, OO
!DIR$ ATTRIBUTES ALIGN : 64 :: C0I,X,OO
!C
!C     INVERSE OF C0 COMPUTATION

         DO 601 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                 DO 600 J=1,ID

                       C0I(I,J)=C0(I,J)
             600 CONTINUE
     601 CONTINUE

         CALL INVDET(C0I,C0DET,ID,ID)
!C
         MP1=M+1
         DO 1000 NS=1,MP1

                DO 611 J=1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                    
                       DO 610 I=1,ID
!cxx  610 X(I,J)=X1(NS,I,J)
                             X(I,J)=X1(NS,I,J)
                    610 CONTINUE
           611 CONTINUE
!C     O(NS)=(INVERSE OF C0)*X(NS) COMPUTATION

               CALL MULPLY(C0I,X,OO,ID,ID,K)

               DO 621 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                   
                       DO 620 J=1,K
!cxx  620 O(NS,I,J)=OO(I,J)
                              O(NS,I,J)=OO(I,J)
                   620 CONTINUE
           621 CONTINUE
               NSM1=NS-1
     1000 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE SUBMAX(XX,XMAX,IA,IB)
          implicit none
!C     MAXIMUM ABSOLUTE VALUE OF XX(I,J) SEARCH

          INTEGER(4) :: IA, IB
          REAL(8), dimension(IA,IB) :: XX 
          REAL(8) :: XMAX 
          ! Locals
          INTEGER(4) :: I,J
          REAL(8) :: T
          XMAX=0.0_8
          DO 709 I=1,IA
               DO 710 J=1,IB
                      T=DABS(XX(I,J))
                      IF(XMAX.GE.T) GO TO 710
                      XMAX=T
           710 CONTINUE
      709 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE GRAD(IJ,IK,GR,M,K,ID,IAW,MJ4,O,CXX1,CXV1)
          implicit none
!C     THIS SUBROUTINE COMPUTES GRADIENT (GA AND GB).
!C     GA=-2.0*(O(0)'*CXV1(1)+O(1)'*CXV1(2)+O(2)'*CXV1(3)+...+O(NSL)'*CXV
!C     1(1+NSL)).
!C     GB=-2.0*(O(0)'*CXX1(0)+O(1)'*CXX1(1)+O(2)'*CXX1(2)+...+O(NSL)'*CXX
!C     1(NSL)).
!C

          INTEGER(4), dimension(ID) :: IJ, IK 
          INTEGER(4) :: M, K, ID, IAW, MJ4
          REAL(8), dimension(MJ4) :: GR 
          REAL(8), dimension(50,ID,K)  :: O 
          REAL(8), dimension(51,ID,ID) :: CXX1 
          REAL(8), dimension(51,ID,K)  :: CXV1
          ! Locals
          INTEGER(4) :: MP1,NSP1,I,J,IKSJ,KS,JL,IJK,IDP1,JJ,NSP2
          REAL(8)    ::   CST0, CST1, CST2
          REAL(8), dimension(K,ID)  ::  OO, ZB,ZZB 
          REAL(8), dimension(ID,ID) ::  CXX 
          REAL(8), dimension(ID,K)  ::  CXV 
          REAL(8), dimension(K,K)   ::  ZA, ZZA
          REAL(8), dimension(MJ4)   ::  ZAW
!DIR$ ATTRIBUTES ALIGN : 64 :: OO,ZB,ZZB,CXX,CXV,ZA,ZZA,ZAW
          CST0=0.0_8
          CST1=1.0_8
          CST2=2.0_8

          ZA(1:K,1:K)=CST0
          ZB(1:K,1:ID)=CST0
          MP1=M+1
          DO 300 NSP1=1,MP1
                      NSP2=NSP1+1

                          DO 311 I=1,K
                               DO 310 J=1,ID
                                     OO(I,J)=O(NSP1,J,I)

                                     CXV(J,I)=CXV1(NSP2,J,I)
                           310 CONTINUE
                      311 CONTINUE

                     DO 321 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                            DO 320 J=1,ID

                                CXX(I,J)=CXX1(NSP1,I,J)
                       320 CONTINUE
                 321 CONTINUE

                     CALL MULPLY(OO,CXV,ZZA,K,ID,K)
                     CALL MATADL(ZA,ZZA,K,K)
                     CALL MULPLY(OO,CXX,ZZB,K,ID,ID)
                     CALL MATADL(ZB,ZZB,K,ID)
      300 CONTINUE
!C     GRADIENT ARRANGEMENT

          IKSJ=0
          DO 1300 KS=1,ID
                    JL=IK(KS)
                       DO 1310 J=1,JL

                            IKSJ=IKSJ+1
                            IJK=IJ(KS)

                            ZAW(IKSJ)=ZA(IJK,J)
                  1310 CONTINUE

     1300 CONTINUE
          IAW=IKSJ
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8)
          DO 500 I=1,IAW

                  GR(I)=-CST2*ZAW(I)
      500 CONTINUE
!C     K>ID
          IDP1=ID+1
          JJ=IAW

          DO 511 I=IDP1,K
               DO 510 J=1,ID
                        JJ=JJ+1
!cxx  510 GR(JJ)=-CST2*ZB(I,J)
                       GR(JJ)=-CST2*ZB(I,J)
           510 CONTINUE
      511 CONTINUE
    END SUBROUTINE
    
      SUBROUTINE SBCXY1(CYY1,MJ3,M,L,ID,X2,CXY1)
          implicit none
!C     THIS SUBROUTINE COMPUTES CXY1(LS) LS=0,M+1+L.
!C     CXY1(LS)=X2(0)*CYY1(LS)+X2(1)*CYY1(LS-1)+X2(2)*CYY1(LS-2)+...
!C     +X2(L)*CYY1(LS-L).

          INTEGER(4) :: MJ3, M, L, ID
          REAL(8), dimension(MJ3,ID,ID) :: CYY1 
          REAL(8), dimension(50,ID,ID)  :: X2 
          REAL(8), dimension(100,ID,ID) :: CXY1
          ! lOCALS
          INTEGER(4) :: LSL,LP1,LSP1,LS,I,J,MSP1,MS,LMS,LMSP1
          REAL(8) :: CST0
          REAL(8), dimension(ID,ID) :: XX, CYY, Z, ZZ
!DIR$ ATTRIBUTES ALIGN : 64 :: XX,CYY,Z,ZZ
          CST0=0.0D_8
          LSL=M+2+L
          LP1=L+1

          DO 200 LSP1=1,LSL
                     LS=LSP1-1

                 Z(1:ID,1:ID)=CST0
                 DO 300 MSP1=1,LP1
                        MS=MSP1-1

                        DO 311 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                            
                             DO 310 J=1,ID

                                   XX(I,J)=X2(MSP1,I,J)
                         310 CONTINUE
                   311 CONTINUE
                       LMS=LS-MS
                       IF(LMS.LT.0) GO TO 319
                       LMSP1=LMS+1

                       DO 321 I=1,ID
 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                             
                             DO 320 J=1,ID

                                  CYY(I,J)=CYY1(LMSP1,I,J)
                         320 CONTINUE
                  321 CONTINUE
                      GO TO 340
                  319 LMSP1=-LMS+1

                      DO 331 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                             
                          DO 330 J=1,ID

                               CYY(I,J)=CYY1(LMSP1,J,I)
                      330 CONTINUE
                 331 CONTINUE

                 340 CALL MULPLY(XX,CYY,ZZ,ID,ID,ID)
                     CALL MATADL(Z,ZZ,ID,ID)
            300 CONTINUE

                DO 351 I=1,ID
                        DO 350 J=1,ID

                                CXY1(LSP1,I,J)=Z(I,J)
                     350 CONTINUE
            351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
      
    SUBROUTINE SUBCXX(C0,M,KK,ID,X2,CXY1,CXX1)
          implicit none
!C     THIS SUBROUTINE COMPUTES CXX1(NS) NS=0,M+1.
!C     CXX1(NS)=CXY1(NS)*X2(0)'+CXY1(NS+1)*X2(1)'+CXY1(NS+2)*X2(2)'+...
!C     +CXY1(NS+MSL)*X2(MSL)'.

          INTEGER(4) :: M, KK, ID
          REAL(8), dimension(ID,ID)     ::   C0 
          REAL(8), dimension(50,ID,ID)  ::   X2 
          REAL(8), dimension(100,ID,ID) ::   CXY1
          REAL(8), dimension(51,ID,ID)  ::   CXX1
          ! lOCALS
          INTEGER(4) :: NSL,KKP1,NSP1,NS,I,J,MSP1,NSPMS1
          REAL(8) :: CST0
          REAL(8), dimension(ID,ID) :: XX, CXY, Z, ZZ
!DIR$ ATTRIBUTES ALIGN : 64 :: XX,CXY,Z,ZZ
          CST0=0.0_0
          NSL=M+2
          KKP1=KK+1

          DO 200 NSP1=1,NSL
                   NS=NSP1-1

                   Z(1:ID,1:ID)=CST0
                   DO 300 MSP1=1,KKP1
                          NSPMS1=NS+MSP1

                          DO 311 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                                DO 310 J=1,ID
                                     XX(I,J)=X2(MSP1,J,I)

                                     CXY(I,J)=CXY1(NSPMS1,I,J)
                            310 CONTINUE
                     311 CONTINUE

                         CALL MULPLY(CXY,XX,ZZ,ID,ID,ID)
                         CALL MATADL(Z,ZZ,ID,ID)
                  300 CONTINUE

                      DO 351 I=1,ID
 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                         
                           DO 350 J=1,ID

                               CXX1(NSP1,I,J)=Z(I,J)
                       350 CONTINUE
                 351 CONTINUE
      200 CONTINUE

          DO 401 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))              
                  DO 400 J=1,ID

                        C0(I,J)=CXX1(1,I,J)
              400 CONTINUE
      401 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE GCXV1(M,L,K,ID,Q,CXY1,CXV1)
          implicit none
!C     THIS SUBROUTINE COMPUTES CXV1(MS) MS=0,M+1.
!C     CXV1(MS)=CXY1(MS)*Q(0)'+CXY1(MS+1)*Q(1)'+...+CXY1(MS+L)*Q(L)'

          INTEGER(4) :: M, L, K, ID
          REAL(8), dimension(50,K,ID)   :: Q 
          REAL(8), dimension(100,ID,ID) :: CXY1 
          REAL(8), dimension(51,ID,K)   :: CXV1
           ! Locals
          INTEGER(4) :: MP2,LP1,IDP1,MSP1,KMD,I,J,MNSP1,NSP1,JMD,MS
          REAL(8) :: CST0
          REAL(8), dimension(ID,K-ID) :: QQ,Z,ZZ 
          REAL(8), dimension(ID,ID) :: CXY
!DIR$ ATTRIBUTES ALIGN : 64 :: QQ,Z,ZZ,CXY
          CST0=0.0_8
          MP2=M+2
          LP1=L+1
          KMD = K - ID
          IDP1 = ID + 1

          DO 200 MSP1=1,MP2
                   MS=MSP1-1


                  Z(1:ID,1:KMD)=CST0
                  DO 300 NSP1=1,LP1
                          MNSP1=MS+NSP1
                          DO 210 I=1,ID
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                              
                                DO 220 J=1,ID

                                      CXY(I,J)=CXY1(MNSP1,I,J)
                            220 CONTINUE
                                DO  230  J=1,KMD

                                         QQ(I,J)=Q(NSP1,J,I)
                                230 CONTINUE
                        210 CONTINUE

                           CALL  MULPLY ( CXY,QQ,ZZ,ID,ID,KMD )
                           CALL  MATADL ( Z,ZZ,ID,KMD )
              300 CONTINUE

                  DO 351 I=1,ID
 !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                       
                         DO 349   J=1,ID

                             CXV1(MSP1,I,J)=CXY1(MSP1,I,J)
                     349 CONTINUE
                         DO 350   J=IDP1,K
                                 JMD = J - ID

                                CXV1(MSP1,I,J) = Z(I,JMD)
                     350 CONTINUE
               351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE  SUBIDR ( NH,IDD,IR,IJ,IK,K,ID,IAW )
        implicit none
!C     CONSTRUCTION OF CHARACTERISTIC VECTORS

          INTEGER(4), dimension(K)  :: NH, IDD, IR 
          INTEGER(4), dimension(ID) :: IJ, IK 
          INTEGER(4) :: K, ID, IAW
          ! Locals
          INTEGER(4) :: IFP,I,IDH,LR,J
          IAW = 0
          IFP = 0
          DO 100 I=1,K
                  IDH = NH(I) + ID
                  IF( NH(K) .LT. IDH )   GO TO 111
                  LR=0
                  J=I+1
              130 LR=LR+1
                  IF(NH(J).LT.IDH) GO TO 110
                  IF(NH(J).GT.IDH) GO TO 120
                  IDD(I)=0
                  IR(I)=I+LR
                  GO TO 100
              120 IR(I) = I+ LR - 1
                  GO TO 113
              110 J=J+1
                  GO TO 130
              111 IR(I) = K
              113 IDD(I) = 1

                  IFP = IFP + 1
                  IJ(IFP) = I
                  IK(IFP) = IR(I)
                  IAW = IAW + IR(I)
      100 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SUBA(A,AW,IJ,IK,K,ID,IAW)
          implicit none
!C     CONSTRUCTION OF A FROM AW

          INTEGER(4), dimension(ID) :: IJ, IK 
          INTEGER(4) :: K, ID, IAW
          REAL(8), dimension(K,K) :: A 
          REAL(8), dimension(IAW) ::  AW
          ! Locals
          INTEGER(4) :: IKSJ,KS,JL,J,IJK

          IKSJ=0
          DO 300 KS=1,ID
                 JL=IK(KS)
                 DO 310 J=1,JL

                       IKSJ=IKSJ+1
                       IJK=IJ(KS)

                       A(IJK,J)=AW(IKSJ)
            310 CONTINUE

      300 CONTINUE
          IAW=IKSJ
    END SUBROUTINE
    
    SUBROUTINE SUBAWZ(AW,IAW,IDD,IR,Z,ZP,K,IC)
          implicit none
!C     ZP=A*Z

          INTEGER(4) :: IAW, K, IC
          INTEGER(4), dimension(K) :: IDD,IR
          REAL(8), dimension(IAW) :: AW 
          REAL(8), dimension(K,IC) :: Z, ZP
          ! Locals
          INTEGER(4) :: NI,I,JJ,IRI,NI0,NI0J
          REAL(8)    :: CST0, SUM
          CST0=0.0_8
          NI=0
          DO 400 I=1,K
                IF(IDD(I).NE.0) GO TO 410
                IRI=IR(I)
                DO 420 JJ=1,IC

                      ZP(I,JJ)=Z(IRI,JJ)
            420 CONTINUE
                GO TO 400
            410 NI0=NI
                NI=NI+IR(I)
                IRI=IR(I)
                DO 430 JJ=1,IC
                       SUM=CST0
                       DO 440 J=1,IRI
                              NI0J=NI0+J

                              SUM=SUM+AW(NI0J)*Z(J,JJ)
                   440 CONTINUE

                       ZP(I,JJ)=SUM
            430 CONTINUE
      400 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SUBCM(M,K,ID,O,CM1)
          implicit none
!C     THIS SUBROUTINE COMPUTES CM1(MS).

          INTEGER(4) :: M, K, ID
          REAL(8), dimension(50,ID,K) :: O 
          REAL(8), dimension(50,K,K) ::  CM1
          ! Locals
          INTEGER(4) :: MP1,MSP1,NSL,MNSP1,I,J
          REAL(8) :: CST0
          REAL(8), dimension(K,ID) ::  OO 
          REAL(8), dimension(ID,K) ::  XX 
          REAL(8), dimension(K,K)  ::  Z,ZZ 
!DIR$ ATTRIBUTES ALIGN : 64 :: OO,XX,Z,ZZ
!C
!C
!C     CM1(MS) COMPUTATION
!C
          CST0=0.0_8
          MP1=M+1
          DO 200 MSP1=1,MP1
                MS=MSP1-1

                Z(1:K,1:K)=CST0
                NSL=M-MS+1
                DO 300 NSP1=1,NSL
                       MNSP1=MS+NSP1

                      DO 221 I=1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                           DO 220 J=1,ID
                                 OO(I,J)=O(NSP1,J,I)

                                 XX(J,I) = CM1(MNSP1,J,I)
                       220 CONTINUE
                  221 CONTINUE

                      CALL MULPLY(OO,XX,ZZ,K,ID,K)
                      CALL MATADL(Z,ZZ,K,K)
            300 CONTINUE

                DO 351 I=1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                    
                    DO 350 J=1,K

                          CM1(MSP1,I,J)=Z(I,J)
                350 CONTINUE
           351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SUBHES(CYY1,IJ,IK,HS,M,L,K,ID,IAW,MJ3,MJ4,O,Q,CM1,X2,  &
         CXY1,CXX1,CXV1)
          use omp_lib
          implicit none
!C     THIS SUBROUTINE COMPUTES HESSIAN.

          INTEGER(4), dimension(ID) :: IJ, IK 
          INTEGER(4) ::  M, L, K, ID, IAW, MJ3, MJ4
          REAL(8), dimension(MJ3,ID,ID)  :: CYY1 
          REAL(8), dimension(MJ4,MJ4)    :: HS 
          REAL(8), dimension(50,ID,K)    :: O 
          REAL(8), dimension(50,K,ID)    :: Q 
          REAL(8), dimension(50,K,K)     :: CM1  
          REAL(8), dimension(50,ID,ID)   :: X2 
          REAL(8), dimension(100,ID,ID)  :: CXY1
          REAL(8), dimension(51,ID,ID)   :: CXX1 
          REAL(8), dimension(51,ID,K)    :: CXV1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CYY1:64,HS:64,O:64,Q:64,CM1:64,X2:64,CXY1:64,CXX1:64,CXV1:64
#endif
          ! Locals
          INTEGER(4) :: MP1,IDP1,JJ,I,I2,JJ2,MSP1,IKSJ,JL,KS,MSP2, &
                           IKSJ2,IJK2,JL2,KS2
          REAL(8) ::  CST2, SUMBB, SUMAB, SUMAA
           
          REAL(8), dimension(50,K,K)   :: CVV1 
          REAL(8), dimension(51,ID,K)  :: CXV2 
          REAL(8), dimension(50,ID,ID) :: CXY2 
!DIR$ ATTRIBUTES ALIGN : 64 :: CVV1,VXV2,CXY2

          CST2=2.0_8
!C     CXY2(MS) MS=0,M-1 COMPUTATION

          CALL SBCXY2(CYY1,MJ3,M,L,ID,X2,CXY2)
!C     CXV2(MS) MS=0,M-1 COMPUTATION

          CALL HCXV2(M,L,K,ID,Q,CXY1,CXY2,CXV2)
!C     CM1(MS) MS=0,M COMPUTATION

          CALL SUBCM(M,K,ID,O,CM1)
!C     HESSIAN COMPUTATION
!C     HBB COMPUTATION
          MP1=M+1
          IDP1=ID+1
          JJ=IAW

          DO 461 I=IDP1,K
                 DO 460 J=1,ID
                         JJ=JJ+1
                         JJ2=IAW

                         DO 1461 I2=IDP1,I
                               DO 1460 J2=1,ID
                                       JJ2=JJ2+1
                                       SUMBB=CM1(1,I,I2)*CXX1(1,J,J2)
#if defined __ICC
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUMBB)
#elif defined __GFORTRAN__
!$OMP SIMD REDUCTION(+:SUMBB)
#endif                                    
                                       DO 490 MSP1=2,MP1

                                               SUMBB=SUMBB+CM1(MSP1,I,I2)*CXX1(MSP1,J,J2)+CM1(MSP1,I2,I)*CXX1(MSP1,J2,J)
   
                                  490 CONTINUE
                                      HS(JJ,JJ2)=CST2*SUMBB
                                      HS(JJ2,JJ)=HS(JJ,JJ2)
                         1460 CONTINUE
                 1461 CONTINUE
           460 CONTINUE
      461 CONTINUE

!C     HAB COMPUTATION
          IKSJ = 0
          DO 800 KS=1,ID
                JL=IK(KS)
                DO 810 J=1,JL
                      IKSJ = IKSJ + 1
                      IJK=IJ(KS)
                      JJ2=IAW

                      DO 861 I2=IDP1,K
                             DO 860 J2=1,ID
                                    JJ2=JJ2+1
                                    SUMAB=CM1(1,IJK,I2)*CXV1(2,J2,J)
#if defined __ICC
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUMAB)
#elif defined __GFORTRAN__
!$OMP SIMD REDUCTION(+:SUMAB)
#endif                                       
                                    DO 870 MS=1,M
                                           MSP1=MS+1
                                           MSP2=MSP1+1
                                           SUMAB=SUMAB+CM1(MSP1,IJK,I2)*CXV2(MS,J2,J)+CM1(MSP1,I2,IJK)*CXV1(MSP2,J2,J)
    
                                870 CONTINUE
                                    HS(IKSJ,JJ2)=CST2*SUMAB
                                    HS(JJ2,IKSJ)=HS(IKSJ,JJ2)
                         860 CONTINUE
                861 CONTINUE
             810 CONTINUE
      800 CONTINUE

!C     CYV1,CYV2 COMPUTATION

          CALL SBCYV1(CYY1,MJ3,M,L,K,ID,Q,CXV1)
          CALL SBCYV2(CYY1,MJ3,L,K,ID,Q,CXV2)
!C     CVV1 COMPUTATION

          CALL SUBCVV(M,L,K,ID,Q,CXV1,CVV1,CXV2)

!C     HAA COMPUTATION
          IKSJ = 0

          DO 311 KS=1,ID
                 JL=IK(KS)
                 DO 310 J=1,JL
                        IKSJ = IKSJ + 1
                        IJK=IJ(KS)
                        IKSJ2 = 0

                        DO 1311 KS2=1,KS
                                JL2=IK(KS2)
                                DO 1310 J2=1,JL2
                                           IKSJ2=IKSJ2+1
                                           IJK2=IJ(KS2)
                                           SUMAA=CM1(1,IJK,IJK2)*CVV1(1,J,J2)
#if defined __ICC
!DIR$ VECTOR ALIGNED
!DIR$ SIMD REDUCTION(+:SUMAA)
#elif defined __GFORTRAN__
!$OMP SIMD REDUCTION(+:SUMAA)
#endif                                              
                                           DO 440 MSP1=2,MP1

                                                SUMAA=SUMAA+CM1(MSP1,IJK,IJK2)*CVV1(MSP1,J,J2)+CM1(MSP1,IJK2,IJK)*  &
                                                ACVV1(MSP1,J2,J)
                                      440 CONTINUE
                                          HS(IKSJ,IKSJ2)=CST2*SUMAA
                                          HS(IKSJ2,IKSJ)=HS(IKSJ,IKSJ2)
                            1310 CONTINUE
                    1311 CONTINUE
              310 CONTINUE
      311 CONTINUE
    END SUBROUTINE
                      
    SUBROUTINE SUBCVV(M,L,K,ID,Q,CYV1,CVV1,CYV2)
          use omp_lib
          implicit none
!C     THIS SUBROUTINE COMPUTES CVV1(MS) MS=0,M.
!C     CVV1(MS)=Q(0)*CYV(MS)+Q(1)*CYV(MS-1)+...+Q(L)*CYV(MS-L)

          INTEGER(4) :: M, L, K, ID
          REAL(8), dimension(50,K,ID) :: Q 
          REAL(8), dimension(51,ID,K) :: CYV1 
          REAL(8), dimension(50,K,K)  :: CVV1 
          REAL(8), dimension(51,ID,K) :: CYV2
#if defined __ICC
          !DIR$ ASSUME_ALIGNED Q:64,CYV1:64,CVV1:64,CYV2:64
#endif
          ! Locals
          INTEGER(4) ::    MP1,I,J,MSP1,LP1,KMD,IDP1,ML,LSP1,ML,IMD
          REAL(8)    ::    CST0, CST1
          REAL(8), dimension(K-ID,ID) :: QQ, Z, ZZ
          REAL(8), dimension(ID,K) :: CXV     
!DIR$ ATTRIBUTES ALIGN : 64 :: QQ,Z,ZZ,CXV
          CST0=0.0_8
          CST1=1.0_8
!C     CVV1(MS) COMPUTATION
          MP1=M+1
          LP1=L+1
          IDP1 = ID + 1
          KMD = K - ID
          DO 200 MSP1=1,MP1

                 Z(1:KMD,1:K)=CST0
                 DO 300 LSP1=1,LP1

                    DO 211 I=1,KMD
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif
                              DO 210 J=1,ID

                                    QQ(I,J)=Q(LSP1,I,J)
                          210 CONTINUE
                   211 CONTINUE
                       ML=MSP1-LSP1
                       IF(ML.LT.0) GO TO 319

                       DO 321 I=1,ID
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif                          
                              DO 320 J=1,K

                                   CXV(I,J)=CYV1(ML+1,I,J)
                          320 CONTINUE
                   321 CONTINUE
                       GO TO 340
                   319 ML=-ML

                       DO 331 I=1,ID
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif                          
                              DO 330 J=1,K

                                    CXV(I,J)=CYV2(ML+1,I,J)
                          330 CONTINUE
                   331 CONTINUE

                   340 CALL  MULPLY ( QQ,CXV,ZZ,KMD,ID,K )
                       CALL  MATADL ( Z,ZZ,KMD,K )
             300 CONTINUE
                 DO 349   I=1,ID
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif
                          DO 348   J=1,K

                                  CVV1(MSP1,I,J)=CYV1(MSP1,I,J)
                      348 CONTINUE
            349 CONTINUE

                    DO 351   I=IDP1,K
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif                                     
                        DO 350   J=1,K
                                IMD = I - ID

                                CVV1(MSP1,I,J) = Z(IMD,J)
                    350 CONTINUE
           351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SBCYV1(CYY1,MJ3,M,L,K,ID,Q,CYV1)
          use omp_lib
          implicit none
!C     THIS SUBROUTINE COMPUTES CYV1(MS) (MS=0,M).
!C     CYV1(MS)=CYY1(MS)*Q(0)'+CYY1(MS+1)*Q(1)'+CYY1(MS+2)*Q(2)'+...
!C     -CYY1(MS+L)*Q(L)'.

          INTEGER(4) :: MJ3, M, L, K, ID
          REAL(8), dimension(MJ3,ID,ID) :: CYY1 
          REAL(8), dimension(50,K,ID)   :: Q 
          REAL(8), dimension(51,ID,K)   :: CYV1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CYY1:64,Q:64.CYV1:64
#endif
          ! Locals
          INTEGER(4) :: MP1,LP1,I,J,KMD,MSP1,LSP1,ML,JMD,IDP1
          REAL(8) :: CST0
          REAL(8), dimension(ID,K-ID) :: QQ 
          REAL(8), dimension(ID,ID)   :: CYY 
          REAL(8), dimension(ID,K-ID) ::  Z, ZZ
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: QQ,CYY,Z,ZZ
#endif
          CST0=0.0_8
          MP1=M+1
          LP1=L+1
          IDP1 = ID + 1
          KMD = K - ID
          DO 200 MSP1=1,MP1

                  Z(1:ID,1:KMD)=CST0
                  DO 300 LSP1=1,LP1
                             ML=MSP1+LSP1-1

                             DO 211 I=1,ID
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif                                
                                 DO 210 J=1,ID

                                       CYY(I,J)=CYY1(ML,I,J)
                             210 CONTINUE
                        211 CONTINUE

                            DO 221 I=1,ID
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif
                                 DO 220 J=1,KMD

                                        QQ(I,J)=Q(LSP1,J,I)
                             220 CONTINUE
                       221 CONTINUE

                           CALL  MULPLY ( CYY,QQ,ZZ,ID,ID,KMD )
                           CALL  MATADL ( Z,ZZ,ID,KMD )
              300 CONTINUE

                  DO 351 I=1,ID
                       DO 349 J=1,ID

                              CYV1(MSP1,I,J)=CYY1(MSP1,I,J)
349                           CONTINUE
#if defined __ICC
                       !DIR$ VECTOR ALIGNED
                       !DIR$ VECTOR ALWAYS
#elif defined __GFORTRAN__
                       !$OMP SIMD
#endif                              
                       DO 350 J=IDP1,K
                              JMD = J - ID

                              CYV1(MSP1,I,J)=Z(I,JMD)
                  350 CONTINUE
             351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SBCYV2(CYY1,MJ3,L,K,ID,Q,CYV2)
          use omp_lib
          implicit none
!C     THIS SUBROUTINE COMPUTES CYV2(MS) (MS=-L,0).
!C     CYV2(MS)=CYV1(-MS)
!C     =CYY1(-MS)*Q(0)'+CYY1(-MS+1)*Q(1)'+CYY1(-MS+2)*Q(2)'+...
!C     +CYY1(-MS+L)*Q(L)'.

         INTEGER(4) :: MJ3, L, K, ID
         REAL(8), dimension(MJ3,ID,ID) :: CYY1 
         REAL(8), dimension(50,K,ID)   :: Q 
         REAL(8), dimension(51,ID,K)   :: CYV2
#if defined __ICC
         !DIR$ ASSUME_ALIGNED CYY1:64,Q:64,CYV2:64
#endif
         ! Locals
         INTEGER(4) :: LP1,IDP1,KMD,MSP1,LSP1,I,J,MJ,ML,JMD
         REAL(8)    :: CST0
         REAL(8), dimension(ID,K-ID) :: QQ,Z, ZZ
         REAL(8), dimension(ID,ID)   :: CYY
#if defined __ICC
         !DIR$ ATTRIBUTES ALIGN : 64 :: QQ,Z,ZZ,CYY
#endif
         CST0=0.0_8
         LP1=L+1
         IDP1 = ID + 1
         KMD = K - ID
         DO 200 MSP1=1,LP1

                   Z(1:ID,1:KMD)=CST0
                   DO 300 LSP1=1,LP1

                      DO 211 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif
                              DO 210 J=1,KMD

                                    QQ(I,J)=Q(LSP1,J,I)
                         210 CONTINUE
                     211 CONTINUE
                         ML=LSP1-MSP1
                         IF(ML.LT.0) GO TO 319

                         DO 321 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                            
                              DO 320 J=1,ID

                                    CYY(I,J)=CYY1(ML+1,I,J)
                          320 CONTINUE
                    321 CONTINUE
                        GO TO 340
                    319 ML=-ML

                        DO 331 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                           
                              DO 330 J=1,ID

                                    CYY(I,J)=CYY1(ML+1,J,I)
                          330 CONTINUE
                   331 CONTINUE

                   340 CALL  MULPLY ( CYY,QQ,ZZ,ID,ID,KMD )
                       CALL  MATADL ( Z,ZZ,ID,KMD )
            300 CONTINUE

                       DO 351 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif
                        DO 349 J=1,ID

                               CYV2(MSP1,I,J)=CYY1(MSP1,J,I)
                    349 CONTINUE
                        DO 350 J=IDP1,K
                                JMD = J - ID

                                CYV2(MSP1,I,J)=Z(I,JMD)
                   350 CONTINUE
          351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE HCXV2(M,L,K,ID,Q,CXY1,CXY2,CXV2)
          use omp_lib 
          implicit none
!C     THIS SUBROUTINE COMPUTES CXV2(MS) MS=0,M-1.
!C     CXV2(MS)=CXV1(-MS)
!C     =CXY1(-MS)*Q(0)'+CXY1(-MS+1)*Q(1)'+...+CXY1(-MS+L)*Q(L)'

         INTEGER(4) :: M, L, K, ID
         REAL(8), dimension(50,K,ID)   ::  Q 
         REAL(8), dimension(100,ID,ID) ::  CXY1 
         REAL(8), dimension(50,ID,ID)  ::  CXY2
         REAL(8), dimension(51,ID,K)   ::  CXV2
#if defined __ICC
         !DIR$ ASSUME_ALIGNED Q:64,CXY1:64,CXY2:64,CXV2:64
#endif
         ! Locals
         INTEGER(4) :: LP1,IDP1,KMD,I,J,MSP1,LSP1,ML,JMD
         REAL(8)    :: CST0
         REAL(8), dimension(ID,K-ID) :: QQ,Z, ZZ
         REAL(8), dimension(ID,ID)   :: CXY
#if defined __ICC
         !DIR$    ATTRIBUTES ALIGN : 64 :: QQ,Z,ZZ,CXY
#endif
         CST0=0.0_8
         LP1=L+1
         IDP1 = ID + 1
         KMD = K - ID
         DO 200 MSP1=1,M

               Z(1:ID,1:KMD)=CST0
               DO 300 LSP1=1,LP1

                  DO 211 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                     
                            DO 210 J=1,KMD

                                  QQ(I,J)=Q(LSP1,J,I)
                        210 CONTINUE
                 211 CONTINUE
                     ML=LSP1-MSP1
                     IF(ML.LT.0) GO TO 319

                     DO 321 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                        
                           DO 320 J=1,ID

                                 CXY(I,J)=CXY1(ML+1,I,J)
                       320 CONTINUE
               321 CONTINUE
                   GO TO 340
               319 ML=-ML

                   DO 331 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                      
                         DO 330 J=1,ID

                               CXY(I,J)=CXY2(ML+1,I,J)
                     330 CONTINUE
               331 CONTINUE

               340 CALL MULPLY ( CXY,QQ,ZZ,ID,ID,KMD )
                   CALL  MATADL ( Z,ZZ,ID,KMD )
          300 CONTINUE

                   DO 351 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                      
                    DO 349 J=1,ID

                          CXV2(MSP1,I,J)=CXY2(MSP1,I,J)
                349 CONTINUE
                    DO 350 J=IDP1,K
                           JMD = J - ID

                           CXV2(MSP1,I,J) = Z(I,JMD)
                350 CONTINUE
          351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SBCXY2(CYY1,MJ3,M,L,ID,X2,CXY2)
          use omp_lib
          implicit  none
!C     THIS SUBROUTINE COMPUTES CXY2(LS) LS=0,M-1.
!C     CXY2(LS)=CXY1(-LS)
!C     =X2(0)*CYY1(-LS)+X2(1)*CYY1(-LS-1)+X2(2)*CYY1(-LS-2)+...
!C     +X2(L)*CYY1(-LS-L).

          INTEGER(4) :: MJ3, M, L, ID
          REAL(8), dimension(MJ3,ID,ID) :: CYY1 
          REAL(8), dimension(50,ID,ID)  :: X2, CXY2
#if defined __ICC
          !DIR$ ASSUME_ALIGNED CYY1:64,X2:64,CXY2:64
#endif
          ! Locals
          INTEGER(4) :: LP1,I,J,ML,LSP1,MSP1
          REAL(8) :: CST0
          REAL(8), dimension(ID,ID) :: XX, CYY, Z, ZZ
!DIR$ ATTRIBUTES ALIGN : 64 :: XX,CYY,Z,ZZ
          CST0=0.0_8
          LP1=L+1
          DO 200 LSP1=1,M

                     Z(1:ID,1:ID)=CST0
                     DO 300 MSP1=1,LP1

                        DO 311 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                              
                                   DO 310 J=1,ID

                                         XX(I,J)=X2(MSP1,I,J)
                                310 CONTINUE
                       311 CONTINUE
                           ML=LSP1+MSP1-1

                           DO 321 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                                 
                                 DO 320 J=1,ID

                                       CYY(I,J)=CYY1(ML,J,I)
                             320 CONTINUE
                      321 CONTINUE

                          CALL MULPLY(XX,CYY,ZZ,ID,ID,ID)
                          CALL MATADL(Z,ZZ,ID,ID)
             300 CONTINUE

                      DO 351 I=1,ID
#if defined __ICC
!DIR$ VECTOR ALWAYS
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                                
                         DO 350 J=1,ID

                              CXY2(LSP1,I,J)=Z(I,J)
                     350 CONTINUE
             351 CONTINUE
      200 CONTINUE
    END SUBROUTINE
    
      SUBROUTINE SUBDAV(CYY1,MJ3,B,AW,IAW,NH,IDD,IR,IJ,IK,VD,X,C0,G,R,    &
           N,K,ID,IPQ,AICD,MJ4,ISWRO,O,Q,X1,X2,CXY1,CXX1,CXV1)
          use omp_lib
          implicit none
!C     DAVIDON'S (MINIMIZATION) PROCEDURE

      
     

          INTEGER(4) :: MJ3, IAW,  N, K, ID, IPQ, MJ4, ISWRO
       
          INTEGER(4), dimension(ID) :: IJ,IK
          INTEGER(4), dimension(K) :: NH,IDD,IR
          REAL(8), dimension(MJ3,ID,ID) :: CYY1 
          REAL(8), dimension(K,ID)      ::  B 
          REAL(8), dimension(IAW)       ::  AW 
          REAL(8), dimension(MJ4,MJ4)   ::  VD
          REAL(8), dimension(MJ4)       ::  X,  G, R
          REAL(8), dimension(ID,ID)     ::  C0
          REAL(8), dimension(50,ID,K)   ::  O 
          REAL(8), dimension(50,K,ID)   ::  Q 
          REAL(8), dimension(50,K,K)    ::  X1 
          REAL(8), dimension(50,ID,ID)  ::  X2
          REAL(8), dimension(100,ID,ID) ::  CXY1 
          REAL(8), dimension(51,ID,ID)  ::  CXX1 
          REAL(8), dimension(51,ID,K)   ::  CXV1
#if defined __ICC
          !DIR$ ASSUME_ALIGNED IJ:64,IK:64,NH:64,IDD:64,IR:64
          !DIR$ ASSUME_ALIGNED CYY1:64,B:64,AW:64,VD:64
          !DIR$ ASSUME_ALIGNED X:64,G:64,R:64,C0:64,O:64
          !DIR$ ASSUME_ALIGNED Q:64,X1:64,X2:64,CXY1:64,CXX1:64,CXV1:64
#endif
          REAL(8) :: AICD
          ! Locals
          INTEGER(4) :: ITN,ISPHAI,IPHAT,ITNS,I,J,IG,IRAM,ITN
          REAL(8)    ::  CST0, CST1, CST2, CST01, CST05,                       &
                            CONSTA, CONSTB, EPS1, EPS3, EPS4, EPS5, AIPQ,         &
                            AN, PHAID, RO, PHAI, EPHAI1, T1, RAM, RAMRO,          &
                            RAMROT, SUM, SRO, SROD, DGAM, GSR, DGAM1, RAMSRO,     &
                            RAMT, SPHAI, RAM1, CONSDR, OPHAI, AICS, DAIC,AICO
          REAL(8), dimension(ID,ID) :: C0D, SC0, SC0D
          REAL(8), dimension(MJ4)   :: SR, SX, SG
#if defined __ICC
          !DIR$N ATTRIBUTES ALIGN : 64 :: C0D,SC0,SC0D,SR,SX,SG
#endif
          COMMON /COM101/AICO           
!C
!C
!C     DAVIDON'S PROCEDURE
!C
!C     CONSTANT
          CST1=1.0_8
          CST0=0.0_8
          CST2=2.0_8
          CST01=0.1_8
          CST05=0.5_8
          CONSTA=0.5_8
          CONSTB=2.0_8
          EPS1=0.01_8
          EPS3=0.000001_8
          EPS4=0.0000000001_8
          EPS5=1.0E-15_8
          ITN=1
          ISPHAI=0
          IPHAI=1
          AIPQ=IPQ
          AN=N
          PHAID=CST1

     150 CONTINUE
!C
!C     RO=G'*R COMPUTATION
          ITNS=0
       40 CALL INNERP(G,R,RO,IPQ)

          IF(IPHAI.EQ.0) GO TO 101
!C     DETERMINANT OF CXX(0) COMPUTATION

          DO 102 I=1,ID
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif
                 DO 100 J=1,ID

                        C0D(I,J)=C0(I,J)
             100 CONTINUE
      102 CONTINUE

          CALL SUBDETM(C0D,PHAI,ID)
          PHAID=PHAI
      101 OPHAI=PHAI
          EPHAI1=EPS1*PHAI
          T1=RO-CST2*PHAI
          IF(T1.LE.EPHAI1) GO TO 140
!C
          RAM=CST2*PHAI/RO

          RAMRO=(RAM-CST1)/RO

          DO 111 I=1,IPQ
             RAMROT=RAMRO*R(I)
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif             
                 DO 110 J=1,IPQ

                      VD(I,J)=VD(I,J)+RAMROT*R(J)
             110 CONTINUE
      111 CONTINUE
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif
          DO 120 I=1,IPQ

                  R(I)=RAM*R(I)
      120 CONTINUE
          IF(ITNS.GE.10) GO TO 140
          ITNS=ITNS+1
          GO TO 40

      140 CONTINUE
          IG=0
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif          
      205 DO 210 I=1,IPQ

                 SX(I)=X(I)-R(I)
      210 CONTINUE

          CALL C0GR(CYY1,MJ3,B,AW,IAW,NH,IDD,IR,IJ,IK,SX,SC0,SG,M,L,K,ID,  &
                MJ4,IG,O,Q,X1,X2,CXY1,CXX1,CXV1)
         
          IF(IG.EQ.0) GO TO 215

          DO 214 I=1,IPQ
             R(I)=CST05*R(I)
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif             
                 DO 213 J=1,IPQ

                        VD(I,J)=CST05*VD(I,J)
            213 CONTINUE
      214 CONTINUE
          GO TO 205
!C
!C     DETERMINANT OF (NEW CXX(0)) COMPUTATION

215       DO 221 I=1,ID
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif
               DO 220 J=1,ID

                        SC0D(I,J)=SC0(I,J)
           220 CONTINUE
      221 CONTINUE

          CALL SUBDETM(SC0D,SPHAI,ID)

          DO 310 I=1,IPQ
             SUM=CST0
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ SIMD REDUCTION(+:SUM)
#elif defined  __GFORTRAN__
             !$OMP SIMD REDUCTION(+:SUM)
#endif             
                DO 311 J=1,IPQ

                      SUM=SUM+VD(I,J)*SG(J)
            311 CONTINUE

                SR(I)=SUM
      310 CONTINUE

          CALL INNERP(SG,SR,SRO,IPQ)
          SROD=SRO/PHAI

          CALL INNERP(G,SR,GSR,IPQ)
          DGAM=-GSR/SRO
          DGAM1=DGAM+CST1
          DGAM1=DABS(DGAM1)+0.1D-70
          RAM=DABS(DGAM)/DGAM1
!C     IF(RAM.LE.CONSTA) RAM=CONSTA
          IF(RAM.GT.CONSTA) GO TO 430
          RAM=CONSTA
          IRAM=1

          GO TO 470

      430 IF(RAM.LT.CONSTB) GO TO 450
          RAM=CONSTB
          IRAM=-1

          GO TO 470

      450 CONTINUE
          IRAM=0

      470 RAMSRO=(RAM-CST1)/SRO

          DO 481 I=1,IPQ
             RAMT=RAMSRO*SR(I)
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif             
                 DO 480 J=1,IPQ

                       VD(I,J)=VD(I,J)+RAMT*SR(J)
             480 CONTINUE
      481 CONTINUE

          IF(PHAI.GT.SPHAI) GO TO 540

          RAM1=RAM-CST1
          IF(DABS(RAM1).LT.EPS3) GO TO 555
          CONSDR=DGAM*RAM1
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif          
          DO 550 I=1,IPQ

                R(I)=R(I)-CONSDR*SR(I)
      550 CONTINUE
          IPHAI=0
          IF(SROD.GT.EPS4) GO TO 900

      555 ISWRO=ISWRO+1
          GO TO 1000
!C
!C     SPHAI.LT.PHAI: SUCCESSFUL REDUCTION
      540 DO 560 I=1,IPQ
              X(I)=SX(I)
              G(I)=SG(I)

              R(I)=RAM*SR(I)
      560 CONTINUE

              DO 571 I=1,ID
#if defined __ICC
             !DIR$ VECTOR ALIGNED
             !DIR$ VECTOR ALWAYS
#elif defined  __GFORTRAN__
             !$OMP SIMD
#endif                 
                 DO 570 J=1,ID

                       C0(I,J)=SC0(I,J)
             570 CONTINUE
      571 CONTINUE
          PHAI=SPHAI
          IPHAI=1

          AICO=AN*DLOG(OPHAI)+CST2*AIPQ
          AICS=AN*DLOG(SPHAI)+CST2*AIPQ
          PHAID=SPHAI
          AICD=AICS
          DAIC=AICO-AICS

         IF(IRAM.NE.0) GO TO 901
         IF(SROD.LT.EPS4) GO TO 555
!C     ITERATION CHECK
     900 IPQ2=IPQ+IPQ
         IF(ITN.GE.IPQ2) GO TO 555
         ISPHAI=(ISPHAI+(1-IPHAI))*(1-IPHAI)
         IF(ISPHAI.GE.5) GO TO 555
         ITN=ITN+1
         GO TO 150
     901 IF(DAIC.GE.CST01) GO TO 900
         IF(SROD.LT.EPS4) GO TO 555
         GO TO 900
!C     END OF MINIMIZATION

         ISWRO=0

    1000 CONTINUE
         AICD=AN*DLOG(PHAID)+CST2*AIPQ
    END SUBROUTINE

    SUBROUTINE ARMACO(B,AW,IAW,IH,IDD,IR,IK,ID,ICONT,K,BBM,    &
                       AAU,ZZ,IQM,MJ6,MJ7)
          implicit none
!C     AR-MA COEFFICIENTS COMPUTATION

          INTEGER(4) :: IAW,  ID, ICONT,K, IQM, MJ6, MJ7
          INTEGER(4), dimension(K) :: IH,IDD,IR
          INTEGER(4), dimension(ID) :: IK
         
          REAL(8), dimension(K,ID)      :: B 
          REAL(8), dimension(IAW)       :: AW 
          REAL(8), dimension(ID,ID,MJ6) :: BBM
          REAL(8), dimension(ID,ID,MJ7) :: AAU, ZZ
          ! Locals
          INTEGER(4) :: I,J,IQMAX,IQ,ISUM,IRS,IKI,JO,IDL,JA,JB,IQM1, &
                           IQD,JDQ,IRD,ISR,ISRD,IMAJ,NS,JMA,JW,JB1,JWJ, &
                           JBJ,ITM1,JTBJ,JTWJ,IDL1,IDL
          REAL(8) :: CST0, CST1, BDET
          INTEGER(4), dimension(K)     :: IO
          REAL(8), dimension(ID,MJ6)   :: BA,BM
          REAL(8), dimension(ID,ID)    :: B0 
          REAL(8), dimension(K,ID)     :: U 
          REAL(8), dimension(K,ID,MJ7) ::  AU 
          REAL(8), dimension(ID,ID)    :: W0, Z
!DIR$ ATTRIBUTES ALIGN : 64 :: IO,BA,BM,B0,U,AU,W0,Z
!C     BA COMPUTATION
!C     ORDER DETERMINATION
          CST0=0.0_8
          CST1=1.0_8
          IQMAX=0
          DO 100 I=1,K
                IQ=(IH(I)-1)/ID+1
                IO(I)=IQ
                IF(IO(I).LE.IQMAX)      GO TO 100
                IQMAX=IQ
    100   CONTINUE
!C
!C     TRANSFORMATION OF AW(F MATRIX IN VECTOR FORM) INTO THE MATRICES OF
!C     THE RAW AR-COEFFICIENTS.
!C

          BA(1:ID,1:MJ6)=CST0
          ISUM=0
          IRS=0
          DO 201 I=1,K
                IF(IDD(I).EQ.0) GO TO 201
                IRS=IRS+1
                IKI=IK(IRS)
                JO=IH(I)-(IO(I)-1)*ID
                IDL=(IQMAX-IO(I))*ID
                IDL1=IDL+ID
                JA=IH(I)+IDL1
                BA(JO,JA)=-CST1

                DO 200 J=1,IKI
                       ISUM=ISUM+1
                       JB=IH(J)+IDL
                       BA(JO,JB)=AW(ISUM)
          200   CONTINUE
      201 CONTINUE

          IQMAX=IQMAX+1
          IQM=IQMAX-1
          IQM1=IQM-1

          IQD=IQM*ID

          DO 301 I=1,ID
                DO 300 J=1,ID
                        JDQ=IQD+J

                        B0(I,J)=-BA(I,JDQ)
           300 CONTINUE
      301 CONTINUE

          CALL INVDET(B0,BDET,ID,ID)
          CALL MULPLY(B0,BA,BM,ID,ID,IQD)

          DO 322 I=1,ID
                 DO 321 J=1,IQD

                        BM(I,J)=-BM(I,J)
             321 CONTINUE
      322 CONTINUE
          DO 320 IRS=1,IQM

                 ISR=IQM-IRS
                 ISRD=ISR*ID+1
                 IRD=ISRD+ID-1

                 DO 311 I=1,ID
                      DO 310 J=1,ID
                            BBM(I,J,IRS) = BM(I,ISRD+J-1)
                   310 CONTINUE
             311 CONTINUE
      320   CONTINUE
!C     IMPULSE RESPONSE MATRICES OUTPUT

            DO 401 I=1,K
                   DO 400 J=1,ID

                        U(I,J)=B(I,J)
               400 CONTINUE
        401 CONTINUE
            IQM1=IQM-1
            IMAJ=-ID
            DO 490 NS=1,IQM1

                   IMAJ=IMAJ+ID

                   CALL SUBAWZ(AW,IAW,IDD,IR,U,AU(1,1,NS),K,ID)
                   DO 470 I=1,ID
                       IF(ICONT.EQ.0) GO TO 440

                       DO 450 J=1,ID
                                AAU(I,J,NS)=AU(I,J,NS)
                   450 CONTINUE
                   440 DO 460 J=1,ID
                              JMA=IMAJ+J

                              BA(I,JMA)=AU(I,J,NS)
                    460 CONTINUE
              470 CONTINUE

                  DO 481 I=1,K
                      DO 480 J=1,ID

                             U(I,J)=AU(I,J,NS)
                  480 CONTINUE
             481 CONTINUE
      490   CONTINUE
            IF(ICONT.EQ.1) GO TO 506

           JW=-ID
           JB=IQD
           JB1=IQD
           DO 505 IT=1,IQM1
                    JW=JW+ID
                    JB=JB-ID

                   DO 510 I=1,ID
                       DO 500 J=1,ID
                              JWJ=JW+J
                              JBJ=JB+J

                              ZZ(I,J,IT)=BA(I,JWJ)+BM(I,JBJ)
                   500 CONTINUE
              510 CONTINUE
                  IF(IT.EQ.1) GO TO 503
                   ITM1=IT-1
                  JTW=JW
                  JTB=JB1
                  DO 502 JT=1,ITM1
                        JTW=JTW-ID
                        JTB=JTB-ID

                        DO 511 I=1,ID
                              DO 501 J=1,ID
                                     JTBJ=JTB+J
                                      JTWJ=JTW+J
                                     B0(I,J)=BM(I,JTBJ)

                                     W0(I,J)=BA(I,JTWJ)
                          501 CONTINUE
                   511 CONTINUE

                       CALL MULPLY(B0,W0,Z,ID,ID,ID)
                       CALL MATADL(ZZ(1,1,IT),Z,ID,ID)
               502 CONTINUE

             503 CONTINUE

      505 CONTINUE
      506 CONTINUE
    END SUBROUTINE
                       
    SUBROUTINE  RESCAL ( B,AW,IAW,NH,IDD,IR,K,ID )
          implicit none
!C     RESCALING OF F AND G MATRICES FOR A FEASIBLE INITIAL

         INTEGER(4) :: IAW,K, ID 
         INTEGER(4), dimension(K) :: NH,IDD,IR
         REAL(8), dimension(K,ID) :: B 
         REAL(8), dimension(IAW)  :: AW 
         ! Locals
         INTEGER(4) :: I,IKSJ,IM,JL,IOR,IDP1,IOI,KS
         
         REAL(8) :: RO9, SCALE
         INTEGER(4), dimension(K) :: IO

         RO9=0.95_8
         DO 10 I=1,K

                IO(I)=(NH(I)-1)/ID
      10 CONTINUE

         IKSJ = 0
         DO 20 I=1,K
                IF(IDD(I).EQ.0) GO TO 20
                IM = IO(I) + 1
                KS=KS+1
                JL = IR(I)
                DO 30 J=1,JL
                     IOR = IM - IO(J)
                     SCALE=RO9**IOR
                     IKSJ = IKSJ + 1

                    AW(IKSJ)=AW(IKSJ)*SCALE
            30 CONTINUE
       20 CONTINUE

          IDP1=ID+1
          DO 40 I=IDP1,K
                   IOI=IO(I)
                   SCALE=RO9**IOI
                   DO 50 J=1,ID

                          B(I,J) = B(I,J) * SCALE
                50 CONTINUE
      40 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE SUBDETM(X,XDETMI,MM)
          implicit none
!C     THIS SUBROUTINE COMPUTES THE DETERMINANT OF UPPER LEFT MM X MM
!C     OF X.  FOR GENERAL USE STATEMENTS 20-21 SHOULD BE RESTORED.
!C     X: ORIGINAL MATRIX
!C     XDETMI: DETERMINANT OF UPPER LEFT MM X MM OF X
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE

          INTEGER(4) :: MM
          REAL(8), dimension(MM,MM) :: X 
          REAL(8) :: XDETMI
          ! Locals
          INTEGER(4) :: MM1,I,J,JJ,K,I1
          REAL(8) :: CST0, CST1, XXC, XC
          CST0=0.0_8
          CST1=1.0_8
          XDETMI=CST1
          IF(MM.EQ.1) GO TO 18
          MM1=MM-1
          DO 10 I=1,MM1

               IF(X(I,I).NE.CST0) GO TO 11
               DO 12 J=I,MM
                     IF(X(I,J).EQ.CST0) GO TO 12
                     JJ=J
                     GO TO 13
            12 CONTINUE
               XDETMI=CST0
               GO TO 17
            13 DO 14 K=I,MM
                     XXC=X(K,JJ)
                     X(K,JJ)=X(K,I)

                     X(K,I)=XXC
            14 CONTINUE
               XDETMI=-XDETMI
            11 XDETMI=XDETMI*X(I,I)
               XC=CST1/X(I,I)
               I1=I+1
               DO 15 J=I1,MM
                    XXC=X(J,I)*XC
                    DO 16 K=I1,MM

                          X(J,K)=X(J,K)-X(I,K)*XXC
                 16 CONTINUE
            15 CONTINUE
       10 CONTINUE
       18 XDETMI=XDETMI*X(MM,MM)
   17 RETURN
    END  SUBROUTINE
    
    
    SUBROUTINE MLOCARF( ZS,N,LAG,NS0,KSW,NML,ZMEAN,SUM,A,MF,SDF,LK0,      &
                        LK2,SXX,NNF,NNS,MS,SDMS,AICS,MP,SDMP,AICP )
          implicit none

!cc      PROGRAM  MLOCAR                                                   
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C!.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.3.1.                                                    
!C     _                     ___                __                       
!C     MINIMUM AIC METHOD OF LOCALLY STATIONARY AR MODEL FITTING; SCALAR 
!C                                                                       
!C     THIS PROGRAM LOCALLY FITS AUTOREGRESSIVE MODELS TO NON-STATIONARY 
!C     SERIES BY MINIMUM AIC PROCEDURE.                                  
!C                                                                       
!C     BY THIS PROCEDURE, THE DATA OF LENGTH N ARE DIVIDED INTO J LOCALLY
!C     STATIONARY SPANS                                                  
!C                                                                       
!C                <-- N1 --> <-- N2 --> <-- N3 -->          <-- NJ -->   
!C               !----------!----------!----------! ...... !----------!  
!C                <-----------------------  N  ---------------------->   
!C                                                                       
!C     WHERE NI (I=1,...,J) DENOTES THE NUMBER OF BASIC SPANS, EACH OF   
!C     LENGTH NS, WHICH CONSTITUTE THE I-TH LOCALLY STATIONARY SPAN.     
!C     AT EACH LOCAL SPAN, THE PROCESS IS REPRESENTED BY A STATIONARY    
!C     AUTOREGRESSIVE MODEL.                                             
!C
!C
!C       --------------------------------------------------------------- 
!C       REFERENCE:                                                      
!C          G.KITAGAWA AND H.AKAIKE(1978), "A PROCEDURE FOR THE MODELING 
!C          OF NON-STATIONARY TIME SERIES.",  ANN. INST. STATIST. MATH., 
!C          30,B,351-363.                                                
!C       --------------------------------------------------------------- 
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:  
!C             REDATA                                                    
!C             NONSTA                                                    
!C             PRINTA                                                    
!C             NRASPE                                                    
!C       --------------------------------------------------------------- 
!C        INPUTS REQUIRED;                                               
!C             MT:       INPUT DEVICE FOR ORIGINAL DATA (MT=5 : CARD READ
!C             LAG:      UPPER LIMIT OF THE ORDER OF AR-MODEL, MUST BE LE
!C                       OR EQUAL TO 50.                                 
!C             NS:       LENGTH OF BASIC LOCAL SPAN                      
!C             KSW:      =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESS
!C                       =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REG
!C                                                                       
!C               -- THE FOLLOWING INPUTS ARE REQUESTED BY SUBROUTINE REDA
!C!             TITLE:    SPECIFICATION OF DATA                           
!C             N:        DATA LENGTH, MUST BE LESS THAN OR EQUAL TO 10000
!C             DFORM:    INPUT DATA SPECIFICATION STATEMENT.             
!C                       -- EXAMPLE  --     (8F10.5)                     
!C             (Z(I),I=1,N):  ORIGINAL DATA                              
!C               --------------------------------------------------------
!C

          INTEGER(4) :: N, LAG, NS0, KSW, NML
          INTEGER(4), dimension(NML) :: MF,LK0,LK2,NNF,NNS,MS,MP
          
          REAL(8), dimension(N) :: ZS 
          REAL(8) :: ZMEAN, SUM 
          REAL(8), dimension(LAG+KSW,NML) :: A 
          REAL(8), dimension(NML)     :: SDF 
          REAL(8), dimension(121,NML) :: SXX 
          REAL(8), dimension(NML)     :: SDMS, AICS, SDMP,AICP
          ! Loclas
          INTEGER(4) :: MJ1,MJ2,ISW,L,K,MX,NJ,NF,NS,LK,LK1,I,IF1
          REAL(8) :: B
          REAL(8), dimension(N)                   ::  Z 
          REAL(8), dimension(N,LAG+KSW+1)         ::  X 
          REAL(8), dimension(LAG+KSW+1,LAG+KSW+1) ::  U
          REAL(8), dimension(LAG+KSW)             ::  AA 
!DIR$ ATTRIBUTES ALIGN : 64 ::  Z,X,U,AA
!C                                                                       
!C          EXTERNAL SUBROUTINE DECLARATION                              
!C                                                                       
      !EXTERNAL  SETX1                                                   
                                                     
          MJ1 = N
          MJ2 = LAG+1                                                          
          ISW = 0                                                           

          CALL  REDATA( ZS,Z,N,ZMEAN,SUM )

          L  = 0                                                            
          K  = LAG + KSW                                                    
          MX = K * 2                                                        
          IF1 = 0                                                            
          NJ = 0
          NF = 0
          NS = NS0
!C                                                                       
      100 CONTINUE                                                          
!C                                                                       
          LK  = L + K                                                       
          LK1 = LK + 1                                                      
          IF( LK1     .GE. N  )   GO TO 200                                 
          IF( N-LK1   .LT. NS )   NS = N - LK                               
          IF( N-LK1-NS.LT. MX )   NS = N - LK                               
!C                                                                       
!C          -----------------------------------                          
!C          LOCALLY STATIONARY AR-MODEL FITTING                          
!C          -----------------------------------                          
                                                        
          NJ = NJ+1
          IF ( NJ .GT. 1 )  MF(NJ) = MF(NJ-1)
          IF ( NJ .GT. 1 )  SDF(NJ) = SDF(NJ-1)
          CALL  NONSTA( SETX1,Z,X,U,LAG,L,NF,NS,K,IF1,ISW,MJ1,MJ2,AA,MF(NJ), &
          SDF(NJ),NNF(NJ),NNS(NJ),MS(NJ),SDMS(NJ),AICS(NJ),MP(NJ),SDMP(NJ),      &
           AICP(NJ) )
                                                                       
          L = L + NS                                                        
          IF( IF1 .EQ. 2 )     LK0(NJ) = LK1                                     
          IF( IF1 .NE. 2 )     LK0(NJ) = LK0(NJ-1)
!C
!C          -----------------------                                      
!C          PRINT OUT CURRENT MODEL                                      
!!C          -----------------------                                      
!C
             
          LK2(NJ) = LK + NS
                                                                       
!C          ----------------                                             
!C          SPECTRUM DISPLAY                                             
!C          ----------------                                             
                    
          CALL  NRASPE( SDF(NJ),AA,B,MF(NJ),0,120,SXX(1,NJ) )
          DO 110 I = 1,MF(NJ)

                  A(I,NJ) = AA(I)
       110 CONTINUE
!C                                                                       
           GO TO 100                                                         
!C                                                                       
      200 CONTINUE                                                          
    END SUBROUTINE
                        
                                                        
                                                   
    SUBROUTINE  NONSTA( SETX,Z,X,U,LAG,N0,NF,NS,K,IF1,ISW,MJ1,MJ2,A,MF,    &
                   SDF,NNF,NNS,MS,SDMS,AICS,MP,SDMP,AICP )
          implicit none
!C                                                                       
!C     IN THIS SUBROUTINE THE FOLLOWING TWO MODELS ARE COMPARED AND      
!C     THE MODEL WITH LESS AIC IS ACCEPTED AS THE CURRENT MODEL.         
!C                                                                       
!C       MOVING MODEL:     SUCCESSION OF TWO-MODELS INDEPENDENTLY FITTED 
!C                         TO THE DIVIDED DATA                           
!C              NF:     DATA LENGTH OF THE PRECEDING STATIONARY BLOCK    
!C              NS:     DATA LENGTH OF NEW BLOCK (= BASIC LOCAL SPAN )   
!C              AR(MF,SDF):   MAICE AR-MODEL WITH THE ORDER MF AND INNOVA
!C                            VARIANCE SDF FITTED TO THE PRECEDING STATIO
!C                            BLOCK                                      
!C              AR(MS,SDS):   MAICE AR-MODEL (ORDER MS AND INNOVATION VAR
!C                            SDS) FITTED TO THE NEWLY OBTAINED DATA     
!C              AICS = NF*LOG(SDF) + NS*LOG(SDS) + 2*(MF+MS+2)           
!C                                                                       
!C                                AR(MF,SDF)       AR(MS,SDS)            
!C                             !---------------!----------------!        
!C                              <---- NF -----> <----- NS ----->         
!C                                                                       
!C                                                                       
!C       CONSTANT MODEL:   AR MODEL FITTED TO THE POOLED DATA            
!C              NP:     DATA LENGTH OF POOLED DATA  (=NF+NS)             
!C              AR(MP,SDP):   MAICE AR-MODEL FITTED TO THE POOLED DATA   
!C                            (ORDER = MP, INNOVATION VARIANCE = SDP)    
!C              AICP = NP*LOG(SDP) + 2*(MP+1)                            
!C                                                                       
!C                                        AR(MP,SDP)                     
!C                             !--------------------------------!        
!C                              <------------ NP -------------->         
!C                                                                       
!C                                                                       
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             COPY                                                      
!C             ARMFIT                                                    
!C             HUSHLD                                                    
!C             REDUCT                                                    
!C!       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          SETX:   EXTERNAL SUBROUTINE DESIGNATION                      
!C          Z:      ORIGINAL DATA VECTOR                                 
!C          X:      WORKING AREA                                         
!C          U:      WORKING AREA                                         
!C          D:      WORKING AREA                                         
!C          LAG:    UPPER LIMIT OF THE ORDER OF AR-MODEL                 
!C          NS:     LENGTH OF BASIC LOCAL SPAN                           
!C          IF:     =0   FIT INITIAL AR-MODEL AND STORE                  
!C                  >0   UPDATE THE CURRENT MODEL                        
!C          ISW:    =0  TO PRODUCE THE MAICE MODEL ONLY (OUTPUTS SUPPRESS
!C                  =1  TO PRODUCE THE MAICE MODEL ONLY                  
!C!                  =2  TO PRODUCE ALL AR-MODELS (UP TO THE ORDER K)     
!C          TITLE:  TITLE OF DATA                                        
!C          MJ1:    ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM          
!C          MJ2:    ABSOLUTE DIMENSION OF U IN THE MAIN PROGRAM          
!C                                                                       
!C       OUTPUTS:                                                        
!C          A:      AR-COEFFICIENTS OF THE CURRENT MODEL                 
!C          MF:     ORDER OF THE CURRENT MODEL                           
!C          SDF:    INNOVATION VARIANCE OF THE CURRENT MODEL             
!C          IF:     =1   MODEL UNSWITCHED                                
!C                  =2   MODEL SWITCHED                                  
!C                                                                       

          INTEGER(4) :: LAG, N0, NF, NS, K, IF1, ISW, MJ1, MJ2, MF, NNF,   &
                           NNS, MS, MP
          REAL(8), dimension(MJ1)     :: Z 
          REAL(8), dimension(MJ1,K+1) :: X 
          REAL(8), dimension(K+1,K+1) :: U 
          REAL(8), dimension(K)       :: A 
          REAL(8) :: SDF, SDMS, AICS, SDMP, AICP
          ! Locals
          INTEGER(4) :: K1,K2
          REAL(8) :: AICMS,AICMP
          REAL(8), dimension(K) :: B 
          REAL(8), dimension(K+1) :: SDS, AS, DICS, SDP, AP, DICP
!DIR$ ATTRIBUTES ALIGN : 64 ::  SDS,AS,DICS,SDP,AP,DICP    
      !EXTERNAL  SETX
                                                                       
          K1 = K + 1                                                        
          K2 = K1*2                                                         
          NNF = 0
          NNS = 0
              
          CALL  REDUCT( SETX,Z,NS,N0,K,MJ1,LAG,X )                        
!C                                                                     +-
!C       ---  AR-MODEL FITTING TO NEW SET OF DATA  ---                 ! 
!C                                                                     +-

          CALL  ARMFIT( X,K,LAG,NS,ISW,MJ1,B,MS,SDS,AS,DICS,SDMS,AICMS)
                                                             !     +--
          IF( IF1 .NE. 0 )     GO TO 10                                      
                                                            !      +-
          CALL  COPY( X,K1,0,0,MJ1,MJ2,U )                                  
                              
          AICS = NS*DLOG(SDMS) + 2._R64P*(MS+1)                                 
                         
          NNS = NS
          GO TO 20                                                          
    !C                                                              !        
    !C                                                              +--------
    !C       ---  AIC FOR MOVING MODEL  ---                                  
    !C                                                                       
           
       10 AICS = NF*DLOG(SDF) + NS*DLOG(SDMS) + 2._R64P*(MF+MS+2)               
           
          NNF = NF
          NNS = NS
!C                                                                       
!C          -------------------------------                              
!C          AR-MODEL FITTING TO POOLED DATA                              
!C          -------------------------------                            +-
!C                                                                     ! 
                                                                    +-
          CALL  COPY( X,K1,0,K2,MJ1,MJ1,X )                                 
          CALL  COPY( U,K1,0,K1,MJ2,MJ1,X )                                 
!C                                                                     +-
!C       HOUSEHOLDER TRANSFORMATION  ---                               ! 
!C                                                                     +-
                                  
          CALL  HUSHLD( X,MJ1,K2,K1 )                                     
!C                                                                       
!C       ---  AR MODEL FITTING TO POOLED DATA  ---                       
!C                                                                       
          NP = NF + NS                                                      

          CALL  ARMFIT( X,K,LAG,NP,ISW,MJ1,A,MP,SDP,AP,DICP,SDMP,AICMP)
!C                                                                       
!C       ---  AIC FOR CONSTANT MODEL  ---                                
!C                                                                       
                        
          AICP = NP*DLOG(SDMP) + 2._R64P*(MP+1)                                 
!C                                                                       
!C          --------------------                              YES  +-----
!C          COMPARISON OF MODELS                             +-----!AICS 
!C          --------------------                             !     +-----
                                                           !           
          IF( AICS .GE. AICP )     GO TO  40                                
                     !         +-
          CALL  COPY( X,K1,K2,0,MJ1,MJ2,U )                                 
                                                           !           
       20 IF1 = 2                                                            
          NF = NS                                                           
          MF = MS                                                           
                                                           !           
          DO 30  I=1,MF                                                     

               A(I) = B(I)
       30 CONTINUE                                                       
                                                 
          SDF = SDMS                                                         
          GO TO 50                                                          
                                                           +-----------
       40 IF1 = 1                                                            
                                                                      
          CALL  COPY( X,K1,0,0,MJ1,MJ2,U )                                  
                                                  
          SDF = SDMP                                                         
          MF = MP                                                           
          NF = NF + NS                                                      
                                                                       
       50 CONTINUE                                                          

    END SUBROUTINE
                   

    SUBROUTINE  MLOMARF( ZS,N,ID,C,LAG,NS0,KSW,K,ZMEAN,ZVARI,NF,NS,MS,  &
                            AIC,MP,AICP,MF,AICF,A,E,LK0,LKE,M )
          implicit none             

!cc      PROGRAM  MLOMAR                                                   
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.3.3.                                                    
!C     _                     __                 _            __          
!C     MINIMUM AIC METHOD OF LOCALLY STATIONARY MULTIVARIATE AR MODEL FIT
!C                                                                       
!C     THIS PROGRAM LOCALLY FITS MULTI-VARIATE AUTOREGRESSIVE MODELS TO  
!C     NON-STATIONARY TIME SERIES BY THE MINIMUM AIC PROCEDURE USING THE 
!C     HOUSEHOLDER TRANSFORMATION.                                       
!C                                                                       
!C     BY THIS PROCEDURE, THE DATA OF LENGTH N ARE DIVIDED INTO J LOCALLY
!C     STATIONARY SPANS                                                  
!C                                                                       
!C!                <-- N1 --> <-- N2 --> <-- N3 -->          <-- NJ -->   
!C               !----------!----------!----------!--------!----------!  
!C                <-----------------------  N  ---------------------->   
!C                                                                       
!C     WHERE NI (I=1,...,J) DENOTES THE NUMBER OF BASIC SPANS, EACH OF   
!C     LENGTH NS, WHICH CONSTITUTE THE I-TH LOCALLY STATIONARY SPAN.     
!C     AT EACH LOCAL SPAN, THE PROCESS IS REPRESENTED BY A STATIONARY    
!C     AUTOREGRESSIVE MODEL.                                             
!C                                                                       
!C                                                                       
!C       --------------------------------------------------------------- 
!C       REFERENCE:                                                      
!C          G.KITAGAWA AND H.AKAIKE(1978), "A PROCEDURE FOR THE MODELING 
!C          OF NON-STATIONARY TIME SERIES.",  ANN. INST. STATIST. MATH., 
!C          30,B,351-363.                                                
!C       --------------------------------------------------------------- 
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:  
!C             MRDATA                                                    
!C             MNONST                                                    
!C       --------------------------------------------------------------- 
!C       INPUTS REQUIRED;                                                
!C          MT:    INPUT DEVICE FOR ORIGINAL DATA (MT=5: CARD READER).   
!C          LAG:   UPPER LIMIT OF THE ORDER OF AR-MODEL, MUST BE LESS THA
!C                 OR EQUAL TO 50.                                       
!C          NS:    LENGTH OF BASIC LOCAL SPAN.                           
!C          KSW:   =0  CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR    
!C                 =1  CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESSOR
!C                                                                       
!C            -- THE FOLLOWING INPUTS ARE REQUESTED BY SUBROUTINE MRDATA 
!C!          TITLE: SPECIFICATION OF DATA                                 
!C          N:     DATA LENGTH, MUST BE LESS THAN OR EQUAL TO 1000.      
!C          ID:    DIMENSION OF DATA,  MUST BE LESS THAN 6               
!C                       < ID*(LAG+1)+KSW MUST BE LESS THAN 101 >        
!C          IFM:   INPUT FORMAT                                          
!C          FORM:  INPUT DATA FORMAT SPECIFICATION STATEMENT.            
!C                 -- EXAMPLE --     (8F10.5)                            
!C          C(J):  CALIBRATION CONSTANT FOR CHANNEL J (J=1,ID)           
!C          Z(I,J): ORIGINAL DATA                                        
!C            -----------------------------------------------------------
!C                                                                       

          INTEGER(4) :: N, ID, LAG, NS0, KSW, K, M 
          INTEGER(4), dimension(K) :: NF, NS, MS, MP, MF, LK0, LKE 
          REAL(8), dimension(N,ID) :: ZS 
          REAL(8), dimension(ID)   :: C, ZMEAN, ZVARI
          REAL(8), dimension(K)    :: AIC,AICP,AICF           
          REAL(8), dimension(ID,ID,LAG,K) ::  A 
          REAL(8), dimension(ID,ID,K)     ::  E
          ! Locals
          INTEGER(4) :: MJ2,MJ3,MJ1,L,KD,MX,LK,LK1,IF1
          REAL(8), dimension(N,ID)      :: Z 
          REAL(8), dimension(ID,ID,LAG) ::  B
          REAL(8), dimension(((LAG+1)*ID+KSW)*4,((LAG+1)*ID+KSW)*2) :: X   
          REAL(8), dimension(((LAG+1)*ID+KSW)*2,((LAG+1)*ID+KSW)*2) :: U  
!DIR$ ATTRIBUTES ALIGN : 64 :: Z,B,U,X
                                                      
                                                    
          MJ2 = ((LAG+1)*ID+KSW)*2
          MJ1 = MJ2*2
          MJ3 = ID

          NF(1:K) = 0
          NS(1:K) = 0
          MS(1:K) = 0
          AIC(1:K) = 0.0_8
          MP(1:K) = 0
          AICP(1:K) = 0.0_8
          MF(1:K) = 0
          AICF(1:K) = 0.0_8
          A(1:ID,1:ID,1:LAG,1:K) = 0.0_8
          E(1:ID,1:ID,1:K) = 0.0_8
          LK0(1:K) = 0
          LKE(1:K) = 0
          X(1:MJ1,1:MJ2) = 0.0_8
          U(1:MJ2,1:MJ2) = 0.0_8
                                                                       
          NS(1) = NS0
                              
          CALL MRDATA( ZS,Z,N,ID,C,ZMEAN,ZVARI )
                                                                    
          L = 0                                                             
          KD = LAG * ID + KSW                                               
          MX = KD * 2                                                       
                                                                      
          IF1 = 0
          M = 0
          NF(1) = 0
      111 CONTINUE                                                          

          LK = L + LAG                                                      
          LK1 = LK + 1                                                      
          IF( LK1 .GE. N )     GO TO 300                                    
          M = M+1
                   
          IF( M. NE. 1 )  THEN
              AICF(M) = AICF(M-1)
              NS(M) = NS(M-1)
              LK0(M) = LK0(M-1)
          END IF
          IF( N-LK1 .LE. NS(M) )     NS(M) = N - LK
          IF( N-LK1-NS(M) .LT. MX )     NS(M) = N - LK
                                           
          CALL MNONST( Z,X,U,KSW,LAG,L,NNF,NF(M),NS(M),ID,IF1,N,MJ1,MJ2,MJ3,  &
                     A(1,1,1,M),B,E(1,1,M),MS(M),AIC(M),MP(M),AICP(M),MF(M),AICF(M) )
                                 
          L = L + NS(M)
          IF( IF1 .EQ. 2 )     LK0(M) = LK1
                                             
          LKE(M) = LK + NS(M)
                                                                   
          GO TO 111                                                         
      300 CONTINUE                                                          
    END SUBROUTINE
                            
                               
                       
    SUBROUTINE  MNONST( Z,X,U,KSW,LAG,N0,NNF,NF,NS,ID,IF1,MJ,MJ1,MJ2,         &
                         MJ3,A,B,E,MS,AICFS,MP,AICP,MF,AICF )
          implicit none
!C                                                                       
!C     IN THIS SUBROUTINE THE FOLLOWING TWO MODELS ARE COMPARED AND      
!C     THE MODEL WITH THE SMALLER AIC IS ACCEPTED AS THE CURRENT MODEL.  
!C                                                                       
!C       MOVING MODEL:      SUCCESSION OF TWO AR-MODELS INDEPENDENTLY FIT
!C                          TO THE FORMER AND PRESENT BLOCK OF DATA      
!C          NF:    DATA LENGTH OF THE PRECEDING STATIONARY BLOCK         
!C          NS:    DATA LENGTH OF NEW BLOCK (A BASIC LOCAL SPAN)         
!C          AR(MF,SDF):  MAICE AR-MODEL WITH THE ORDER MF AND INNOVATION 
!C                       VARIANCE SDF FITTED TO THE PRECEDING STATIONARY 
!C                       BLOCK                                           
!C          AR(MS,SDS):  MAICE AR-MODEL (ORDER MS AND INNOVATION VARIANCE
!C                       SDS) FITTED TO THE NEWLY OBTAINED DATA          
!C                                                                       
!C                                AR(MF,SDF)      AR(MS,SDS)             
!C                             !---------------!---------------!         
!C                              <---- NF -----> <----- NS ---->          
!C                                                                       
!C       CONSTANT MODEL:    AR MODEL FITTED TO THE POOLED DATA OF THE FOR
!C                          AN PRESENT BLOCK                             
!C          NP:    DATA LENGTH OF POOLED DATA                            
!C          AR(MP,SDP):  MAICE AR-MODEL FITTED TO THE POOLED DATA        
!C                       (ORDER=MP, INNOVATION VARIANCE=SDP)             
!C                                                                       
!C                                       AR(MP,SDP)                      
!C                             !-------------------------------!         
!C!                              <----------- NP -------------->          
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             COPY                                                      
!C             HUSHLD                                                    
!C             MARFIT                                                    
!C             MREDCT                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C       INPUTS:                                                         
!C          Z:      ORIGINAL DATA; Z(K,I) (K=1,N) REPRESENTS THE RECORD O
!C                  THE I-TH CHANNEL                                     
!C          X:      WORKING AREA                                         
!C          U:      WORKING AREA                                         
!C          D:      WORKING AREA                                         
!C          KSW:    =0   CONSTANT VECTOR IS NOT INCLUDED AS A REGRESSOR  
!C                  =1   CONSTANT VECTOR IS INCLUDED AS THE FIRST REGRESS
!C          LAG:    UPPER LIMIT OF THE ORDER OF AR MODEL                 
!C          N0:     INDEX OF THE END POINT OF THE FORMER SPAN            
!C          NS:     LENGTH OF BASIC LOCAL SPAN                           
!C          ID:     DIMENSION OF DATA                                    
!C          IF:                                                          
!C          MJ:     ABSOLUTE DIMENSION OF Z IN THE MAIN PROGRAM          
!C          MJ1:    ABSOLUTE DIMENSION OF X IN THE MAIN PROGRAM          
!C          MJ2:    ABSOLUTE DIMENSION OF U IN THE MAIN PROGRAM          
!C          MJ3:    ABSOLUTE DIMENSION OF A IN THE MAIN PROGRAM          
!C          B:      WORKING AREA                                         
!C                                                                       
!C       OUTPUTS:                                                        
!C          A:      AR COEFFICIENT MATRICES OF THE CURRENT MODEL         
!C          MF:     ORDER OF THE CURRENT MODEL                           
!C          AICF:   AIC OF THE CURRENT MODEL                             
!C                                                                       
!C                                                                       

          INTEGER(4) :: KSW, LAG, N0, NNF, NF, NS, ID, IF1, MJ, MJ1, MJ2,       &
                           MJ3, MS, MP, MF
          REAL(8), dimension(MJ,ID)     ::  Z 
          REAL(8), dimension(MJ1,MJ2)   ::  X 
          REAL(8), dimension(MJ2,MJ2)   ::  U 
          REAL(8), dimension(ID,ID,LAG) ::  A,B
          REAL(8), dimension(ID,ID)     ::  E 
          REAL(8) ::  AICFS, AICP, AICF
          ! Locals
          INTEGER(4) :: MJ4,IPR,K1,KD1,KD2,II,I,J
          REAL(8)    ::  AICS
          INTEGER(4), dimension(ID)     ::  M,NPR 
          INTEGER(4), dimension(MJ2,ID) ::  JNDF
          REAL(8), dimension(ID,ID,LAG) ::  AI, BI 
          REAL(8), dimension(ID,ID)     ::  EI 
          REAL(8), dimension(ID)        ::  C, EX,AICM,SDM,AAIC
          REAL(8), dimension(LAG+1,ID)  ::  AIC, SD, DIC 
          REAL(8), dimension(MJ2,ID)    ::  AF
!DIR$ ATTRIBUTES ALIGN : 64 :: M,NPR,JNDF,AI,BI,EI,C,EX,AICM,SD,,AAIC,AIC,SD,DIC,AF                                                   
          MJ4 = LAG
          IPR = 0
                                                                      
          K1 = LAG + 1                                                      
          KD1 = K1*ID + KSW                                                 
          KD2 = KD1 * 2                                                     
!C                                                                       
!C       HOUSEHOLDER'S REDUCTION                                         
!C                                                                       
             
          CALL  MREDCT( Z,NS,N0,LAG,ID,MJ,MJ1,KSW,X )
                                                                       
!C                                                                       
!C       AR-MODEL FITTING BY THE MINIMUM AIC PROCEDURE                   
!C                                                                       

          CALL  MARFIT( X,NS,ID,LAG,KSW,MJ1,MJ3,MJ4,KD1,0,IPR,AIC,SD,DIC,   &
                       AICM,SDM,M,BI,EI,B,E,EX,C,MS,AICS,JNDF,AF,NPR,AAIC )
     
                                                                       
          IF( IF1 .NE. 0 )     GO TO 10                                      
                                                                       
          CALL  COPY( X,KD1,0,0,MJ1,MJ2,U )                                 
                               
          GO TO 20                                                          
                                            
       10 AICFS = AICF + AICS                                               
                       
          NF = NNF
                                                                       
          CALL  COPY( X,KD1,0,KD2,MJ1,MJ1,X )                               
          CALL  COPY( U,KD1,0,KD1,MJ2,MJ1,X )                               
!C                                                                       
!!C       ---  HOUSEHOLDER TRANSFORMATION  ---                            
!C                                                                       
                              
          CALL  HUSHLD( X,MJ1,KD2,KD1 )                                   
                                                                       
 

!C                                                                       
!C       ---  AR-MODEL FITTING FOR POOLED DATA  ---                      
!C                                                                       
          NP = NNF + NS                                                     

          CALL  MARFIT( X,NP,ID,LAG,KSW,MJ1,MJ3,MJ4,KD1,0,IPR,AIC,SD,DIC,   &
                         AICM,SDM,M,AI,EI,A,E,EX,C,MP,AICP,JNDF,AF,NPR,AAIC )
           
                              
          IF( AICFS .GE. AICP )     GO TO 40                                
                                                                     
          CALL  COPY( X,KD1,KD2,0,MJ1,MJ2,U )                               
                                                                       
       20 CONTINUE                                                          
          IF1 = 2                                                            
          NNF = NS                                                          
          MF = MS                                                           
          AICF = AICS                                                       

          DO 32  II=1,MF                                                    
                 DO 31  J=1,ID                                                     
                        DO 30  I=1,ID                                                     

                            A(I,J,II) = B(I,J,II)                                            
                     30 CONTINUE
             31 CONTINUE
       32 CONTINUE
          GO TO 50                                                          
                                                                      
       40 CONTINUE                                                          
          IF1 = 1                                                            
          CALL  COPY( X,KD1,0,0,MJ1,MJ2,U )                                 
                                                 
          NNF = NNF + NS                                                    
          MF = MP                                                           
          AICF = AICP                                                       
                                                                       
         50 CONTINUE                                                          
    END SUBROUTINE
                         

    SUBROUTINE MULBARF( ZS,N,ID,C,LAG,ZMEAN,ZVARI,SD,AIC,DIC,IMIN,   &
                        AICM,SDMIN,BW1,BW2,A,B,G,H,E,AICB )
        implicit none

!cc      PROGRAM  MULBAR                                                   
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.2.2.                                                    
!C     ___          _                  __                                
!C     MULTIVARIATE BAYESIAN METHOD OF AR MODEL FITTING                  
!C                                                                       
!C     THIS PROGRAM DETERMINES MULTI-VARIATE AUTOREGRESSIVE MODELS BY A  
!C     BAYESIAN PROCEDURE.  THE BASIC LEAST SQUARES ESTIMATES OF THE PARA
!C     ARE OBTAINED BY THE HOUSEHOLDER TRANSFORMATION.                   
!C                                                                       
!C     THE STATISTIC AIC IS DEFINED BY                                   
!C                                                                       
!C            AIC  =  N * LOG( DET(SD) ) + 2 * (NUMBER OF PARAMETERS)    
!C                                                                       
!C       WHERE                                                           
!C           N:    NUMBER OF DATA,                                       
!C           SD:   ESTIMATE OF INNOVATION VARIANCE MATRIX                
!C           DET:  DETERMINANT,                                          
!C           K:    NUMBER OF FREE PARAMETERS.                            
!C                                                                       
!C     BAYESIAN WEIGHT OF THE M-TH ORDER MODEL IS DEFINED BY             
!C         W(M)  = CONST * C(M) / (M+1)                                  
!C     WHERE                                                             
!C         CONST = NORMALIZING CONSTANT                                  
!C         C(M)  = EXP( -0.5*AIC(M) ).                                   
!C     THE BAYESIAN ESTIMATES OF PARTIAL AUTOREGRESSION COEFFICIENT MATRI
!C     OF FORWARD AND BACKWARD MODELS ARE OBTAINED BY (M=1,...,LAG)      
!C         G(M)  = G(M)*D(M)                                             
!C         H(M)  = H(M)*D(M),                                            
!C     WHERE THE ORIGINAL G(M) AND H(M) ARE THE (CONDITIONAL) MAXIMUM    
!C     LIKELIHOOD ESTIMATES OF THE HIGHEST ORDER COEFFICIENT MATRICES OF 
!C!     FORWARD AND BACKWARD AR MODELS OF ORDER M AND D(M) IS DEFINED BY  
!C         D(M)  = W(M) + ... + W(LAG).                                  
!C                                                                       
!C     THE EQUIVALENT NUMBER OF PARAMETERS FOR THE BAYESIAN MODEL IS     
!C     DEFINED BY                                                        
!C         EK = (D(1)**2 + ... + D(LAG)**2)*ID + ID*(ID+1)/2             
!C     WHERE ID DENOTES DIMENSION OF THE PROCESS.                        
!C!                                                                       
!C                                                                       
!C       --------------------------------------------------------------- 
!C       REFERENCES:                                                     
!C          H.AKAIKE(1978), "A BAYESIAN EXTENSION OF THE MINIMUM AIC     
!C          PROCEDURE OF AUTOREGRESSIVE MODEL FITTING.",  RESEARCH MEMO. 
!C          NO. 126, THE INSTITUTE OF STATISTICAL MATHEMATICS; TOKYO.    
!C                                                                       
!C          G.KITAGAWA AND H.AKAIKE(1978), "A PROCEDURE FOR THE MODELING 
!C          OF NON-STATIONARY TIME SERIES.",  ANN. INST. STATIST. MATH., 
!C          30,B,351-363.                                                
!C       --------------------------------------------------------------- 
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:  
!C             MRDATA                                                    
!C             MREDCT                                                    
!C             MARFIT                                                    
!C       ----------------------------------------------------------------
!C       INPUTS REQUIRED:                                                
!C!           MT:    INPUT DEVICE FOR ORIGINAL DATA (MT=5; CARD READER)   
!C!           LAG:   UPPER LIMIT OF AR-ORDER,  MUST BE LESS THAN 31       
!C                                                                       
!C-----  THE FOLLOWING INPUTS ARE REQUIRED AT SUBROUTINE MRDATA  -----   
!C                                                                       
!C           TITLE: SPECIFICATION OF DATA                                
!C           N:     DATA LENGTH,  MUST BE LESS THAN OR EQUAL TO 1000     
!C           ID:    DIMENSION OF VECTOR,  MUST BE LESS THAN 11           
!C                       < ID * LAG  MUST BE LESS THAN 101 >             
!C           IFM:   CONTROL FOR INPUT                                    
!C           FORM:  INPUT DATA FORMAT SPECIFICATION STATEMENT            
!C                  -- FOR EXAMPLE --     (8F10.5)                       
!C           C(I):  CALIBRATION OF CHANNEL I (I=1,ID)                    
!C           Z:     ORIGINAL DATA; Z(K,I) (K=1,N) REPRESENTS THE I-TH CHA
!C                  RECORD                                               
!C                                                                       


          INTEGER(4) :: N, ID, LAG, IMIN
          REAL(8), dimension(N,ID)  :: ZS 
          REAL(8), dimension(ID)    :: C, ZMEAN, ZVARI 
          REAL(8), dimension(LAG+1) ::  SD,AIC,DIC,BW1
          REAL(8) ::  AICM, SDMIN, AICB
          REAL(8), dimension(LAG)       :: BW2      
          REAL(8), dimension(ID,ID,LAG) :: A,B,G,H          
          REAL(8), dimension(ID,ID)     ::  E 
          ! Loclas
          INTEGER(4) :: MJ,MJ1,MJ2,IPR,N0,NMK,KSW
          REAL(8) :: EK
          REAL(8), dimension(N,ID) :: Z 
          REAL(8), dimension((LAG+1)*ID*2,(LAG+1)*ID) :: X 
!DIR$ ATTRIBUTES ALIGN : 64 :: Z,X
                                                      
          MJ = N
          MJ1 = (LAG+1)*ID*2
          MJ2 = ID
          IPR = 1                                                           
          IPR = 3                                                           
          IPR = 2                                                           
                                
          CALL MRDATA( ZS,Z,N,ID,C,ZMEAN,ZVARI )

          N0 = 0                                                            
          NMK = N - LAG                                                     
          KSW = 0                                                           
!C                                                                       
!C     --  HOUSEHOLDER REDUCTION  --                                     
!C                                                                       
        
          X(1:MJ1,1:(LAG+1)*ID) = 0.0_8
          CALL  MREDCT( Z,NMK,N0,LAG,ID,MJ,MJ1,KSW,X )                    
!C                                                                       
!C     --  AR-MODEL FITTING (BAYESIAN PROCEDURE)  --                     
!C                                                                       

          CALL  MBYSAR( X,NMK,LAG,ID,KSW,MJ1,MJ2,SD,AIC,DIC,       &
                       AICM,SDMIN,IMIN,BW1,BW2,A,B,G,H,E,AICB,EK )

    END SUBROUTINE
                        
    SUBROUTINE MULCORF(X1,N,K,LAGH1,SM,C,CN)
          implicit none
!C     PROGRAM 5.1.2   MULTIPLE CORRELATION
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM REQUIRES FOLLOWING INPUTS:
!C     N: LENGTH OF DATA
!C     K: DIMENSION OF THE OBSERVATION VECTOR
!C     LAGH: MAXIMUM LAG
!C     ISW: ISW=1...ROWWISE DATA INPUT
!C           ISW=2...COLUMNWISE DATA INPUT
!C     DFORM: INPUT FORMAT SPECIFICATION STATEMENT IN ONE CARD,
!C     FOR EXAMPLE
!C     (8F10.4)
!C     (X1(S,I); S=1,...,N, I=1,...,K): ORIGINAL DATA MATRIX.
!C     THE OUTPUTS ARE (CIJ(L): L=0,1,...,LAGH) (I=1,...,K; J=1,...,K),
!C     WHERE CIJ(L)=COVARIANCE(XI(S+L),XJ(S)),
!C     AND THEIR NORMALIZED (CORRELATION) VALUES.
!C
    

          INTEGER(4) :: N, K, LAGH1
          REAL(8), dimension(N,K)       :: X1 
          REAL(8), dimension(K)         :: SM 
          REAL(8), dimension(LAGH1,K,K) ::  C, CN
          ! Locals
          INTEGER(4) :: II,I,JJ,IM1
          REAL(8)    :: CX0, CY0, XMEAN
          REAL(8), dimension(N,K)    ::  X2 
          REAL(8), dimension(N)      ::  X, Y 
          REAL(8), dimension(LAGH1)  ::  C1, C2, CN1, CN2
          REAL(8), dimension(K)      ::  C0 
!DIR$ ATTRIBUTES ALIGN : 64 :: X2,X,Y,C1,C2,CN1,CN2,C0
!C     MEAN DELETION
         DO 300 II=1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                DO 310 I=1,N

                      X(I)=X1(I,II)
         310    CONTINUE
                CALL DMEADL(X,N,XMEAN)
                SM(II)=XMEAN
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))                
                DO 320 I=1,N

                      X2(I,II)=X(I)
        320    CONTINUE
      300 CONTINUE
!C
!C     COVARIANCE COMPUTATION
          DO 10 II=1,K
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))              
                DO 110 I=1,N

                      X(I)=X2(I,II)
        110    CONTINUE
!C     AUTO COVARIANCE COMPUTATION
               CALL CROSCO(X,X,N,C1,LAGH1)
!C     NORMALIZATION
               C0(II)=C1(1)
               CX0=C0(II)
               CALL CORNOM(C1,CN1,LAGH1,CX0,CX0)
!C     AUTO COVARIANCE PRINT OUT
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
               DO 115 I=1,LAGH1
                     C(I,II,II)=C1(I)
                     CN(I,II,II)=CN1(I)
           115 CONTINUE
              IF(II.EQ.1) GO TO 10
              IM1=II-1
              DO 11 JJ=1,IM1
                  DO 120 I=1,N

                     Y(I)=X2(I,JJ)
           120    CONTINUE
!C     CROSS COVARIANCE COMPUTATION
                  CALL CROSCO(X,Y,N,C1,LAGH1)
                  CALL CROSCO(Y,X,N,C2,LAGH1)
!C \81@\81@NORMALIZATION
                  CX0=C0(II)
                  CY0=C0(JJ)
                  CALL CORNOM(C1,CN1,LAGH1,CX0,CY0)
                  CALL CORNOM(C2,CN2,LAGH1,CX0,CY0)
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
                  DO 125 I=1,LAGH1
                       C(I,II,JJ)=C1(I)
                       C(I,JJ,II)=C2(I)
                       CN(I,II,JJ)=CN1(I)
                       CN(I,JJ,II)=CN2(I)
              125 CONTINUE
          11 CONTINUE
       10 CONTINUE

    END SUBROUTINE
    
    
    SUBROUTINE MULFRFF(K,INW,N,LAGH1,IP0,P,X,C,S,G,PH,PCH,R,CHM)
          implicit none

!C     PROGRAM 5.2.4   FREQUENCY RESPONSE FUNCTION (MULTIPLE CHANNEL)
!C-----------------------------------------------------------------------
!C      SUBROUTINE FQCPIV(X,XDET,MM,MJ)
!C      SUBROUTINE MPHASE(C,S,OARC,PH,K,JJF)
!C      SUBROUTINE MULARC(C,S,ARC,K)
!C      SUBROUTINE MULERR(PCH,R,N,LAGH1,K,JJF,D1,D2)
!C      SUBROUTINE MULPAC(ARC,OARC,PH,K,JJF)
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES MULTIPLE FREQUENCY RESPONSE FUNCTION, GAIN,
!C     PHASE, MULTIPLE COHERENCY, PARTIAL COHERENCY AND RELATIVE ERROR
!C     STATISTICS.
!C     A CARD WITH THE TOATL NUMBER(K) OF INPUT VARIABLES AND ANOTHER
!C     WITH SPECIFICATION OF INPUT VARIABLES(INW(I),I=1,K) AND OUTPUT
!C     VARIABLE(INW(K+1)) SHOULD BE ADDED ON TOP OF THE OUTPUT OF
!C     PROGRAM 5.2.2 MULSPE TO FORM THE INPUT TO THIS PROGRAM.
!C     WITHIN IP0 VARIABLES OF MULSPE OUTPUT, ONLY THOSE K+1 INW(I)-TH
!C     VARIABLES ARE TAKEN INTO COMPUTATION.
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: MULFRFF
!c      USE DFLIB
!C

          INTEGER(4) :: K, N, LAGH1, IP0
          INTEGER(4), dimension(K+1) :: INW
          REAL(8), dimension(LAGH1,IP0,IP0)   :: P 
          REAL(8), dimension(K,LAGH1)         :: C, S, G, PH, PCH, R
          REAL(8), dimension(LAGH1)           :: CHM
        
          COMPLEX(8), dimension(IP0,IP0,LAGH1) :: X
          ! Locals
          INTEGER(4) :: K1,JJF,JF,I,IM1,J,II
          REAL(8)    :: P00, EP, G2, G3, D1, D2
          COMPLEX(8) :: XDET
          REAL(8), dimension(K) :: OARC 
          COMPLEX(8), dimension(IP0,IP0,LAGH1) :: XFR
!DIR$ ATTRIBUTES ALIGN : 64 :: OARC,XFR
          K1=K+1

          DO 10 JF=1,LAGH1
                JJF=JF

               DO 401 I=1,IP0

                      X(I,I,JF)=P(JF,I,I)
                      IF(I.EQ.1) GO TO 401
                      IM1=I-1
                      DO 402 J=1,IM1

                             X(I,J,JF)=DCMPLX(P(JF,I,J),P(JF,J,I))

                             X(J,I,JF)=DCONJG(X(I,J,JF))
                  402 CONTINUE
          401 CONTINUE
!C     MATRIX REARRANGEMENT AND PRINT OUT (COMPLEX)

              CALL REARRAC(X(1,1,JF),INW,IP0,K1)

              P00=DREAL(X(K1,K1,JF))

              DO 31 I=1,IP0
                     DO 30 II=1,IP0
                              XFR(I,II,JF)=X(I,II,JF)
                  30 CONTINUE
           31 CONTINUE
              CALL FQCPIV(XFR(1,1,JF),XDET,K,IP0)
              DO 20 I=1,K

                     C(I,JF)=DREAL(XFR(I,K1,JF))

                     S(I,JF)=-DIMAG(XFR(I,K1,JF))
           20 CONTINUE
!C     GAIN COMPUTATION
              DO 21 I=1,K

                    G(I,JF)=DSQRT(C(I,JF)**2+S(I,JF)**2)
           21 CONTINUE
!C     PHASE COMPUTATION

              IF(JJF.NE.1) THEN
                   DO 24 I=1,K

                      PH(I,JF)=PH(I,JF-1)
             24    CONTINUE
             END IF
             CALL MPHASE(C(1,JF),S(1,JF),OARC,PH(1,JF),K,JJF)
!C     PARTIAL COHERENCY AND MULTIPLE COHERENCY COMPUTATION

             EP=DREAL(XFR(K1,K1,JF))
             DO 22 I=1,K

                    G2=G(I,JF)**2

                    G3=G2+EP*DREAL(XFR(I,I,JF))
                    IF(G3.NE.0.0) GO TO 23

                    PCH(I,JF)=100.0_R64P
                    GO TO 22

                 23 PCH(I,JF)=G2/G3
          22 CONTINUE

             CHM(JF)=1.0_R64P-EP/P00
!C     RELATIVE ERROR STATISTICS COMPUTATION

             CALL MULERR(PCH(1,JF),R(1,JF),N,LAGH1,K,JJF,D1,D2)
!C     FREQUENCY RESPONSE FUNCTION, GAIN, PHASE, PARTIAL COHERENCY,
!C     MULTIPLE COHERENCY, RELATIVE ERROR STATISTICS PRINT OUT

       10 CONTINUE

    END SUBROUTINE

    SUBROUTINE FQCPIV(X,XDET,MM,MJ)
          implicit none
!C     THIS SUBROUTINE COMPUTES MULTIPLE FREQUENCY RESPONSE FUNCTION.
!C     MM: THE TOTAL NUMBER OF INPUTS (LESS THAN 10)
!C     MJ: ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE

          INTEGER(4) :: MM, MJ
          COMPLEX(8), dimension(MJ,MJ) :: X 
          COMPLEX(8) :: XDET
          ! Locals
          INTEGER(4) :: MP1,L,MAXI,I,J,MM1,MMJ,JJ
          COMPLEX(8) :: XMAXP, XC
          INTEGER(4), dimension(MM) :: IDS
         

          XDET=1.0_8
          MP1=MM+1
          DO 10 L=1,MM
!C     PIVOTING AT L-TH STAGE
                XMAXP=0.10000E-10_8
                MAXI=0
                DO 110 I=L,MM
                       IF(CDABS(XMAXP).GE.CDABS(X(I,L))) GO TO 110
                       XMAXP=X(I,L)
                       MAXI=I
           110 CONTINUE
               IDS(L)=MAXI
               IF(MAXI.EQ.L) GO TO 120
               IF(MAXI.GT.0) GO TO 121
               XDET=0.0_8
               GO TO 140
!C     ROW INTERCHANGE
           121 DO 14 J=1,MP1
                     XC=X(MAXI,J)
                     X(MAXI,J)=X(L,J)

                     X(L,J)=XC
           14 CONTINUE
              XDET=-XDET
          120 XDET=XDET*XMAXP
              XC=1.0_R64P/XMAXP
              X(L,L)=1.0_R64P
              DO 11 J=1,MP1

                      X(L,J)=X(L,J)*XC
           11 CONTINUE
              DO 12 I=1,MP1
                    IF(I.EQ.L) GO TO 12
                    XC=X(I,L)
                    X(I,L)=0.0_R64P
                    DO 13 J=1,MP1

                            X(I,J)=X(I,J)-XC*X(L,J)
                 13 CONTINUE
          12 CONTINUE
       10 CONTINUE
          IF(MM.GT.1) GO TO 123
          GO TO 140
!C     COLUMN INTERCHANGE
      123 MM1=MM-1
          DO 130 J=1,MM1
                 MMJ=MM-J
                 JJ=IDS(MMJ)
                 IF(JJ.EQ.MMJ) GO TO 130
                 DO 131 I=1,MP1
                        XC=X(I,JJ)
                        X(I,JJ)=X(I,MMJ)

                        X(I,MMJ)=XC
             131 CONTINUE
        130 CONTINUE
      140 RETURN
    END SUBROUTINE

    SUBROUTINE MPHASE(C,S,OARC,PH,K,JJF)
          implicit none
!C     THIS SUBROUTINE COMPUTES PHASE.
!C     (MULTIPLE CHANNEL)

          INTEGER(4) :: K, JJF
          REAL(8), dimension(K) :: C, S, OARC, PH
          !Locals
          REAL(8), dimension(K) :: ARC
!C     ARCTANGENT COMPUTATION
          CALL MULARC(C,S,ARC,K)
!C     PHASE COMPUTATION
          CALL MULPAC(ARC,OARC,PH,K,JJF)
     
    END SUBROUTINE
    

    SUBROUTINE MULARC(C,S,ARC,K)
          implicit none
!C     THIS SUBROUTINE COMPUTES RAW PHASE.
!C     (MULTIPLE CHANNEL)

          INTEGER(4) :: K
          REAL(8), dimension(K) :: C, S, ARC
          REAL(8) :: PI, CST5
          PI==3.1415926535897932384626433_8
          CST5=0.5_8
          DO 10 I=1,K

             IF(C(I).EQ.0) GO TO 12
             IF(C(I).GT.0) GO TO 13

             IF(S(I).LT.0) GO TO 14
             IF(S(I).EQ.0) GO TO 15
             IF(S(I).GT.0) GO TO 16
          12 IF(S(I).LT.0) GO TO 17
             IF(S(I).EQ.0) GO TO 18
             IF(S(I).GT.0) GO TO 19
          13 ARC(I)=DATAN(S(I)/C(I))
             GO TO 10
          14 ARC(I)=DATAN(S(I)/C(I))-PI
             GO TO 10
          15 ARC(I)=-PI
             GO TO 10
          16 ARC(I)=DATAN(S(I)/C(I))+PI
             GO TO 10
          17 ARC(I)=-PI*CST5
             GO TO 10
          18 ARC(I)=0.0_R64P
             GO TO 10
          19 ARC(I)=PI*CST5
       10 CONTINUE
      
    END SUBROUTINE
    

    SUBROUTINE MULERR(PCH,R,N,LAGH1,K,JJF,D1,D2)
          implicit none
!C     THIS SUBROUTINE COMPUTES RELATIVE ERROR STATISTICS.
!C     (MULTIPLE CHANNEL)

          INTEGER(4) :: N, LAGH1, K,JJF
          REAL(8), dimension(K) :: PCH, R 
          REAL(8) ::  D1, D2
          ! Locals
          INTEGER(4) :: I,LAGH,
          REAL(8) :: CST0, CST1, CST100, E1, ER
          CST0=0.0_8
          CST1=1.0_8
          CST100=100.0_8
          IF(JJF.NE.1) GO TO 30
!C     CONSTANTS D1,D2 COMPUTATION
          LAGH=LAGH1-1
          CALL SUBD12(N,LAGH,K,D1,D2)
!C     RELATIVE ERROR STATISTICS COMPUTATION
       30 DO 20 I=1,K
               IF(PCH(I).LE.CST0) GO TO 22
               IF(PCH(I).GT.CST1) GO TO 22
               E1=CST1/PCH(I)-CST1
               ER=DSQRT(E1)
               IF(JJF.EQ.1) GO TO 23
               IF(JJF.EQ.LAGH1) GO TO 23
               R(I)=D2*ER
               GO TO 20
            23 R(I)=D1*ER
               GO TO 20
            22 R(I)=CST100
       20 CONTINUE
     
    END SUBROUTINE
    

    SUBROUTINE MULPAC(ARC,OARC,PH,K,JJF)
          implicit none
!C     THIS SUBROUTINE MAKES PHASE CURVE CONTINUOUS.
!C     (MULTIPLE CHANNEL)

          INTEGER(4) :: K, JJF
          REAL(8), dimension(K) :: ARC, OARC, PH
         ! Locals
          INTEGER(4) :: I
          REAL(8) :: PI, PI2, DK
          PI=3.1415926535897932384626433_8
          PI2=PI+PI
          IF(JJF.NE.1) GO TO 20
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
          DO 9 I=1,K
                PH(I)=ARC(I)

               OARC(I)=ARC(I)
        9 CONTINUE
          GO TO 30

       20 DO 100 I=1,K
               DK=ARC(I)-OARC(I)
               IF(DK.GT.PI) GO TO 11
               IF(DK.LT.-PI) GO TO 12
               PH(I)=PH(I)+DK
               GO TO 10
            11 PH(I)=PH(I)+DK-PI2
               GO TO 10
            12 PH(I)=PH(I)+DK+PI2
            10 OARC(I)=ARC(I)
      100 CONTINUE
       30 CONTINUE
    
    END SUBROUTINE
    
    SUBROUTINE  MULMARF( ZS,N,ID,C,LAG,ZMEAN,ZVARI,SD1,AIC1,DIC1,IM,      &
                         AICM,SDM,NPR,JNDF,AF,EX,AIC,EI,BI,E,B,LMAX,AICS )
          implicit none  

!cc      PROGRAM  MULMAR                                                   
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE AND G.KITAGAWA...............................
!C.....PROGRAMMED BY G.KITAGAWA AND F.TADA...............................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.2.1.                                                    
!C     ___                  _                     __                     
!C     MULTIVARIATE CASE OF MINIMUM AIC METHOD OF AR MODEL FITTING.      
!C                                                                       
!C     THIS PROGRAM FITS A MULTI-VARIATE AUTOREGRESSIVE MODEL BY THE MINI
!C     AIC PROCEDURE.  ONLY THE POSSIBILITIES OF ZERO COEFFICIENTS AT THE
!C     BEGINNING AND END OF THE MODEL ARE CONSIDERED. THE LEAST SQUARES E
!C     OF THE PARAMETERS ARE OBTAINED BY THE HOUSEHOLDER TRANSFORMATION. 
!C     AIC IS DEFINED BY                                                 
!C                                                                       
!C            AIC  =  N * LOG( DET(SD) ) + 2 * (NUMBER OF PARAMETERS)    
!C                                                                       
!C       WHERE                                                           
!C           N:    NUMBER OF DATA,                                       
!C           SD:   ESTIMATE OF INNOVATION VARIANCE MATRIX                
!C           DET:  DETERMINANT,                                          
!C           K:    NUMBER OF FREE PARAMETERS.                            
!C                                                                       
!C                                                                       
!C       --------------------------------------------------------------- 
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM.  
!C           MRDATA                                                      
!C           MREDCT                                                      
!C           MARFIT                                                      
!C       --------------------------------------------------------------- 
!C       REFERENCE:                                                      
!C          G.KITAGAWA AND H.AKAIKE(1978), "A PROCEDURE FOR THE MODELING 
!C          OF NON-STATIONARY TIME SERIES.",  ANN. INST. STATIST. MATH., 
!C          30,B,351-363.                                                
!C       --------------------------------------------------------------- 
!C       INPUTS REQUIRED:                                                
!C           MT:    INPUT DEVICE FOR ORIGINAL DATA (MT=5; CARD READER)   
!C           LAG:   UPPER LIMIT OF AR-ORDER,  MUST BE LESS THAN 31       
!C                                                                       
!C          .....  FOLLOWING INPUTS ARE REQUIRED AT SUBROUTINE MREDCT  ..
!C           TITLE: SPECIFICATION OF DATA                                
!C           N:     DATA LENGTH,  MUST BE LESS THAN OR EQUAL TO 1000     
!C           ID:    DIMENSION OF DATA,  MUST BE LESS THAN 11             
!C                       < ID*(M+1) MUST BE LESS THAN 101 >              
!C           IFM:   CONTROL FOR INPUT                                    
!C           FORM:  INPUT DATA FORMAT SPECIFICATION STATEMENT            
!C                  -- FOR EXAMPLE --     (8F10.5)                       
!C          C(I):  CALIBRATION OF CHANNEL I (I=1,ID)                     
!C           Z:    ORIGINAL DATA; Z(K,I) (K=1,N) REPRESENTS THE I-TH CHAN
!C                 RECORD                                                

          INTEGER(4) :: N, ID, LAG,LMAX
          INTEGER(4), dimension(ID) :: IM,NPR
          INTEGER(4), dimension((LAG+1)*ID,ID) :: JNDF
          REAL(8), dimension(N,ID) :: ZS 
          REAL(8), dimension(ID) ::  C, ZMEAN, ZVARI, AICM, SDM, EX, AIC
          REAL(8), dimension(LAG+1,ID) :: SD1, AIC1 , DIC1
          REAL(8), dimension((LAG+1)*ID,ID) :: AF 
          REAL(8), dimension(ID,ID) ::  EI,E
          REAL(8), dimension(ID,ID,LAG) ::   BI,B 
          REAL(8) ::  AICS
          ! Locals
          INTEGER(4) :: MJ,MJ1,MJ2,MJ3,MJ4,KSW,IPR,N0,NMK
          REAL(8), dimension(N,ID) :: Z 
          REAL(8), dimension((LAG+1)*ID*2,(LAG+1)*ID) :: X 
          REAL(8), dimension(ID) ::  CV

                                                    
          MJ = N
          MJ1 = (LAG+1)*ID*2
          MJ2 = ID
          MJ3 = LAG
          MJ4 = (LAG+1)*ID
          KSW = 0                                                           
          IPR = 3                                                           
          IFG = 0


!C
!C     --  ORIGINAL DATA LOADING AND MEANS DELETION  --                  
!C                                                                       
                           
          CALL MRDATA( ZS,Z,N,ID,C,ZMEAN,ZVARI )

          N0 = 0                                                            
          NMK = N - LAG                                                     
!C                                                                       
!C     --  HOUSEHOLDER REDUCTION  --                                     
!C                                                                       

          X(1:MJ1,1:MJ4) = 0.0_8
          CALL  MREDCT( Z,NMK,N0,LAG,ID,MJ,MJ1,KSW,X )                    
!C                                                                       
!C     --  AR-MODEL FITTING (MAICE PROCEDURE)  --                        
!C                                                                       
                                   
          CALL MARFIT( X,NMK,ID,LAG,KSW,MJ1,MJ2,MJ3,MJ4,0,IPR,AIC1,SD1,DIC1,    &
                       AICM,SDM,IM,BI,EI,B,E,EX,CV,LMAX,AICS,JNDF,AF,NPR,AIC )
      
    END SUBROUTINE
                         

    SUBROUTINE MULNOSF(H,L,IP,SD,A,RS1,RS2,R)
          implicit none
!C     PROGRAM 5.3.3   MULTIPLE UNOISE
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES RELATIVE POWER CONTRIBUTIONS IN DIFFERENTIAL
!C     AND INTEGRATED FORM, ASSUMING THE ORTHOGONALITY BETWEEN NOISE
!C     SOURCES.
!C     THE PROGRAM OPERATES ON THE OUTPUT OF PROGRAM 5.3.2 FPEC WITH
!C     IL=0.
!C     THE RESULTS ARE GIVEN AT FREQUIENCIES I/(2*H).
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: MULNOSF

          INTEGER(4) :: H, L, IP
          REAL(8), dimension(IP,IP) :: SD, RS1
          REAL(8), dimension(L,IP,IP) :: A 
          REAL(8), dimension(IP,IP,H+1) :: RS2, R
          ! Locals          
          INTEGER(4) :: H1,I,J,JF,JJF,II,JJ,LG
          REAL(8)    :: GR, GI, CST0, CST1
          COMPLEX(8) ::  XDET
          REAL(8), dimension(L+1) :: G
          COMPLEX(8), dimension(IP,IP) :: X
!DIR$ ATTRIBUTES ALIGN : 64 :: G,X
          CST0=0.0_8
          CST1=1.0_8

          H1=H+1
!C     SD NORMALIZATION

          DO 101 I=1,IP
              
                  DO 100 J=1,IP

                       RS1(I,J)=SD(I,J)/DSQRT(SD(I,I)*SD(J,J))
              100 CONTINUE
      101 CONTINUE

          DO 10 JF=1,H1
                 JJF=JF
!C     AF COMPUTATION
                   DO 40 II=1,IP
                         DO 41 JJ=1,IP
                             IF(II.NE.JJ) GO TO 42
                             G(1)=CST1
                             GO TO 43
                          42 G(1)=CST0
                          43 DO 45 I=1,L
                                  I1=I+1

                                  G(I1)=-A(I,II,JJ)
                          45 CONTINUE

                                   LG=L

                                   CALL FGER1(G,GR,GI,LG,H,JJF)
                                   X(II,JJ)=DCMPLX(GR,GI)
                    41 CONTINUE
               40 CONTINUE

                 CALL INVDETC(X,XDET,IP)

                 CALL SUBNOS(X,SD,IP,RS2(1,1,JF),R(1,1,JF),IP)

       10 CONTINUE
    END SUBROUTINE
    
    
    SUBROUTINE MULRSPF(H,L,IP,K,SD,A,B,Y,CH) !GCC$ ATTRIBUTES ALIGNED(32) :: MULRSPF !GCC$ ATTRIBUTES HOT :: MULRSPF
          use omp_lib
          implicit none
!C
!C     PROGRAM 5.4.2   MULTIPLE RATIONAL SPECTRUM
!C-----------------------------------------------------------------------
!C      SUBROUTINE XYCTRX(X,Y,Z,MM,NN)
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES RATIONAL SPECTRUM FOR IP-DIMENSIONAL
!C     AR-MA PROCESS
!C     X(N)=A(1)X(N-1)+...+A(L)X(N-L)+E(N)+B(1)E(N-1)+...+B(K)E(N-K),
!C     WHERE E(N) IS A WHITE NOISE WITH ZERO MEAN VECTOR AND COVARIANCE
!C     MATRIX SD.
!C     OUTPUTS ARE SPECTRUM MATRIX P(I) AT FREQUENCIES I/(2*H)
!C     (I=0,1,...,H).
!C

          INTEGER(4) :: H, L, IP, K
          REAL(8), dimension(IP,IP)        ::  SD 
          REAL(8), dimension(L,IP,IP)      ::  A 
          REAL(8), dimension(K,IP,IP)      ::  B 
          REAL(8), dimension(IP,IP,H+1)    ::  CH
          COMPLEX(8), dimension(IP,IP,H+1) ::  Y
          ! Locals
      
          INTEGER :: H1,JF,JJF,I,J,II,JJ,LG,I1,IM1
          REAL(8) ::  CST0,  CST1, GR, GI, RYI, RYJ, RRYIJ, RIYIJ
          COMPLEX(8) :: XDET
          REAL(8), dimension(L+K+1) :: G 
          COMPLEX(8), dimension(IP,IP)  :: X, Z
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: G,X,Z
#endif
          CST0=0.0_8
          CST1=1.0_8

          H1=H+1

          DO 10 JF=1,H1
                  JJF=JF

                  DO 632 II=1,IP
!$OMP SIMD
                     DO 631 JJ=1,IP

                         Y(II,JJ,JF)=SD(II,JJ)
                631 CONTINUE
             632 CONTINUE
               IF(K.GT.0) GO TO 100

               DO 111 II=1,IP
!$OMP SIMD
                     DO 110 JJ=1,IP

                            Z(II,JJ)=SD(II,JJ)
                110 CONTINUE
          111 CONTINUE
              GO TO 224
!C     BF COMPUTATION
          100 DO 20 II=1,IP
                      DO 21 JJ=1,IP
                         IF(II.NE.JJ) GO TO 22
                         G(1)=CST1
                         GO TO 23
                      22 G(1)=CST0
                      23 DO 25 I=1,K
                               I1=I+1

                               G(I1)=B(I,II,JJ)
                     25 CONTINUE

                        LG=K

                        CALL FGER1(G,GR,GI,LG,H,JJF)
                        X(II,JJ)=DCMPLX(GR,GI)
                  21 CONTINUE
            20 CONTINUE
!C     BF*SD*CONJG(BF') COMPUTATION

               CALL XYCTRX(X,Y(1,1,JF),Z,IP,IP)
           224 IF(L.GT.0) GO TO 120
               DO 131 II=1,IP
!$OMP SIMD
                      DO 130 JJ=1,IP

                           Y(II,JJ,JF)=Z(II,JJ)
                   130 CONTINUE
           131 CONTINUE
               GO TO 244
!C     AF COMPUTATION
           120 DO 40 II=1,IP
                   DO 41 JJ=1,IP
                        IF(II.NE.JJ) GO TO 42
                        G(1)=CST1
                        GO TO 43
42                      G(1)=CST0
!$OMP SIMD
                     43 DO 45 I=1,L
                                I1=I+1

                                G(I1)=-A(I,II,JJ)
                     45 CONTINUE

                        LG=L

                        CALL FGER1(G,GR,GI,LG,H,JJF)
                        X(II,JJ)=DCMPLX(GR,GI)
                41 CONTINUE
            40 CONTINUE
!C     INVERSE OF AF (COMPLEX) COMPUTATION

               CALL INVDETC(X,XDET,IP)
!C     (INVERSE OF AF)*(BF*SD*CONJG(BF'))*CONJG((INVERSE OF AF)')
!C     COMPUTATION

               CALL XYCTRX(X,Z,Y(1,1,JF),IP,IP)
!C!     SIMPLE COHERENCE COMPUTATION

            244 CH(1,1,JF)=CST1

                IF(IP.EQ.1) GO TO 10
                DO 50 II=2,IP
                      IM1=II-1

                      RYI=DREAL(Y(II,II,JF))
                      DO 51 JJ=1,IM1

                           RYJ=DREAL(Y(JJ,JJ,JF))
                           RRYIJ=DREAL(Y(II,JJ,JF))
                           RIYIJ=DIMAG(Y(II,JJ,JF))
                           CH(II,JJ,JF)=(RRYIJ**2+RIYIJ**2)/(RYI*RYJ)

                           CH(JJ,II,JF)=CH(II,JJ,JF)
                  51 CONTINUE
                     CH(II,II,JF)=CST1
            50 CONTINUE
!C     RATIONAL SPECTRUM AND SIMPLE COHERENCE PRINT OUT

       10 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE XYCTRX(X,Y,Z,MM,NN) !GCC$ ATTRIBUTES ALIGNED(32) :: XYCTRX !GCC$ ATTRIBUTES HOT :: XYCTRX
          use omp_lib
          implicit none
!C     Z=X*Y*CONJG(X')
!C     Y,Z: HERMITIAN
!C     (UPPER LEFT MM X MM OF Z)=(UPPER LEFT MM X NN OF X)*(UPPER LEFT
!C     NN X NN OF Y)*CONJG((UPPER LEFT MM X NN OF X)')
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     (MJ2,MJ2): ABSOLUTE DIMENSION OF Y IN THE MAIN ROUTINE
!C     (MJ1,MJ1): ABSOLUTE DIMENSION OF Z IN THE MAIN ROUTINE
!C     MM,NN: SHOULD BE LESS THAN 11.

          INTEGER(4) :: MM, NN
          COMPLEX(8), dimension(MM,NN) ::  X 
          COMPLEX(8), dimension(NN,NN) ::  Y 
          COMPLEX(8), dimension(MM,MM) ::  Z
          ! Locals
          INTEGER(4) ::  I,J,K
          REAL(8)    ::  CST0
          COMPLEX(8) ::  XSUM
          COMPLEX(8), dimension(MM,NN) ::  Y1
          CST0=0.0_8
          DO 10 I=1,MM

                 DO 11 J=1,NN
                    XSUM=CST0
!$OMP SIMD REDUCTION(+:XSUM)
                       DO 12 K=1,NN

                             XSUM=XSUM+X(I,K)*Y(K,J)
                   12 CONTINUE

                      Y1(I,J)=XSUM
             11 CONTINUE
       10 CONTINUE
          DO 110 I=1,MM

                 DO 111 J=1,I
                    XSUM=CST0
!$OMP SIMD REDUCTION(+:XSUM)                    
                        DO 112 K=1,NN

                             XSUM=XSUM+Y1(I,K)*DCONJG(X(J,K))
                    112 CONTINUE
                       Z(I,J)=XSUM

                       Z(J,I)=DCONJG(Z(I,J))
            111 CONTINUE
      110 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE MULSPEF(N,K,LAGH1,LAGH3,CV,P1,P2,PS,PCH1,PCH2) !GCC$ ATTRIBUTES HOT :: MULSPEF !GCC$ ATTRIBUTES ALIGNED(32) :: MULSPEF
          use omp_lib
          implicit none
!C     PROGRAM 5.2.2   MULTIPLE SPECTRUM
!C-----------------------------------------------------------------------
!C      SUBROUTINE MULSPEF(N,K,LAGH1,LAGH3,IR0,IR1,IR2,IC0,IC1,IC2,
!C      SUBROUTINE CROSSP(FC,FS,P1,P2,LAGH1,A,LA1)
!C      SUBROUTINE ECORSI(FS,LAGH1,FS1,LAGSHF,LA1)
!C      SUBROUTINE FGERSI(G,LGP1,FS,LF1)
!C      SUBROUTINE SIMCOH(P1,P2,C,S,P3,LAGH1)
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES MULTIPLE SPECTRUM ESTIMATES FROM THE OUTPUT
!C     OF PROGRAM 5.1.2 MULCOR, USING WINDOWS W1 AND W2.
!C     ONLY ONE CARD OF LAGH(MAXIMUM LAG OF COVARIANCES TO BE USED FOR
!C     SPECTRUM COMPUTATION) SHOULD BE ADDED ON TOP OF THE OUTPUT OF
!C     PROGRAM 5.1.2 MULCOR TO FORM THE INPUT TO THIS PROGRAM.
!C     IN THE CARD OUTPUT OF SPECTRUM MATRIX ON AND LOWER DIAGONAL ARE
!C     REAL PARTS AND UPPER DIAGONAL ARE IMAGINARY PARTS OF ON AND LOWER
!C     DIAGONAL SPECTRAL ELEMENTS.
!C
          INTEGER(4) :: N, K, LAGH1, LAGH3
          REAL(8), dimension(LAGH3,K,K) ::   CV 
          REAL(8), dimension(LAGH1,K,K) ::   P1, P2,PCH1,PCH2
          REAL(8), dimension(LAGH1,K)   ::   PS
          ! Locals
          INTEGER(4) :: MLA1,MLA2,LAG2,II,I,J,II1,I1,I2,IM1,JJ,ISW,IWD, &
                           JJ1
          REAL(8) :: CT5
          REAL(8), dimension(LAGH1) :: C, S, G, FC, FS
          REAL(8), dimension(LAGH1*2*K) :: P
          REAL(8), dimension(2) ::  A1 
          REAL(8), dimension(3) ::  A2
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: C,S,G,FC,FS,P
#endif
          MLA1=2
          A1(1)=0.5_R64P
          A1(2)=0.25_R64P
!C     WINDOW W2 DEFINITION
          MLA2=3
          A2(1)=0.625_R64P
          A2(2)=0.25_R64P
          A2(3)=-0.0625_R64P

          CT5=0.5_R64P
          LAG2=LAGH1+LAGH1
          DO 10 II=1,K
!$OMP SIMD
                DO 15 I=1,LAGH1

                     C(I)=CV(I,II,II)
15                   CONTINUE
#if defined __ICC
!DIR$ VECTOR ALIGNED
                     !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
                DO 20 I=1,LAGH1

                      G(I)=C(I)+C(I)
             20 CONTINUE
                G(1)=CT5*G(1)
                G(LAGH1)=CT5*G(LAGH1)
!C     F-COS TRANSFORMATION
                CALL FGERCO(G,LAGH1,FC,LAGH1)
!C     SPECTRUM SMOOTHING BY WINDOW W1

                CALL AUSP(FC,P1(1,II,II),LAGH1,A1,MLA1)
!C     SPECTRUM SMOOTHING BY WINDOW W2

                CALL AUSP(FC,P2(1,II,II),LAGH1,A2,MLA2)
!C     TEST STATISTICS COMPUTATION

                CALL SIGNIF(P1(1,II,II),P2(1,II,II),PS(1,II),LAGH1,N)

                II1=(II-1)*LAG2
                DO 21 I=1,LAGH1
                      I1=II1+I
                      I2=I1+LAGH1

                      P(I1)=P1(I,II,II)

                      P(I2)=P2(I,II,II)
            21 CONTINUE
               IF(II.EQ.1) GO TO 10
!C     CROSS COVARIANCE INPUT
               IM1=II-1
               DO 11 JJ=1,IM1
!$OMP SIMD
                    DO 25 I=1,LAGH1
                         C(I)=CV(I,II,JJ)

                         S(I)=CV(I,JJ,II)
25                  CONTINUE
                         !C     F-COS TRANSFORMATION
#if defined __ICC
!DIR$ VECTOR ALIGNED
                         !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif
                        DO 30 I=1,LAGH1

                          G(I)=C(I)+S(I)
                30 CONTINUE
                   G(1)=CT5*G(1)
                   G(LAGH1)=CT5*G(LAGH1)
                   CALL FGERCO(G,LAGH1,FC,LAGH1)
                   !C     F-SIN TRANSFORMATION
#if defined __ICC
!DIR$ VECTOR ALIGNED
                   !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                         !$OMP SIMD
#endif                   
                   DO 31 I=1,LAGH1

                         G(I)=S(I)-C(I)
                31 CONTINUE
                   G(1)=CT5*G(1)
                   G(LAGH1)=CT5*G(LAGH1)
                   CALL FGERSI(G,LAGH1,FS,LAGH1)
!C     SMOOTHING BY WINDOW W1
                   ISW=1
                   IWD=0

                   CALL CROSSP(FC,FS,P1(1,II,JJ),P1(1,JJ,II),LAGH1,A1,MLA1)
!C     SIMPLE COHERENCE COMPUTATION
                33 II1=(II-1)*LAG2+IWD
                   JJ1=(JJ-1)*LAG2+IWD
                   DO 32 I=1,LAGH1
                        I1=II1+I
                        I2=JJ1+I
                        C(I)=P(I1)

                        S(I)=P(I2)
                32 CONTINUE

                   IF (ISW.EQ.1) THEN
                         CALL SIMCOH(P1(1,II,JJ),P1(1,JJ,II),C,S,PCH1(1,II,JJ),LAGH1)
                   ELSE
                         CALL SIMCOH(P2(1,II,JJ),P2(1,JJ,II),C,S,PCH2(1,II,JJ),LAGH1)
                   END IF
!C     CROSS SPECTRUM AND SIMPLE COHERENCE   PRINT OUT

                   IF(ISW.LT.0) GO TO 11
!C     CROSS SPECTRUM STORE (DISK)

                       ISW=-1
                       IWD=LAGH1

                       CALL CROSSP(FC,FS,P2(1,II,JJ),P2(1,JJ,II),LAGH1,A2,MLA2)
                       GO TO 33
              11 CONTINUE
       10 CONTINUE
    END SUBROUTINE
    

   

    SUBROUTINE CROSSP(FC,FS,P1,P2,LAGH1,A,LA1) !GCC$ ATTRIBUTES HOT :: CROSSP !GCC$ ATTRIBUTES ALIGNED(32) ::  CROSSP
          implicit none
!C     THIS SUBROUTINE COMPUTES SMOOTHED CROSS SPECTRUM.
!C     FC,FS: OUTPUTS OF FGERCO AND FGERSI
!C     P1,P2: REAL AND IMAGINARY PART OF SMOOTHED CROSS SPECTRUM
!C     LAGH1: DIMENSION OF FC, FS AND PI (I=1,2)
!C!     A: SMOOTHING COEFFICIENTS
!C     LA1: DIMENSION OF A (LESS THAN 11)

          INTEGER(4) :: LAGH1, LA1
          REAL(8), dimension(LAGH1)  :: FC, FS, P1, P2 
          REAL(8), dimension(LA1)    :: A
          ! Locals
          INTEGER(4) :: LA, LAGSHF,
          REAL(8), dimension(521) :: FC1, FS1
          LA=LA1-1
          LAGSHF=LAGH1+2*LA
!C     FC SHIFT-RIGHT BY LA FOR END CORRECTION
          CALL ECORCO(FC,LAGH1,FC1,LAGSHF,LA1)
!C     REAL PART SMOOTHING
          CALL SMOSPE(FC1,LAGSHF,A,LA1,P1,LAGH1)
!C     FS SHIFT-RIGHT BY LA FOR END CORRECTION
          CALL ECORSI(FS,LAGH1,FS1,LAGSHF,LA1)
!C     IMAGINARY PART SMOOTHING
          CALL SMOSPE(FS1,LAGSHF,A,LA1,P2,LAGH1)
     
    END SUBROUTINE

    SUBROUTINE ECORSI(FS,LAGH1,FS1,LAGSHF,LA1) !GCC$ ATTRIBUTES HOT :: ECORSI !GCC$ ATTRIBUTES ALIGNED(32) :: ECORSI
          implicit none
!C     FS SHIFT-RIGHT BY LA FOR IMAGINARY PART END CORRECTION

          INTEGER(4):: LAGH1, LAGSHF, LA1
          REAL(8), dimension(LAGH1)  :: FS 
          REAL(8), dimension(LAGSHF) :: FS1
          ! Locals
          INTEGER(4) :: LAGH2,LA,I,I1,I2,LA2,I3,I4,LA1
          LAGH2=LAGH1+1
          LA=LA1-1
          DO 100 I=1,LAGH1
                 I1=LAGH2-I
                 I2=I1+LA

                 FS1(I2)=FS(I1)
     100 CONTINUE
         LA2=LAGH1+LA
         DO 110 I=1,LA
               I1=LA1-I
               I2=LA1+I
               I3=LA2-I
               I4=LA2+I
               FS1(I1)=-FS1(I2)

               FS1(I4)=-FS1(I3)
      110 CONTINUE
    
    END SUBROUTINE
    

    SUBROUTINE FGERSI(G,LGP1,FS,LF1) !GCC$ ATTRIBUTES HOT :: FGERSI !GCC$ ATTRIBUTES ALIGNED(32) :: FGERSI
          
          implicit none
!C     FOURIER TRANSFORM (GOERTZEL METHOD)
!C     THIS SUBROUTINE COMPUTES FOURIER TRANSFORM OF G(I),I=0,1,...,LG AT
!C     FREQUENCIES K/(2*LF),K=0,1,...,LF AND RETURNS SIN TRANSFORM IN
!C     FS(K).

          INTEGER(4) :: LGP1 ,LF1
          REAL(8), dimension(LGP1) :: G 
          REAL(8), dimension(LF1) ::  FS
          ! Locals
          INTEGER(4) :: LG,LF,LG3,LG4,I,I2,K
          REAL(8) :: T, PI, ALF, AK, TK, CK, SK, CK2, UM0, UM1, UM2
          LG=LGP1-1
          LF=LF1-1
!C     REVERSAL OF G(I),I=1,...,LGP1 INTO G(LG3-I)   LG3=LGP1+1
          IF(LGP1.LE.1) GO TO 110
          LG3=LGP1+1
          LG4=LGP1/2
          DO 100 I=1,LG4
                 I2=LG3-I
                 T=G(I)
                 G(I)=G(I2)

                 G(I2)=T
      100 CONTINUE
      110 PI=3.1415926536_8
          ALF=LF
          T=PI/ALF
          DO 10 K=1,LF1
                 AK=K-1
                 TK=T*AK
                 CK=DCOS(TK)
                 SK=DSIN(TK)
                 CK2=CK+CK
                 UM2=0.0D-00
                 UM1=0.0D-00
                 IF(LG.EQ.0) GO TO 12
                 DO 11 I=1,LG
                        UM0=CK2*UM1-UM2+G(I)
                        UM2=UM1
                        UM1=UM0
              11 CONTINUE
              12 FS(K)=SK*UM1
       10 CONTINUE
      
    END SUBROUTINE
    

    SUBROUTINE SIMCOH(P1,P2,C,S,P3,LAGH1) !GCC$ ATTRIBUTES HOT :: SIMCOH !GCC$ ATTRIBUTES ALIGNED(32) :: SIMCOH
          use omp_lib
          implicit none
!C     THIS SUBROUTINE COMPUTES SIMPLE COHERENCE.

          INTEGER(4) :: LAGH1
          REAL(8), dimension(LAGH1) :: P1, P2, C, S, P3
          ! Locals
          INTEGER(4) :: I
!$OMP SIMD
          DO 10 I=1,LAGH1

                 P3(I)=(P1(I)**2+P2(I)**2)/(C(I)*S(I))
       10 CONTINUE
   
    END SUBROUTINE
    
    SUBROUTINE NONSTF(N,ISTP,DATA0,NM,LAGH,JP0,COEF0,VA0,AIC0,DAIC21,  &
         DAIC,K01,KOUNT2,SXX) !GCC$ ATTRIBUTES ALIGNED(32) :: NONSTF !GCC$ ATTRIBUTES HOT :: NONSTF
          use omp_lib
          implicit none        

!cc      PROGRAM NONST
!C     PROGRAM 74.4.1. NON-STATIONARY POWER SPECTRUM ANALYSIS
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY T. OZAKI, THE INSTITUTE OF STATISTICAL MATHEMATICS,
!C     ** PROGRAMMED BY T. OZAKI, THE INSTITUTE OF STATISTICAL MATHEMATIC
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(2
!C         BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C         NO.6 MARCH 1976, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** FOR THE BASIC THEORY SEE "ON THE FITTING OF NON-STATIONARY
!C         AUTOREGRESSIVE MODELS IN TIME SERIES ANALYSIS" BY T. OZAKI AND
!C         IN "PROC. 8TH HAWAII INTERNATIONAL CONFERENCE ON SYSTEM SCIENCE
!C         WESTERN PERIODICALS NORTH HOLLYWOOD, CALIF., 1975
!C-----------------------------------------------------------------------
!C     THIS PROGRAM LOCALLY FITS AUTOREGRESSIVE MODELS TO NON-STATIONARY
!C     TIME SERIES BY AIC CRITERION.
!C     POWER SPECTRA FOR STATIONARY SPANS ARE GRAPHICALLY PRINTED OUT.
!C     THE FOLLOWING INPUTS ARE REQUIRED;
!C         N: LENGTH OF DATA
!C         ISTP : LENGTH OF THE BASIC LOCAL SPAN
!C         DFORM : INPUT FORMAT SPECIFICATION IN ONE CARD, FOR EXAMPLE,'(8
!C         (X(I),I=1,N) : ORIGINAL DATA.
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: NONSTF
!C
!C     NSG : NUMBER OF SEGMENTS OF FREQUENCY AXIS +1
          INTEGER(4),   PARAMETER :: NSG=121

          INTEGER(4) :: N, ISTP, NM, LAGH
          INTEGER(4), dimension(NM) :: JP0, K01, KOUNT2
          REAL(8), dimension(N)       :: DATA0 
          REAL(8), dimension(LAGH,NM) :: COEF0 
          REAL(8), dimension(NM)     :: VA0,AIC0,DAIC21,DAIC
          REAL(8), dimension(NSG,NM) :: SXX
          ! Locals
          INTEGER(4) :: LAGH1,KOUNT0,KOUNT1,ML1,I,IP0,J,IK1,IK5,IK0, &
                           NSG1,NML,JJ,NI,II
          REAL(8) ::   AISTP, AIP0, AIP1, AIP2, CST2, CST4, ANI, ANJ, STP,   &
                          VA1, VA2, AIC1, AIC2, XMEAN, Z
          INTEGER(4), dimension(5) :: IDX
          REAL(8), dimension(LAGH+1) :: ACV0, ACV1, ACV2, CN
          REAL(8), dimension(LAGH)   :: COEF1, COEF2 
          REAL(8), dimension(N)      :: DATA1
              

          LAGH1=LAGH+1
          KOUNT0=0
          KOUNT1=0

          DAIC21(1)=0
          DAIC(1)=0

!C     ML : HIGHEST ALLOWABLE ORDER OF AUTOREGRESSIVE MODEL
          ML1 = LAGH

          KOUNT2(1)=ISTP
          KOUNT1=KOUNT2(1)
#if defined __ICC
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
          DO 50 I=1,ISTP

                 DATA1(I)=DATA0(I)
    50    CONTINUE

          CALL AUTCORF(DATA1,ISTP,ACV0,CN,LAGH1,XMEAN)
          CALL SICP(ACV0,COEF0,VA0(1),ML1,ISTP,IP0)
          AISTP=ISTP
          AIP0=IP0
          CST2=2.0_R64P

          AIC0(1)=AISTP*(DLOG(VA0(1)))+CST2*(AIP0+CST2)
          NI=ISTP

          JP0(1)=IP0

          IDX(1)=1
          DO 60 I=1,4
                J=I+1

                IDX(J)=IDX(I)+1
    60    CONTINUE
    70    IK1=IDX(1)
          IK5=IDX(5)
          IK0=IK5-IP0
          IF(IK0.GE.0) GO TO 90

          DO 80 I=1,5

               IDX(I)=IDX(I)+5
    80    CONTINUE
          GO TO 70
    90    IK0=5-IK0

          K01(1)=KOUNT0+1

          NSG1=NSG-1
          CALL NRASPE(VA0(1),COEF0(1,1),Z,IP0,0,NSG1,SXX)

          NML=1
 100      J=NI+1
          JJ=J+ISTP

          IF((KOUNT2(NML)+ISTP).GT.N) GOTO 999
          KOUNT2(NML+1)=KOUNT2(NML)+ISTP
          DO 200 I=1,ISTP
                  II=KOUNT1+I

                 DATA1(I)=DATA0(II)
    200   CONTINUE
          NJ=NI+ISTP
          ANJ=NJ
          ANI=NI
          STP=ISTP

          CALL AUTCORF(DATA1,ISTP,ACV2,CN,LAGH1,XMEAN)
          CALL SICP(ACV2,COEF2,VA2,ML1,ISTP,IP2)
          AIP0=IP0
          AIP2=IP2
          CST4=4.0_R64P

          AIC2=ANI*DLOG(VA0(NML))+STP*DLOG(VA2)+CST2*(AIP0+AIP2+CST4)
          DO 500 J=1,NJ
                 JJ=KOUNT0+J

                 DATA1(J)=DATA0(JJ)
    500   CONTINUE

          CALL AUTCORF(DATA1,NJ,ACV1,CN,LAGH1,XMEAN)
          CALL SICP(ACV1,COEF1,VA1,ML1,NJ,IP1)
          AIP1=IP1
          AIC1=ANJ*DLOG(VA1)+CST2*(AIP1+CST2)
          NML=NML+1
          DAIC(NML)=AIC2-AIC1
          IF(AIC2.LT.AIC1) GOTO 800
          NI=NJ
          IP0=IP1

          VA0(NML)=VA1
          AIC0(NML)=AIC1
!$OMP SIMD
          DO 700 I=1,IP0

                 COEF0(I,NML)=COEF1(I)
700              CONTINUE
!$OMP SIMD
          DO 750 I=1,LAGH

                ACV0(I)=ACV1(I)
    750   CONTINUE

          JP0(NML)=IP0

          IDX(1)=1
          DO 760 I=1,4
                 J=I+1

                 IDX(J)=IDX(I)+1
    760   CONTINUE
    770   IK1=IDX(1)
          IK5=IDX(5)
          IK0=IK5-IP0
          IF(IK0.GE.0) GO TO 790

          DO 780 I=1,5

                  IDX(I)=IDX(I)+5
     780   CONTINUE
           GO TO 770
     790   IK0=5-IK0

           DAIC21(NML)=DAIC(NML)
           DAIC(NML)=DAIC(NML)/ANJ

           KOUNT1=KOUNT2(NML)
           K01(NML)=KOUNT0+1

           CALL NRASPE(VA0(NML),COEF0(1,NML),Z,IP0,0,NSG1,SXX(1,NML))

           GOTO 100
800        NI=ISTP
           IP0=IP2

           VA0(NML)=VA2
           AIC0(NML)=AIC2
!$OMP SIMD
           DO 1000 I=1,IP0

                  COEF0(I,NML)=COEF2(I)
1000              CONTINUE
!$OMP SIMD
           DO 1050 I=1,LAGH

                 ACV0(I)=ACV2(I)
     1050  CONTINUE

           JP0(NML)=IP0

           IDX(1)=1
           DO 1060 I=1,4
                    J=I+1

                    IDX(J)=IDX(I)+1
     1060  CONTINUE
     1070  IK1=IDX(1)
           IK5=IDX(5)
           IK0=IK5-IP0
           IF(IK0.GE.0) GO TO 1090

           DO 1080 I=1,5

                   IDX(I)=IDX(I)+5
     1080  CONTINUE
           GO TO 1070
     1090  IK0=5-IK0

           DAIC21(NML)=DAIC(NML)
           DAIC(NML)=DAIC(NML)/ANJ

           KOUNT0=KOUNT1
           KOUNT1=KOUNT2(NML)
           K01(NML)=KOUNT0+1

           CALL NRASPE(VA0(NML),COEF0(1,NML),Z,IP0,0,NSG1,SXX(1,NML))

           GOTO 100
     999   CONTINUE
    END SUBROUTINE
                          


    SUBROUTINE SICP(CXX,COEF,OSD,L1,N,MO) !GCC$ ATTRIBUTES HOT :: SICP !GCC$ ATTRIBUTES ALIGNED(32) :: SICP
          use omp_lib
          implicit none
!C     THIS SUBROUTINE FITS AUTOREGRESSIVE MODELS
!C     X(N)=A(1)X(N-1)+...+A(M)X(N-M)+E(N)
!C     OF SUCCESSIVELY INCREASING ORDER UP TO L(=L1-1).
!C     INPUT:
!C     CXX(I),I=0,L1; AUTOCOVARIANCE SEQUENCE
!C     L1; L1=L+1, L IS THE UPPER LIMIT OF THE MODEL ORDER
!C     N; LENGTH OF ORIGINAL DATA
!C     OUT PUT:
!C     MO; ORDER OF AR
!C     OSD; INNOVATION VARIANCE
!C     COEF; AR-COEFFICIENTS
    
          INTEGER(4) :: L1, N, MO
          REAL(8), dimension(L1) :: CXX, COEF 
          REAL(8) ::  OSD
          ! Locals
          INTEGER(4) :: L,I,M,MP1,LM,IM,MP1
          REAL(8) :: CST1, CST2, SD, AN, OAIC, SE, D, D2, &
                        AM, DLSD, AIC
          REAL(8), dimension(L1-1) :: A,B 
          CST1=1.0_8
          CST2=2.0_8
          L=L1-1
          SD=CXX(1)
          AN=N
          OAIC=AN*DLOG(SD)
          OSD=SD
          MO=0
          SE=CXX(2)
!C     ITERATION START
          DO 400 M=1,L
                 MP1=M+1
                 D=SE/SD
                 A(M)=D
                 D2=D*D
                 SD=(CST1-D2)*SD
                 AM=M
                 AIC=AN*DLOG(SD)+CST2*AM
                 DLSD=DLOG(SD)
                 IF(M.EQ.1) GO TO 410
!C
!C     A(I) COMPUTATION
                 LM=M-1
!$OMP SIMD
                 DO 420 I=1,LM

                       A(I)=A(I)-D*B(I)
420                    CONTINUE
!OMP SIMD
             410 DO 421 I=1,M
                        IM=MP1-I

                        B(I)=A(IM)
             421 CONTINUE

                 IF(OAIC.LT.AIC) GO TO 440
                 OAIC=AIC
                 OSD=SD
                 MO=M
!OMP SIMD LINEAR(I:1)
                 DO 430 I=1,M

                        COEF(I)=A(I)
             430 CONTINUE
             440 IF(M.EQ.L) GO TO 400
                        SE=CXX(M+2)
!$OMP SIMD REDUCTION(-:SE)
                 DO 441 I=1,M

                        SE=SE-B(I)*CXX(I+1)
             441 CONTINUE
      400 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE OPTDESF(IR,L,NS,M,Q1,R,GR1,A,B,GI) 
          implicit none
!cc      PROGRAM OPTDES
!C     PROGRAM 5.5.1   OPTIMAL CONTROLLER DESIGN
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM COMPUTES OPTIMAL CONTROLLER GAIN MATRIX FOR
!C     A QUADRATIC CRITERION DEFINED BY TWO POSITIVE DEFINITE MATRICES
!C     Q1 AND R.
!C     THE OUTPUT OF FPEC COMPUTATION IS USED.
!C     THE FIRST IR VARIABLES SHOULD BE CONTROLLED VARIABLES.
!C     IR: NUMBER OF CONTROLLED VARIABLES
!C     L: NUMBER OF MANIPULATED VARIABLES
!C     NS: NUMBER OF D.P. STAGES
!C     N: LENGTH OF ORIGINAL DATA
!C     M: ORDER OF THE MODEL WHICH GIVES THE MINIMUM OF FPEC
!C     MATRIX P: MI OR P
!C     GI: GAIN
!C
!cc      !DEC$ ATTRIBUTES DLLEXPORT :: OPTDESF

          INTEGER(4) :: IR, L, NS, M
          REAL(8), dimension(IR,IR)   :: Q1,GR1
          REAL(8), dimension(L,L)     :: R          
          REAL(8), dimension(M*IR,IR) :: A 
          REAL(8), dimension(M*IR,L)  :: B 
          REAL(8), dimension(L,M*IR)  ::  GI
          ! Locals
          INTEGER(4) :: I,J,MR,MR1,MM1,MM2,IBA,INS,IM1,IIB,II0,JJC,JJ,I1,I2
          REAL(8)    :: XDET,CST0                 
          REAL(8), dimension(M*IR,IR)   ::  GIT
          REAL(8), dimension(L,L)       ::  GL
          REAL(8), dimension(L,M*IR)    ::  G3 
          REAL(8), dimension(IR,IR)     ::  GR
          REAL(8), dimension(L,IR)      ::  GLR 
          REAL(8), dimension(M*IR,M*IR) ::  P 
          REAL(8), dimension(M*IR)      ::  D
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 ::  GIT,GL,G3,GR,GLR,P,D
#endif
          CST0=0.0_8

          DO 6 I=1,IR
               DO 5 J=1,IR
                   GR(I,J)=GR1(I,J)
             5 CONTINUE
        6 CONTINUE

          MR=M*IR

          MR1=MR-IR
          MM1=M-1
          MM2=M-2
          IBA=MM2*IR
!C     INITIAL P COMPUTATION

          DO 132 I=1,MR
                 DO 130 J=1,MR

                          P(I,J)=CST0
             130 CONTINUE
      132 CONTINUE

          DO 133 I=1,IR
                 DO 131 J=1,IR

                       P(I,J)=Q1(I,J)
             131 CONTINUE
      133 CONTINUE

          DO 10 INS=1,NS
!C     GI=(TRANSPOSE OF B)*P COMPUTATION
                     CALL TRAMDL(B,P,GI,MR,L,MR)
!C     GL=GI*B COMPUTATION

                     CALL MULTRB(GI,B,GL,L,MR)

                     DO 21 I=1,L
                         DO 20 J=1,I

                              GL(J,I)=GL(I,J)
                     20 CONTINUE
                 21 CONTINUE
!C     GL=GL+R COMPUTATION

                    CALL MATADL(GL,R,L,L)
!C     GL=(INVERSE OF GL) COMPUTATION

                    CALL INVDET(GL,XDET,L,L)
!C     G3=GL*GI COMPUTATION

                    CALL MULPLY(GL,GI,G3,L,L,MR)
!C     D= DIAGONAL OF P
                    DO 30 I=1,MR

                             D(I)=P(I,I)
                30 CONTINUE
!C     INTERMEDIATE MATRIX MI COMPUTATION
!C     P=(TRANSPOSE OF GI)*G3 (LOWER TRIANGLE) COMPUTATION
                   CALL MULTRL(GI,G3,P,L,MR)
                   DO 40 I=1,MR

                            P(I,I)=D(I)-P(I,I)
                40 CONTINUE
                   IF(MR.EQ.1) GO TO 260

                   DO 42 I=2,MR
                         IM1=I-1
                         DO 41 J=1,IM1
                              P(I,J)=P(J,I)-P(I,J)
                              P(J,I)=P(I,J)
                      41 CONTINUE
               42 CONTINUE
!C     GIT=MI*A COMPUTATION

             260 CALL MULPLY(P,A,GIT,MR,MR,IR)
!C     GR=(TRANSPOSE OF A)*GIT COMPUTATION

                 CALL MULTRL(A,GIT,GR,MR,IR)

                 DO 151 I=1,IR
                        DO 150 J=1,I

                                GR(J,I)=GR(I,J)
                     150 CONTINUE
             151 CONTINUE
!C     GR=GR+Q1 COMPUTATION

                 CALL MATADL(GR,Q1,IR,IR)
!C     NEW P ARRANGEMENT
                 IF(M.EQ.1) GO TO 261
                 IIB=IBA
                 DO 50 II=1,MM1
                       II0=M-II
                       JJC=IIB
                       DO 51 JJ=1,II0
                            DO 52 I=1,IR
                                 I1=IIB+I
                                 I2=I1+IR
!CX      DO 52 J=1,IR
                                 DO 53 J=1,IR
                                       J1=JJC+J
                                       J2=J1+IR
                                       P(I2,J2)=P(I1,J1)

                                       P(J2,I2)=P(I2,J2)
                              53 CONTINUE
                        52 CONTINUE

                           JJC=JJC-IR
                  51 CONTINUE

                     IIB=IIB-IR
             50 CONTINUE
                DO 57 I=1,MR1
                        I1=I+IR
!cxx      DO 57 J=1,IR
                        DO 58 J=1,IR
                              P(I1,J)=GIT(I,J)

                              P(J,I1)=P(I1,J)
                     58 CONTINUE
             57 CONTINUE

            261 DO 55 I=1,IR
                      DO 56 J=1,I
                           P(I,J)=GR(I,J)
!cxx   56 P(J,I)=P(I,J)
                           P(J,I)=P(I,J)
                   56 CONTINUE
              55 CONTINUE
       10 CONTINUE

          CALL MULPLY(G3,A,GLR,L,MR,IR)

          DO 112 I=1,L
                  DO 110 J=1,IR

                          GI(I,J)=-GLR(I,J)
              110 CONTINUE
      112 CONTINUE
          IF(M.EQ.1) GO TO 262

          DO 113 I=1,L
                 DO 111 J=1,MR1
                       J1=IR+J

                       GI(I,J1)=-G3(I,J)
            111 CONTINUE
       113 CONTINUE
!C     GAIN PRINT AND PUNCH OUT
       262 CONTINUE
    END SUBROUTINE
    

    SUBROUTINE MULTRB(X,Y,Z,MM,NN) !GCC$ ATTRIBUTES HOT :: MULTRB !GCC$ ATTRIBUTES ALIGNED(32) :: MULTRB
          use omp_lib
          implicit none
!C     Z=X*Y
!C     Z: SYMMETRIC
!C     (LOWER TRIANGLE OF UPPER LEFT MM X MM OF Z)=(UPPER LEFT MM X NN OF
!C     X)*(UPPER LEFT NN X MM OF Y)
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X IN THE MAIN ROUTINE
!C     (MJ2,MJ1): ABSOLUTE DIMENSION OF Y IN THE MAIN ROUTINE
!C     (MJ1,MJ1): ABSOLUTE DIMENSION OF Z IN THE MAIN ROUTINE

          INTEGER(4) :: MM, NN
          REAL(8), dimension(MM,NN) :: X 
          REAL(8), dimension(NN,MM) :: Y 
          REAL(8), dimension(NN,NN) :: Z
          ! Locals
          INTEGER(4) :: I,J,K
          REAL(8) :: CST0, SUM
          CST0=0.0_8
          DO 9 I=1,MM
               DO 10 J=1,I
                  SUM=CST0
!$OMP SIMD REDUCTION(+:SUM)
                     DO 11 K=1,NN

                          SUM=SUM+X(I,K)*Y(K,J)
                  11 CONTINUE

                     Z(I,J)=SUM
            10 CONTINUE
        9 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE MULTRL(X,Y,Z,MM,NN) !GCC$ ATTRIBUTES HOT :: MULTRL !GCC$ ATTRIBUTES ALIGNED(32) :: MULTRL
          use omp_lib
          implicit none
!C     TRANSPOSE MULTIPLY (LEFT)
!C     Z=X'*Y
!C     Z: SYMMETRIC
!C     (LOWER TRIANGLE OF UPPER LEFT NN X NN OF Z)=(UPPER LEFT MM X NN OF
!C     X)'*(UPPER LEFT MM X NN OF Y)
!C     (MJ1,MJ2): ABSOLUTE DIMENSION OF X AND Y IN THE MAIN ROUTINE
!C     (MJ2,MJ2): ABSOLUTE DIMENSION OF Z IN THE MAIN ROUTINE

          INTEGER(4) :: MM, NN
          REAL(8), dimension(MM,NN) :: X 
          REAL(8), dimension(MM,NN) :: Y 
          REAL(8), dimension(NN,NN) :: Z
          ! Locals
          INTEGER(4) :: I,J,K
          REAL(8) :: CST0, SUM
          CST0=0.0_8

          DO 9 I=1,NN
               DO 10 J=1,I
                  SUM=CST0
!$OMP SIMD REDUCTION(+:SUM)
                         DO 11 K=1,MM

                              SUM=SUM+X(K,I)*Y(K,J)
                      11 CONTINUE

                         Z(I,J)=SUM
           10 CONTINUE
        9 CONTINUE
    END SUBROUTINE
    
    SUBROUTINE OPTSIMF(NS,M,IR,L,A,B,G,W,X,Y,XMEAN,YMEAN,XS2,YS2,    &
         XS2MEA,YS2MEA,XVAR,YVAR) !GCC$ ATTRIBUTES HOT :: OPTSIMF
          use omp_lib
          implicit none
!cc      PROGRAM OPTSIM
!C     PROGRAM 5.5.2   OPTIMAL CONTROL SIMULATION
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "DAINAMIKKU SISTEMU NO TOKEI-TEKI KAISEKI TO SEIGYO (STATISTICA
!C         ANALYSIS AND CONTROL OF DYNAMIC SYSTEMS)" BY H. AKAIKE AND
!C         T. NAKAGAWA, SAIENSU-SHA, TOKYO, 1972 (IN JAPANESE)
!C-----------------------------------------------------------------------
!C     THIS PROGRAM PERFORMS OPTIMAL CONTROL SIMULATION FOR THE
!C     CONTROLLER DESIGNED BY PROGRAM 5.5.1 AND EVALUATES THE MEANS AND
!C     VARIANCES OF THE CONTROLLED AND MANIPULATED VARIABLES X AND Y.
!C     FOLLOWING CONSTANTS SHOULD BE PROVIDED BESIDES THE OUTPUTS OF
!C     PROGRAM 5.5.1   OPTIMAL CONTROLLER DESIGN TO START THIS PROGRAM.
!C     NS: NUMBER OF STEPS OF SIMULATION
!C     INTP=1: TO SUPPRESS HISTORY OUTPUT
!C     INTP=2: TO PRINT OUT THE HISTORY
!C     THE SEQUENCE OF NS IR-DIMENSIONAL VECTORS W, REPRESENTING WHITE
!C     NOISE (OR IMPULSE) IS ALSO REQUIRED AS INPUT.
!C

          INTEGER(4) :: NS, M, IR, L
          REAL(8), dimension(IR*M,IR) :: A 
          REAL(8), dimension(IR*M,L)  :: B 
          REAL(8), dimension(L,IR*M)  :: G 
          REAL(8), dimension(IR,NS)   :: W, X
          REAL(8), dimension(L,NS)    :: Y 
          REAL(8), dimension(IR)      ::  XMEAN, XS2, XS2MEA, XVAR 
          REAL(8), dimension(L)       ::  YS2MEA,YVAR,YMEAN,YS2
          ! Locals
          INTEGER(4) :: MR,INS,I,J,MR1,IPR
          REAL(8) :: CST0, CST1,  ANS, BNS
             
          REAL(8), dimension(IR) :: XS 
          REAL(8), dimension(L)  :: YS 
          REAL(8), dimension(IR*M) ::  Z, C

          CST0=0.0_8

          MR=M*IR

          X(1:IR,1:NS)=CST0
          XS(1:IR)=CST0
          XS2(1:IR)=CST0
          Y(1:L,1:NS)=CST0
          YS(1:L)=CST0
          YS2(1:L)=CST0
          C(1:MR)=CST0
          MR1=MR-IR
!C     START OF SIMULATION
          !C     NOISE INPUT

          DO 10 INS=1,NS

                 CALL VECADL(C,W(1,INS),IR)
                 DO 9 I=1,IR

                     X(I,INS)=C(I)
               9 CONTINUE
!C     Y COMPUTATION

                 CALL MULVER(G,C,Y(1,INS),L,MR)
                 IF(INS.EQ.NS) GO TO 101

                 CALL MULVER(A,X(1,INS),Z,MR,IR)
                 IF(M.EQ.1) GO TO 360
                 DO 20 I=1,MR1
                          IPR=I+IR

                          Z(I)=Z(I)+C(IPR)
             20 CONTINUE

            360 CALL MULVER(B,Y(1,INS),C,MR,L)
                CALL VECADL(C,Z,MR)
!C     SUM AND SUM OF SQUARES COMPUTATION

            101 CALL VECADL(XS,X(1,INS),IR)
                CALL VECADL(YS,Y(1,INS),L)
!$OMP SIMD
                DO 30 I=1,IR

                      XS2(I)=XS2(I)+X(I,INS)**2
30                    CONTINUE
!$OMP SIMD
                DO 31 I=1,L

                      YS2(I)=YS2(I)+Y(I,INS)**2
             31 CONTINUE

       10 CONTINUE
!C     MEAN, MEAN SQUARE AND VARIANCE COMPUTATION
          ANS=NS
          CST1=1.0_R64P
          BNS=CST1/ANS
!$OMP SIMD
          DO 40 I=1,IR
                 XMEAN(I)=BNS*XS(I)
                 XS2MEA(I)=BNS*XS2(I)

                 XVAR(I)=XS2MEA(I)-XMEAN(I)**2
40               CONTINUE
!$OMP SIMD
           DO 41 I=1,L
                 YMEAN(I)=BNS*YS(I)
                 YS2MEA(I)=BNS*YS2(I)

                 YVAR(I)=YS2MEA(I)-YMEAN(I)**2
       41 CONTINUE

    END  SUBROUTINE
                       
   
    SUBROUTINE VECADL(X,Y,MM) !GCC$ ATTRIBUTES HOT :: VECADL !GCC$ ATTRIBUTES INLINE :: VECADL
          use omp_lib
          implicit none
          INTEGER(kind=4) :: MM
          REAL(kind=8), dimension(MM) :: X, Y
          ! Locals
          INTEGER(kind=4) :: I
!$OMP SIMD LINEAR(I:1)
          DO 10 I=1,MM

                  X(I)=X(I)+Y(I)
       10 CONTINUE
    END SUBROUTINE
    
    
    SUBROUTINE XSARMAF( YS,N,IQ,IP,P01,G1,TL1,P02,G2,ALPHB,ALPHA,TL2, SIGMA2 ) !GCC$ ATTRIBUTES HOT :: XSARMAF
                        
          implicit none
!cc      PROGRAM XSARMA                                                    
!C.......................................................................
!C.....PLANNED BY H.AKAIKE...............................................
!C.....DESIGNED BY H.AKAIKE..............................................
!C.....PROGRAMMED BY E.ARAHATA...........................................
!C.....ADDRESS: THE INSTITUTE OF STATISTICAL MATHEMATICS, 4-6-7 MINAMI-AZ
!C..............MINATO-KU, TOKYO 106, JAPAN..............................
!C.....DATE OF THE LATEST REVISION:  MAR. 6,1979.........................
!C.......................................................................
!C.....THIS PROGRAM WAS ORIGINALLY PUBLISHED IN "TIMSAC-78", BY H.AKAIKE,
!C.....G.KITAGAWA, E.ARAHATA AND F.TADA, COMPUTER SCIENCE MONOGRAPHS, NO.
!C.....THE INSTITUTE OF STATISTICAL MATHEMATICS, TOKYO, 1979.............
!C.......................................................................
!C     TIMSAC 78.5.2                                                     
!C     __                                 _      __ __                   
!C     EXACT MAXIMUM LIKELIHOOD METHOD OF SCALAR AR-MA MODEL FITTING     
!C                                                                       
!C-----------------------------------------------------------------------
!C     THIS PROGRAM PRODUCES EXACT MAXIMUM LIKELIHOOD ESTIMATES OF THE   
!C     PARAMETERS OF A SCALAR AR-MA MODEL.                               
!C                                                                       
!C     THE AR-MA MODEL IS GIVEN BY                                       
!C                                                                       
!C     Y(I)+B(1)Y(I-1)+...+B(IQ)Y(I-IQ)=X(I)+A(1)X(I-1)+...+A(IP)X(I-IP),
!C                                                                       
!C     WHERE X(I) IS A ZERO MEAN WHITE NOISE.                            
!C                                                                       
!C     ----------------------------------------------------------------- 
!C       REFERENCE:                                                      
!C          H.AKAIKE(1978), "COVARIANCE MATRIX COMPUTATION OF THE STATE  
!C          VARIABLE OF A STATIONARY GAUSSIAN PROCESS,",  RESEARCH MEMO. 
!C          NO.139, THE INSTITUTE OF STATISTICAL MATHEMATICS; TOKYO.     
!C          TO BE PUBLISHED IN ANN. INST. STATIST. MATH..                
!C     ----------------------------------------------------------------- 
!C     THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS PROGRAM:    
!C             SDATPR                                                    
!C             SMINOP                                                    
!C             SUBRST                                                    
!C     ----------------------------------------------------------------- 
!C     THE FOLLOWING INPUTS ARE REQUESTED BY SUBROUTINE SDATPR:          
!C          IQ:  AR-ORDER                                                
!C          (B(I),I=1,IQ):  INITIAL ESTIMATES OF AR COEFFICIENTS         
!C          IP:  MA-ORDER                                                
!C          (A(I),I=1,IP):  INITIAL ESTIMATES OF MA COEFFICIENTS         
!C          TITL:  TITLE OF THE DATA                                     
!C          N:  DATA LENGTH                                              
!C          (DFORM(I),I=1,20):  INPUT FORMAT SPECIFICATION IN ONE CARD,  
!C                              EXAMPLE,                                 
!C                              (8F10.4)                                 
!C          (Y(I),I=1,N):  ORIGINAL DATA                                 
!C                                                                       
!C     OUTPUTS:                                                          
!C          TITL:  TITLE OF THE DATA                                     
!C          IQ:  AR-ORDER                                                
!C          (B(I),I=1,IQ):  AR COEFFICIENTS                              
!C          IP:  MA-ORDER                                                
!C          (A(I),I=1,IP):  MA COEFFICIENTS                              
!C          SIGMA2:  WHITE NOISE VARIANCE                                
!C-----------------------------------------------------------------------
!C                                                                       

          INTEGER(kind=4) :: N, IQ, IP
          REAL(kind=8), dimension(N) :: YS 
          REAL(kind=8), dimension(IP+IQ) :: P01, G1,G2,P02
          REAL(kind=8) :: TL1,TL2,SIGMA2
          REAL(kind=8), dimension(IQ) :: ALPHB 
          REAL(kind=8), dimension(IP) :: ALPHA 
          ! Locals
          !INTEGER(I32P) :: 
          REAL(kind=8), dimension(N) :: Y

          CALL SDATPR(YS,Y,N)

          CALL SMINOP( TL1,TL2,SIGMA2,Y,N,P01,G1,P02,G2,ALPHB,ALPHA,IQ,IP)
    END SUBROUTINE
    

                                                                 
    SUBROUTINE ARCHCK(A,ALPH,M,ICOND) !GCC$ ATTRIBUTES HOT :: ARCHCK !GCC$ ATTRIBUTES ALIGNED(32) :: ARCHCK
          use omp_lib
          implicit none
!C                                                                       
!C-----------------------------------------------------------------------
!C     THIS SUBROUTINE CHECKS STABILITY OF AR OR MA PART.                
!C                                                                       
!C     INPUTS:                                                           
!C          (A(I),I=1,M):  AR OR MA COEFFICIENTS                         
!C          M:  AR- OR MA-ORDER                                          
!C                                                                       
!C     OUTPUTS:                                                          
!C          (A(I),I=1,M):  AR OR MA COEFFICIENTS                         
!C          ICOND:  ICOND=0, WHEN STABLE                                 
!C                  ICOND=1, WHEN NOT STABLE                             
!C-----------------------------------------------------------------------
!C                                                                       
                               
          INTEGER(kind=4) :: M, ICOND 
          REAL(kind=8), dimension(M) :: A, ALPH
          ! Locals
          INTEGER(kind=4) :: I,J,MI,MIP1,KI,IM1,IP1,K,IK
          REAL(kind=8) ::  CST0, CST1, CST099, AT, CT, D
          REAL(kind=8), dimension(M)  :: B 
          DATA CST0,CST1,CST099/0.0_8,1.0_8,0.99999_8/                
                                                                       
!C-----  STABILITY CHECK  -----                                          
                                                       
          B(1:M)=CST0
          DO 20 I=1,M                                                       
                MI=M-I                                                            
                MIP1=MI+1                                                         
                AT=A(MIP1)                                                        
                IF(DABS(AT).LT.CST099) GO TO 210                                  
                ICOND=1                                                           
                AT=CST099*AT/DABS(AT)                                             
            210 ALPH(MIP1)=AT                                                     
                IF(MI.EQ.0) GO TO 20                                              
                CT=CST1/(CST1-AT**2)                                              
                DO 25 J=1,MI                                                      
                      KI=MIP1-J                                                         
                      B(J)=A(KI)                                                        
25                    CONTINUE
#if defined __ICC
                      !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD LINEAR(K:1)
#endif    
               DO 30 K=1,MI                                                      
                    A(K)=(A(K)-AT*B(K))*CT                                            
            30 CONTINUE                                                          
       20 CONTINUE                                                          
                                                                      
!C-----  RECOVERY OF COEFFICIENTS  -----                                 
          DO 400 I=1,M                                                      
                 D=ALPH(I)                                                         
                 A(I)=D                                                            
                 IF(I.EQ.1) GO TO 410                                              
                 IM1=I-1
!$OMP SIMD LINEAR(J:1)
                 DO 420 J=1,IM1                                                    
                       A(J)=A(J)+D*B(J)                                                  
             420 CONTINUE                                                          
             410 CONTINUE                                                          
                 IP1=I+1                                                           
                 DO 421 K=1,I                                                      
                        IK=IP1-K                                                          

                        B(K)=A(IK)
             421 CONTINUE
      400 CONTINUE                                                          
    END SUBROUTINE
    
    SUBROUTINE  FUNCT2( F,SD,Y,N,P0,IQ,IP,IR ) !GCC$ ATTRIBUTES HOT :: FUNCT2 !GCC$ ATTRIBUTES ALIGNED(32) :: FUNCT2
          use omp_lib
          implicit none
!C                                                                       
!C-----------------------------------------------------------------------
!C!     THIS SUBROUTINE COMPUTES SD AND F(=(-2)LOG LIKELIHOOD) BY         
!C     A PROCEDURE OF MORF, SIDHU AND KAILATH (IEEE TRANS. AUTOMAT.      
!C     CONTR., AC19, 315-323,1974).                                      
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINE IS DIRECTLY CALLED BY THIS SUBROUTINE: 
!C             SUBPM                                                     
!C       ----------------------------------------------------------------
!C                                                                       
!C     INPUTS:                                                           
!C          N:  DATA LENGTH                                              
!C          (Y(I),I=1,N):  ORIGINAL DATA, MEAN DELETED                   
!C          IQ:  AR-ORDER                                                
!C          IP:  MA-ORDER                                                
!C          (P0(I),I=1,IPQ):  THE VECTOR OF AR AND MA COEFFICIENTS (IPQ=I
!C                                                                       
!C     OUTPUTS:                                                          
!C          F:  (-2)LOG LIKELIHOOD                                       
!C          SD:  WHITE NOISE VARIANCE                                    
!C-----------------------------------------------------------------------
!C                                                                       

          INTEGER(kind=4) :: N,  IQ, IP, IR
          REAL(kind=8) :: F , SD 
          REAL(kind=8), dimension(N)     ::  Y 
          REAL(kind=8), dimension(IP+IQ) ::  P0
          ! Locals
          INTEGER(kind=4) :: I,J,II,IRM1,IRP1,I1,INDX,NS,INDX1
          REAL(kind=8)    ::    CST0, CST1, CSTA, REM,             &
                SUM, AMI, EM, SERI, SLR, Y2, REW, ERI, AMY,      &
                AMRI, YRI, EW, AN
          REAL(kind=8), dimension(IR) :: A, B,P1, AKI, YY, PY, Z, PZ
          REAL(kind=8), dimension(IR,IR) :: P
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: A,B,P1,AKI,YY,PY,Z,PZ,P
#endif
          DATA CST0,CST1,CSTA/0.0_8,1.0_8,0.1E-05_8/                      

          A(1:IR)=CST0
          B(1:IR)=CST0
          AKI(1:IR)=CST0
                                                                       
          IF(IQ.EQ.0) GO TO 620
#if defined __ICC
          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 610 I=1,IQ                                                     
               B(I)=P0(I)                                                        
      610 CONTINUE                                                          
620            IF(IP.EQ.0) GO TO 640
!$OMP SIMD
          DO 630 I=1,IP                                                     
                 II=IQ+I                                                           
                 A(I)=P0(II)                                                       
      630 CONTINUE                                                          
      640 CONTINUE                                                          
                                                                       
!C-----  P MATRIX COMPUTATION  -----                                     
          CALL SUBPM(P,B,A,IQ,IP,IR)                                        
!C                                                                       
!C-----  INITIAL CONDITION  -----                                        
          REM=P(1,1)
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD
#endif
          DO 20 I=1,IR                                                      
                P1(I)=P(I,1)                                                      
       20 CONTINUE                                                          
          IRM1=IR-1                                                         
          IRP1=IR+1                                                         
          IF(IRM1.LE.0) GO TO 510                                           
          DO 50 I=1,IRM1                                                    
                 AKI(I)=P1(I+1)                                                    
       50 CONTINUE                                                          
      510 CONTINUE                                                          
          SUM=CST0
!$OMP SIMD REDUCTION(+:SUM)                
          DO 60 I=1,IR                                                      
                 I1=IRP1-I                                                         
                 SUM=SUM+B(I)*P1(I1)                                               
       60 CONTINUE                                                          
          AKI(IR)=-SUM                                                      
          AMI=-CST1/REM
#if defined __ICC
!DIR$ VECTOR ALIGNED
          !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif          
          DO 100 I=1,IR                                                     
                 YY(I)=AKI(I)                                                      
      100 CONTINUE                                                          
                 EM=Y(1)
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD LINEAR(I:1)
#endif                 
          DO 110 I=1,IR                                                     
                 Z(I)=CST0                                                         
      110 CONTINUE                                                          
!C                                                                       
          SERI=EM**2/REM                                                    
          SLR=DLOG(REM)                                                     
!C******************************                                         
          INDX = 1
          DO 1000 NS=2,N                                                    
                  Y2=YY(1)*YY(1)                                                    
!C-----  RE COMPUTATION  -----                                           
                  REW=REM+AMI*Y2                                                    
                  INDX=NS                                                           
!C                                                                       
!C-----  PHI*Z COMPUTATION  -----                                        
                  IF(IRM1.LE.0) GO TO 520                                           
                  DO 210 I=1,IRM1                                                   
                         PZ(I)=Z(I+1)                                                      
              210 CONTINUE                                                          
              520 CONTINUE                                                          
                  SUM=CST0                                                          
                  DO 220 I=1,IR                                                     
                         I1=IRP1-I                                                         
                         SUM=SUM+B(I)*Z(I1)                                                
             220 CONTINUE                                                          
                 PZ(IR)=-SUM                                                       
!C----- Z COMPUTATION  -----                                             
                 ERI=EM/REM
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD LINEAR(I:1)
#endif    
                 DO 230 I=1,IR                                                     
                       Z(I)=PZ(I)+ERI*AKI(I)                                             
             230 CONTINUE                                                          
!C                                                                       
!C-----  PHI*YY COMPUTATION  -----                                       
                 IF(IRM1.LE.0) GO TO 530                                           
                 DO 310 I=1,IRM1                                                   
                        PY(I)=YY(I+1)                                                     
             310 CONTINUE                                                          
             530 CONTINUE                                                          
                 SUM=CST0                                                          
                 DO 320 I=1,IR                                                     
                        I1=IRP1-I                                                         
                        SUM=SUM+B(I)*YY(I1)                                               
             320 CONTINUE                                                          
                 PY(IR)=-SUM                                                       
!C                                                                       
!C-----  K COMPUTATION  -----                                            
                 AMY=AMI*YY(1)
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD LINEAR(I:1)
#endif    
                 DO 330 I=1,IR                                                     
                       AKI(I)=AKI(I)+AMY*PY(I)                                           
             330 CONTINUE                                                          
!C                                                                       
!C-----  M COMPUTATION  -----                                            
                 AMRI=AMI/REM                                                      
                 AMI=AMI*(CST1+AMRI*Y2)                                            
!C                                                                       
!C-----  YY COMPUTATION  -----                                           
                 YRI=YY(1)/REW
#if defined __ICC
!DIR$ VECTOR ALIGNED
                 !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD LINEAR(I:1)
#endif    
                DO 400 I=1,IR                                                     
                     YY(I)=PY(I)-YRI*AKI(I)                                            
            400 CONTINUE                                                          
!C                                                                       
!C-----  E COMPUTATION  -----                                            
                EW=Y(NS)-Z(1)                                                     
!C                                                                       
!C-----  SERI, SLR COMPUTATION  -----                                    
                SERI=SERI+EW**2/REW                                               
                SLR=SLR+DLOG(REW)                                                 
                REM=REW                                                           
                EM=EW                                                             
                IF(DABS(REW-CST1).LT.CSTA) GO TO 1100                             
     1000 CONTINUE                                                          
                                                                       
     1100 CONTINUE                                                          
          IF(INDX.GE.N) GO TO 1500                                          
          INDX1=INDX+1                                                      
          DO 1110 NS=INDX1,N                                                
!C-----  PHI*Z  -----                                                    
                   IF(IRM1.LE.0) GO TO 540                                           
                   DO 1210 I=1,IRM1                                                  
                          PZ(I)=Z(I+1)                                                      
              1210 CONTINUE                                                          
               540 CONTINUE                                                          
                   SUM=CST0                                                          
                   DO 1220 I=1,IR                                                    
                         I1=IRP1-I                                                         
                         SUM=SUM+B(I)*Z(I1)                                                
              1220 CONTINUE                                                          
                   PZ(IR)=-SUM                                                       
!C                                                                       
                   !C-----  Z COMPUTATION  -----
#if defined __ICC
!DIR$ VECTOR ALIGNED
                   !DIR$  SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
                 !$OMP SIMD LINEAR(I:1)
#endif    
                  DO 1230 I=1,IR                                                    
                         Z(I)=PZ(I)+EM*AKI(I)                                              
             1230 CONTINUE                                                          
!C                                                                       
!C-----  E COMPUTATION  -----                                            
                  EW=Y(NS)-Z(1)                                                     
!C                                                                       
!C-----  SERI COMPUTATION  -----                                         
                 SERI=SERI+EW**2                                                   
                 EM=EW                                                             
     1110 CONTINUE                                                          
     1500 CONTINUE                                                          
!C******************************                                         
                                                                      
          AN=N                                                              
          SD=SERI/AN                                                        
          F=SLR+AN*DLOG(SD)                                                 
                                                                      
          IF(IQ.EQ.0) GO TO 1620                                            
          DO 1610 I=1,IQ                                                    
                 P0(I)=B(I)                                                        
      1610 CONTINUE                                                          
      1620 IF(IP.EQ.0) GO TO 1640                                            
           DO 1630 I=1,IP                                                    
                  II=IQ+I                                                           
                  P0(II)=A(I)                                                       
      1630 CONTINUE                                                          
      1640 CONTINUE                                                          
    END SUBROUTINE
    

    SUBROUTINE MSDAV2(PHAI,SIGMA2,G,C,Y,N,X,IQ,IP,ISWRO,VD) !GCC$ ATTRIBUTES HOT :: MSDAV2 !GCC$ ATTRIBUTES ALIGNED(32) :: MSDAV2
          use omp_lib
          implicit none
!C                                                                       
!C-----------------------------------------------------------------------
!C     DAVIDON'S (MINIMIZATION) PROCEDURE                                
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             SGRAD                                                     
!C             ARCHCK                                                    
!C                                                                       
!C     INPUTS:                                                           
!C          N:  DATA LENGTH                                              
!C          (Y(I),I=1,N):  ORIGINAL DATA, MEAN DELETED                   
!C          IQ:  AR-ORDER                                                
!C          IP:  MA-ORDER                                                
!C          (X(I),I=1,IPQ):  THE VECTOR OF AR AND MA COEFFICIENTS (IPQ=IP
!C          PHAI:  (-2)LOG LIKELIHOOD                                    
!C          SIGMA2:  WHITE NOISE VARIANCE                                
!C          (G(I),I=1,IPQ):  GRADIENT                                    
!C          (C(I),I=1,IPQ):  CORRECTION TERM                             
!C          ISWRO:  ITERATION COUNT OF SUBROUTINE MSDAV2                 
!C          ((VD(I,J),I=1,IPQ),J=1,IPQ):  INVERSE OF HESSIAN             
!C                                                                       
!C     OUTPUTS:                                                          
!C          PHAI:  NEW PHAI                                              
!C          SIGMA2:  NEW SIGMA2                                          
!C          (G(I),I=1,IPQ):  NEW GRADIENT                                
!C          (X(I),I=1,IPQ): NEW X(I)                                     
!C          ISWRO:  NEW ISWRO                                            
!C          ((VD(I,J),I=1,IPQ),J=1,IPQ):  NEW INVERSE OF HESSIAN         
!C                                                                       
!C     PARAMETERS:                                                       
!C          IPRNT=0:  NOT TO PRINT OUT INTERMEDIATE RESULTS              
!C          IPRNT=1:  TO PRINT OUT INTERMEDIATE RESULTS                  
!C-----------------------------------------------------------------------
!C                                                                       

          INTEGER(kind=4) :: N, IQ, IP, ISWRO
          REAL(kind=8) :: PHAI, SIGMA2
          REAL(kind=8), dimension(IP+IQ) :: G, C, Y, X
          REAL(kind=8), dimension(N)     :: Y 
          REAL(kind=8), dimension(IP+IQ,IP+IQ) :: VD
          ! Locals
          INTEGER(kind=4) :: ISPHAI,IPHAI,IPQ,IPQ2,ITNS,I,J,ITN,ICOND, &
                           II,IRAM
          REAL(kind=8)    ::   CST0, CST1, CST4, CST10,                          &
                             CONSTA, CONSTB, EPS3, EPS4, VDN, SCI, SUM,        &
                             SRO, GSR, DGAM, DGAM1, RAM, RAMSRO, RAMT,         &
                             SPHAI, RAM1, CONSDR, SD, MAXVD 
          REAL(kind=8), dimension(IP+IQ) :: SX, SG, SR, SSX, ALPH
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: SX,SG,SR,SSX,ALPH
#endif
          DATA CST0,CST1,CST4,CST10/0.0_8,1.0_8,4.0_8,10.0_8/       
          DATA CONSTA,CONSTB,EPS3,EPS4/0.5_8,2.0_8,0.1E-05_8,0.1E-05_8/     
                                                                      
          ISPHAI=0                                                          
          IPHAI=1                                                           
          IPQ=IQ+IP                                                         
          IPQ2=IPQ+IPQ                                                      
                                                                       
          ITNS=0                                                            
      150 CONTINUE                                                          
          ITNS=ITNS+1                                                       
          ITN=0                                                             
                                                                       
     1210 CONTINUE                                                          
          ICOND=0                                                           
!C-----  SX=X-C  -----                                                   
          DO 210 I=1,IPQ                                                    

                  SX(I)=X(I)-C(I)
      210 CONTINUE
                                                                       
!C-----  GRADIENT COMPUTATION  -----                                     
                                                 
          ICOND=0                                                           
          IF(IQ.LE.0) GO TO 4510
#if defined __ICC
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif
          DO 4500 I=1,IQ                                                    

                    SSX(I)=SX(I)
     4500 CONTINUE
                                    
          CALL ARCHCK(SSX,ALPH,IQ,ICOND)
     4510 IF(IP.LE.0) GO TO 4600                                            
          DO 4520 I=1,IP                                                    
                  II=IQ+I                                                           

                  SSX(I)=SX(II)
     4520 CONTINUE
                                   
          CALL ARCHCK(SSX,ALPH,IP,ICOND)
     4600 CONTINUE                                                          
                                                                       
          IF(ICOND.EQ.0) GO TO 309                                          
                                                  
     1220 CONTINUE                                                          
                                                                       
          ITN=ITN+1                                                         
                                         
          MAXVD=CST0                                                        
          DO 4900 I=1,IPQ                                                   
               IF(VD(I,I).GT.MAXVD)MAXVD=VD(I,I)                                 
     4900 CONTINUE                                                          
          VDN=MAXVD/CST4                                                    
          DO 304 I=1,IPQ                                                    
                 DO 303 J=1,IPQ                                                    

                         VD(I,J)=VD(I,J)/CST10
              303 CONTINUE

                  VD(I,I)=VD(I,I)+VDN
      304 CONTINUE
          DO 306 I=1,IPQ                                                    
             SCI=CST0
!$OMP SIMD REDUCTION(+:SCI)
                 DO 305 J=1,IPQ                                                    

                       SCI=SCI+VD(I,J)*G(J)
             305 CONTINUE

                 C(I)=SCI
       306 CONTINUE
                                                                       
          GO TO 1210                                                        
      309 CONTINUE                                                          
                      
          CALL SGRAD(SPHAI,SD,SG,Y,N,SX,IQ,IP)
          IF(ICOND.EQ.1) GO TO 1220                                         
          IF(ITN.GE.10) GO TO 312                                           
      312 CONTINUE                                                          
                                            
          DO 310 I=1,IPQ                                                    
             SUM=CST0
!$OMP SIMD REDUCTION(+:SUM)
                   DO 311 J=1,IPQ                                                    
                                   
                          SUM=SUM+VD(I,J)*SG(J)
              311 CONTINUE

                  SR(I)=SUM
      310 CONTINUE
!C                                                                       
!C-----  SRO=(SG)'*(SR)  -----                                           
         SRO=0.0D-00  
!DIR$ SIMD REDUCTION(+:SRO)
         DO 1050 I=1,IPQ                                                   

                 SRO=SRO+SG(I)*SR(I)
    1050 CONTINUE
                                    
                 GSR=0.0_R64P
#if defined __ICC
                 !DIR$ SIMD REDUCTION(+:GSR)
#elif defined __GFORTRAN__
!$OMP SIMD REDUCTION(+:GSR)
         DO 1060 I=1,IPQ                                                   

                   GSR=GSR+G(I)*SR(I)
    1060 CONTINUE
         DGAM=-GSR/SRO                                                     
         DGAM1=DGAM+CST1                                                   
         DGAM1=DABS(DGAM1)+0.1E-70_R64P                                         
         RAM=DABS(DGAM)/DGAM1                                              
                                                                      
         IF(RAM.GT.CONSTA) GO TO 430                                       
         RAM=CONSTA                                                        
         IRAM=1                                                            
         GO TO 470                                                         
                                                                       
     430 IF(RAM.LT.CONSTB) GO TO 450                                       
         RAM=CONSTB                                                        
         IRAM=-1                                                           
         GO TO 470                                                         
                                                                       
     450 CONTINUE                                                          
         IRAM=0                                                            
     470 RAMSRO=(RAM-CST1)/SRO                                             
                                           
         DO 481 I=1,IPQ
                 RAMT=RAMSRO*SR(I)                                                 
                 DO 480 J=1,IPQ                                                    

                         VD(I,J)=VD(I,J)+RAMT*SR(J)
            480 CONTINUE
      481 CONTINUE
          IF(PHAI.GE.SPHAI) GO TO 540                                       
                  
          RAM1=RAM-CST1                                                     
          IF(DABS(RAM1).LT.EPS3) GO TO 555                                  
          CONSDR=DGAM*RAM1
#if defined __ICC
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif
          DO 550 I=1,IPQ                                                    
                                 
                   C(I)=C(I)-CONSDR*SR(I)
      550 CONTINUE
          IPHAI=0                                                           
          IF(SRO.GT.EPS4) GO TO 900                                         
!C     END OF ITERATION                                                  
      555 ISWRO=ISWRO+1                                                     
          GO TO 1000                                                        
!C                                                                       
          !C-----  SHPAI.LE.PHAI: SUCCESSFUL REDUCTION  -----
#if defined __ICC
          !DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
          !$OMP SIMD LINEAR(I:1)
#endif
      540 DO 560 I=1,IPQ                                                    
                X(I)=SX(I)                                                        
                G(I)=SG(I)                                                        
                C(I)=RAM*SR(I)
      560 CONTINUE
          PHAI=SPHAI                                                        
          SIGMA2=SD                                                         
                                                        
                                                                       
          IPHAI=1                                                           

          IF(IRAM.NE.0) GO TO 901                                           
          IF(SRO.LT.EPS4) GO TO 555                                         
!C     ITERATION CHECK                                                   
      900 CONTINUE                                                          
          ISPHAI=(ISPHAI+(1-IPHAI))*(1-IPHAI)                               
                                                                       
          IF(ISPHAI.GT.IPQ2) GO TO 555                                      
                                                                       
          GO TO 150                                                         
      901 IF(SRO.LT.EPS4) GO TO 555                                         
          GO TO 900                                                         
!C     END OF MINIMIZATION                                               
     1000 CONTINUE                                                          
    END SUBROUTINE
    
                          
    SUBROUTINE SDATPR(YS,Y,N) !GCC$ ATTRIBUTES INLINE :: SDATPR !GCC$ ATTRIBUTES HOT :: SDATPR !GCC$ ATTRIBUTES ALIGNED(32) :: SDATPR
          implicit none
!C                                                                       
!C-----------------------------------------------------------------------
!C     THIS SUBROUTINE READS IN AND PRINTS OUT INITIAL CONDITION AND DELE
!C     THE MEAN OF THE DATA.                                             
!C                                                                       
!C     THE FOLLOWING INPUTS ARE REQUIRED:                                
!C          IQ:  AR-ORDER                                                
!C          (B(I),I=1,IQ):  INITIAL ESTIMATES OF AR COEFFICIENTS         
!C          IP:  MA-ORDER                                                
!C          (A(I),I=1,IP):  INITIAL ESTIMATES OF MA COEFFICIENTS         
!C          TITL:  TITLE OF THE DATA                                     
!C          N:  DATA LENGTH                                              
!C          (DFORM(I),I=1,20):  INPUT FORMAT SPECIFICATION IN ONE CARD,  
!C                              EXAMPLE,                                 
!C                              (8F10.4)                                 
!C          (Y(I),I=1,N):  ORIGINAL DATA                                 
!C                                                                       
!C     THE AR-MA MODEL IS GIVEN BY                                       
!C     Y(I)+B(1)Y(I-1)+...+B(IQ)Y(I-IQ)=X(I)+A(1)X(I-1)+...+A(IP)X(I-IP),
!C     WHERE X(I) IS A ZERO MEAN WHITE NOISE.                            
!C-----------------------------------------------------------------------
!C                                                                       

          INTEGER(kind=4) :: N
          REAL(kind=8), dimension(N) :: YS, Y
          ! Locals
          INTEGER(kind=4) :: I
          REAL(kind=8) :: CST0, AN, SUM, YMEAN
          DATA CST0/0.0_8/                                                
                                                     
                                      
          DO 320 I=1,N

                 Y(I)=YS(I)
      320 CONTINUE
                                            
                                   
          AN=N                                                              
          SUM=CST0                                                          
          DO 9 I=1,N                                                        
                                                 
                 SUM=SUM+Y(I)
        9 CONTINUE
          YMEAN=SUM/AN                                                      
          DO 10 I=1,N                                                       

                Y(I)=Y(I)-YMEAN
       10 CONTINUE
    END SUBROUTINE
    
                                                  
                
    SUBROUTINE SGRAD(F0,SD,G,Y,N,P0,IQ,IP) !GCC$ ATTRIBUTES HOT :: SGRAD !GCC$ ATTRIBUTES ALIGNED(32) :: SGRAD
          implicit none
!C                                                                       
!C-----------------------------------------------------------------------
!C     THIS SUBROUTINE COMPUTES AN APPROXIMATION TO GRADIENT BY DIFFERENC
!C     THIS SUBROUTINE SHOULD EVENTUALLY BE REPLACED BY AN ANALYTIC EVALU
!C     PROCEDURE OF GRADIENTS.                                           
!C       ----------------------------------------------------------------
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             FUNCT2                                                    
!C             ARCHCK                                                    
!C       ----------------------------------------------------------------
!C                                                                       
!C     INPUTS:                                                           
!C          N:  DATA LENGTH                                              
!C          (Y(I),I=1,N):  ORIGINAL DATA, MEAN DELETED                   
!C          IQ:  AR-ORDER                                                
!C          IP:  MA-ORDER                                                
!C          (P0(I),I=1,IPQ):  THE VECTOR OF AR AND MA COEFFICIENTS (IPQ=I
!C                                                                       
!C     OUTPUTS:                                                          
!C          F0:  (-2)LOG LIKELIHOOD                                      
!C          SD:  WHITE NOISE VARIANCE                                    
!C          (G(I),I=1,IPQ):  GRADIENT                                    
!C                                                                       
!C     PARAMETERS:                                                       
!C          EPSA:  ORDINATE DIFFERENCE FOR GRADIENT COMPUTATION BY DIFFER
!C          IPRNT=0:  NOT TO PRINT OUT INTERMEDIATE RESULTS              
!C          IPRNT=1:  TO PRINT OUT INTERMEDIATE RESULTS                  
!C-----------------------------------------------------------------------

          INTEGER(kind=4) :: N, IQ, IP
          REAL(kind=8) :: F0, SD 
          REAL(kind=8), dimension(IP+IQ) :: G, P0
          REAL(kind=8), dimension(N) :: Y
          ! Locals
          INTEGER(kind=4) :: IP1,IR,I,J,IPQ,ITR,ICOND,II,III
          REAL(kind=8) ::   CST07, EPSA, EPSAS, F1, SDN
               
          REAL(kind=8), dimension(IP+IQ) :: P1, PP0, ALPH
#if defined __ICC
          !DIR$ ATTRIBUTES ALIGN : 64 :: P1,PP0,ALPH
#endif
          DATA EPSA,CST07/0.1e-03_8,0.7e-00_8/                                  
                             
          IP1=IP+1                                                          
          IR=MAX0(IQ,IP1)                                                   
          CALL FUNCT2(F0,SD,Y,N,P0,IQ,IP,IR)                                   
          IPQ=IP+IQ                                                         
          DO 9 J=1,IPQ                                                      
                 P1(J)=P0(J)                                                       
        9 CONTINUE                                                          
!C                                                                       
!C-----  GRADIENT COMPUTATION  -----                                     
         DO 10 I=1,IPQ                                                     
                EPSAS=EPSA                                                        
                ITR=1                                                             
           4000 CONTINUE                                                          
                ICOND=0                                                           
                P1(I)=P0(I)+EPSAS                                                 
                IF(I.GT.IQ) GO TO 4500                                            
                DO 4010 II=1,IQ                                                   
                        PP0(II)=P1(II)                                                    
           4010 CONTINUE                                                          
                                   
                CALL ARCHCK(PP0,ALPH,IQ,ICOND)
                GO TO 5000                                                        
           4500 CONTINUE                                                          
                DO 5010 II=1,IP                                                   
                         III=IQ+II                                                         
                                                   
                         PP0(II)=P1(III)
           5010 CONTINUE
                                       
                CALL ARCHCK(PP0,ALPH,IP,ICOND)
           5000 CONTINUE                                                          
                IF(ICOND.EQ.0) GO TO 4100                                         
                IF(ITR.LT.10) GO TO 4110                                          
                                                   
                RETURN                                                            
           4110 EPSAS=EPSAS*CST07                                                 
                EPSAS=-EPSAS                                                      
                ITR=ITR+1                                                         
                GO TO 4000                                                        
           4100 CONTINUE                                                          
                              
                CALL FUNCT2(F1,SDN,Y,N,P1,IQ,IP,IR)
                G(I)=(F1-F0)/EPSAS                                                
                P1(I)=P0(I)                                                       
       10 CONTINUE                                                          
    END SUBROUTINE
    
                                                                 
                   
    SUBROUTINE SMINOP( TL,TL2,SIGMA2,Y,N,P0,G,P02,G2,ALPHB,ALPHA,IQ, IP  ) !GC$$ ATTRIBUTES HOT :: SMINOP !GCC$ ATTRIBUTES ALIGNED(32) :: SMINOP
          use omp_lib
          implicit none
    
!C C                                                                       
!C-----------------------------------------------------------------------
!C     THIS SUBROUTINE CONTROLS THE MAXIMUM LIKELIHOOD COMPUTATION.      
!C                                                                       
!C       THE FOLLOWING SUBROUTINES ARE DIRECTLY CALLED BY THIS SUBROUTINE
!C             SGRAD                                                     
!C             ARCHCK                                                    
!C                                                                       
!C     INPUTS:                                                           
!C          N:  DATA LENGTH                                              
!C          (Y(I),I=1,N):  ORIGINAL DATA, MEAN DELETED                   
!C          IQ:  AR-ORDER                                                
!C          IP:  MA-ORDER                                                
!C          (P0(I),I=1,IPQ):  THE VECTOR OF AR AND MA COEFFICIENTS (IPQ=I
!C                                                                       
!C     OUTPUTS:                                                          
!C          TL:  (-2)LOG LIKELIHOOD                                      
!C          SIGMA2:  WHITE NOISE VARIANCE                                
!C                                                                       
!C     PARAMETERS:                                                       
!C          IPRNT=0:  NOT TO PRINT OUT INTERMEDIATE RESULTS              
!C          IPRNT=1:  TO PRINT OUT INTERMEDIATE RESULTS                  
!C-----------------------------------------------------------------------

          INTEGER(kind=4) :: N, IQ, IP
          REAL(kind=8) :: TL, TL2, SIGMA2 
          REAL(kind=8), dimension(N) :: Y 
          REAL(kind=8), dimension(IP+IQ) :: P0, G, P02, G2
          REAL(kind=8), dimension(IQ) :: ALPHB, ALPHA
          ! Locals
          INTEGER(kind=4) :: IPQ,I,J,ICOND,II,ISWRO
          REAL(kind=8) :: MAXAB,CST0, CST10, CST05, CST005, PAB, BN, SUM
          REAL(kind=8), dimension(IP+IQ,IP+IQ)  ::  HS 
          REAL(kind=8), dimension(IP+IQ)        :: CR, PP0, ALPH
           
                                        
          DATA CST0,CST10,CST05,CST005/0.0_8,10.0_8,0.1E-03_8,0.00005_8/
                                                                      
          IPQ=IP+IQ                                                         
                                                    
          G(1:IPQ)=CST0                                                         
          PP0(1:IPQ)=CST0
          HS(1:IPQ,1:IPQ)=CST0 
                                    
          ICOND=0                                                           
          IF(IQ.LE.0) GO TO 4510                                            
          DO 4500 I=1,IQ                                                    
                                             
                PP0(I)=P0(I)
     4500 CONTINUE
                                  
                CALL ARCHCK(PP0,ALPH,IQ,ICOND)
!$OMP SIMD LINEAR(I:1)
          DO 5000 I=1,IQ                                                    
                                              
               P0(I)=PP0(I)
     5000 CONTINUE
     4510 IF(IP.LE.0) GO TO 4800                                            
          DO 4700 I=1,IP                                                    
                  II=IQ+I                                                           
                                                   
                  PP0(I)=P0(II)
     4700 CONTINUE
                                    
          CALL ARCHCK(PP0,ALPH,IP,ICOND)
          DO 5100 I=1,IP                                                    
                  II=IQ+I                                                           
                  P0(II)=PP0(I)                                                     
     5100 CONTINUE                                                          
     4800 CONTINUE                                                          
          ISWRO=0                                                           
                    
          CALL SGRAD(TL,SIGMA2,G,Y,N,P0,IQ,IP)
!$OMP SIMD LINEQAR(I:1)                                            
          DO 4850 I=1,IPQ
                  P02(I)=P0(I)
                  G2(I)=G(I)
     4850 CONTINUE
          TL2=TL
                                                                       
     4890 CONTINUE                                                          
          MAXAB=CST0                                                        
          DO 4900 I=1,IPQ                                                   
                                                
                  PAB=DABS(G2(I))
                  IF(PAB.GT.MAXAB) MAXAB=PAB                                        
     4900 CONTINUE                                                          
                       
          BN=CST05/MAXAB                                                    
          DO 3010 I=1,IPQ                                                   
                  DO 3009 J=1,IPQ                                                   
                                    
                         HS(I,J)=HS(I,J)/CST10
            3009 CONTINUE
                 HS(I,I)=BN+HS(I,I)                                                
     3010 CONTINUE                                                          
               
          DO 900 I=1,IPQ                                                    
             SUM=CST0
!$OMP SIMD REDUCTION(+:SUM)
                DO 910 J=1,IPQ                                                    

                       SUM=SUM+HS(I,J)*G2(J)
             910 CONTINUE
                                                 
                 CR(I)=SUM
      900 CONTINUE

          CALL MSDAV2(TL2,SIGMA2,G2,CR,Y,N,P02,IQ,IP,ISWRO,HS)
                                                                       
          IF(ISWRO.GE.IPQ) GO TO 1201                                       
          DO 1902 I=1,IPQ                                                   
                    
                   IF(DABS(PP0(I)-P02(I)).GE.CST005) GO TO 1919
     1902 CONTINUE                                                          
          GO TO 1201                                                        
     1919 CONTINUE                                                          
                                                                    
          GO TO 4890                                                        
                                                                       
     1201 CONTINUE                                                          
                                                
          ICOND=0                                                           
          IF(IQ.LE.0) GO TO 6510                                            
          DO 6500 I=1,IQ                                                    
                                                 
                     PP0(I)=P02(I)
     6500 CONTINUE
          CALL ARCHCK(PP0,ALPHB,IQ,ICOND)
                                  
     6510 IF(IP.LE.0) GO TO 6800                                            
          DO 6700 I=1,IP                                                    
                   II=IQ+I                                                           

                   PP0(I)=P02(II)
     6700 CONTINUE
          CALL ARCHCK(PP0,ALPHA,IP,ICOND)
                             
     6800 CONTINUE                                                          
    END SUBROUTINE
    
                                                     
    SUBROUTINE SUBPM(P,B,A,IQ,IP,IR) !GCC$ ATTRIBUTES HOT :: SUBPM !GCC$ ATTRIBUTES ALIGNED(32)
          use omp_lib
          implicit none
!C                                                                       
!C-----------------------------------------------------------------------
!C     THIS SUBROUTINE COMPUTES THE VARIANCE MATRIX OF A STATIONARY STATE
!C     VECTOR BY THE PROCEDURE OF AKAIKE (RESEARCH MEMO. 139 INST. STATIS
!C     MATH. OCTOBER, 1978).                                             
!C                                                                       
!C     INPUTS:                                                           
!C          IQ:  AR-ORDER                                                
!C          (B(I),I=1,IQ):  AR-COEFFICIENTS                              
!C          IP:  MA-ORDER                                                
!C          (A(I),I=1,IP):  MA-COEFFICIENTS                              
!C          IR:  IR=MAX(IQ,IP+1)                                         
!C                                                                       
!C     OUTPUTS:                                                          
!C          ((P(I,J),I=1,IR),J=1,IR):  VARIANCE MATRIX OF THE STATIONARY 
!C                                     STATE VECTOR                      
!C-----------------------------------------------------------------------
!C                                                                       

          INTEGER(kind=4) :: IQ, IP, IR              
          REAL(kind=8), dimension(IR,IR) :: P 
          REAL(kind=8), dimension(IR) :: B, A
          ! Locals
          INTEGER(kind=4) :: I,IPP1,IQP1,IRM1,IM1,J,IMJ,JI,IT,IP1,IP2,IPK,IH,IHP1, &
                           ITPK,IMIK,ITMK,ITP1,IMK,IJK,IJ1
          REAL(kind=8) ::    CST0, CST1, SUM, CKB, CKI
          REAL(kind=8), dimension(IR)   :: WS 
          REAL(kind=8), dimension(IR+1) :: R 
          REAL(kind=8), dimension(IQ*2) :: DB 
#if defined __ICC
!DIR$ ATTRIBUTES ALIGN : 64 :: WS,R,DB
#endif
          DATA CST0,CST1/0.0_8,1.0_8/                                   
#if defined __ICC
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif
          DO 6100 I=1,IQ*2
                 DB(I)=CST0                                                        
6100             CONTINUE
#if defined __ICC             
!DIR$ VECTOR ALIGNED
!DIR$ SIMD VECTORLENGTHFOR(REAL(KIND=8))
#elif defined __GFORTRAN__
!$OMP SIMD LINEAR(I:1)
#endif                 
          DO 6200 I=1,IR
               R(I)=CST0                                                         
     6200 CONTINUE                                                          
!C                                                                       
!C-----  IMPULSE RESPONSE COMPUTATION  -----                             
          WS(1)=CST1                                                        
          IPP1=IP+1                                                         
          IQP1=IQ+1                                                         
          IRM1=IR-1                                                         
          IF(IRM1.LE.0) GO TO 400                                           
          DO 100 I=2,IR                                                     
                 IM1=I-1                                                           
                 IMPR=MIN0(IQ,IM1)                                                 
                 SUM=CST0                                                          
                 IF(IMPR.EQ.0) GO TO 201
!$OMP SIMD REDUCTION(+:SUM)
                 DO 200 J=1,IMPR                                                   
                        IMJ=I-J                                                           
                        SUM=SUM-B(J)*WS(IMJ)                                              
             200 CONTINUE                                                          
             201 IF(I.LE.IPP1) SUM=SUM+A(IM1)                                      
                 WS(I)=SUM                                                         
      100 CONTINUE                                                          
      400 CONTINUE                                                          
!C                                                                       
!C-----  PREPARATION OF CONSTANT VECTOR  -----                           
          IRP1=IR+1                                                         
          R(IRP1)=CST0                                                      
          IF(IRM1.EQ.0) GO TO 7200                                          
          R(IR)=A(IRM1)                                                     
          DO 7010 I=1,IRM1                                                  
                  IM1=I-1                                                           
                  IPMI=IP-IM1                                                       
                  SUM=CST0                                                          
                  IF(IPMI.LE.0) GO TO 7021
!$OMP SIMD REDUCTION(+:SUM)                  
                  DO 7020 J=1,IPMI                                                  
                          JI=IM1+J                                                          
                          SUM=SUM+A(JI)*WS(J+1)                                             
             7020 CONTINUE                                                          
             7021 IF(I.EQ.1) SUM=SUM+CST1                                           
                  IF(I.GT.1) SUM=SUM+A(IM1)                                         
                  R(I)=SUM                                                          
     7010 CONTINUE                                                          
          GO TO 7300                                                        
     7200 CONTINUE                                                          
          R(1)=CST1                                                         
     7300 CONTINUE                                                          
                                                                       
          IF(IQ.EQ.0) GO TO 1600                                            
!C                                                                       
!C-----  TRIANGULARIZATION OF THE COEFFICIENT MATRIX  -----              
          IQP1=IQ+1                                                         
          DO 2100 L=1,IQ                                                    

                  DB(L)=B(L)
     2100 CONTINUE
          IT=IQ                                                             
          I=IQ                                                              
     2200 CONTINUE                                                          
          IP1=I+1                                                           
          IP2=IP1+1                                                         
          IH=IP2/2                                                          
          IHP1=IH+1                                                         
          CKB=DB(IT)                                                        
          CKI=CST1/(CST1-CKB**2)
!$OMP SIMD
          DO 2300 K=1,IH                                                    
                  IPK=IP2-K                                                         
                  R(K)=(R(K)-CKB*R(IPK))*CKI                                        
     2300 CONTINUE                                                          
                                                                       
          IF(I.LE.2) GO TO 2401
!$OMP SIMD                  
          DO 2400 K=IHP1,I                                                  
                  IPK=IP2-K                                                         
                  R(K)=R(K)-CKB*R(IPK)                                              
     2400 CONTINUE                                                          
                                                                       
     2401 IM1=I-1                                                           
                                    
          IF(IM1.EQ.0) GO TO 2600                                           
          DO 2500 K=1,IM1                                                   
                  ITPK=IT+K                                                         
                  IMIK=IT-I+K                                                       
                  ITMK=IT-K                                                         
                  DB(ITPK)=(DB(IMIK)-CKB*DB(ITMK))*CKI                              
      2500 CONTINUE                                                          
                                                                       
           I=IM1                                                             
           IT=IT+I                                                           
           GO TO 2200                                                        
      2600 CONTINUE                                                          
!C                                                                       
!C-----  SOLVING THE LINEAR EQUATION  -----                              
           IF(IQ.LE.1) GO TO 3110                                            
           ITP1=IT+1                                                         
           DO 3100 I=2,IQ                                                    
                   SUM=R(I)                                                          
                   IM1=I-1
!$OMP SIMD REDUCTION(-:SUM)
                   DO 3200 J=1,IM1                                                   
                           ITP1=ITP1-1                                                       
                           SUM=SUM-DB(ITP1)*R(J)                                             
             3200 CONTINUE                                                          
                  R(I)=SUM                                                          
     3100 CONTINUE                                                          
     3110 CONTINUE                                                          
          DO 3300 I=IQP1,IRP1                                               
             SUM=R(I)
!$OMP SIMD REDUCTION(-:SUM)    
                    DO 3400 J=1,IQ                                                    
                            IMJ=I-J                                                           
                            SUM=SUM-DB(J)*R(IMJ)                                              
               3400 CONTINUE                                                          
                    R(I)=SUM                                                          
     3300 CONTINUE                                                          
                                                                       
     1600 CONTINUE                                                          
!C                                                                       
!C-----  P(I,J) COMPUTATION  -----                                       
          DO 9100 I=1,IR                                                    
                  DO 9200 J=1,I                                                     
                          SUM=CST0                                                          
                          IF(J.EQ.1) GO TO 9400
!$OMP SIMD REDUCTION(+:SUM)
                          DO 9300 K=1,J                                                     
                                  IJK=K+I-J                                                         
                                  SUM=SUM+WS(IJK)*WS(K)                                             
                     9300 CONTINUE                                                          
                     9400 CONTINUE                                                          
                          IJ1=I-J+1                                                         
                          P(I,J)=R(IJ1)-SUM                                                 
                          P(J,I)=P(I,J)                                                     
              9200 CONTINUE                                                          
      9100 CONTINUE                                                          
    END SUBROUTINE
    
    SUBROUTINE PRDCTRF(N,P,Q,H,D,K,L,JSW,YY,B,A,WW,S,Y,YORI,YD,X,Z1,     &
                        Z2,Z3,ZZ1,ZZ2,ZZ3) !GCC$ ATTRIBUTES HOT :: PRDCTRF !GCC$ ATTRIBUTES ALIGNED(32) :: PRDCTRF

           use omp_lib
           implicit none

!cc      PROGRAM PRDCTR
!C     PROGRAM 74.3.1.  PREDICTION PROGRAM
!C-----------------------------------------------------------------------
!C     ** DESIGNED BY H. AKAIKE, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C     ** PROGRAMMED BY E. ARAHATA, THE INSTITUTE OF STATISTICAL MATHEMAT
!C         TOKYO
!C     ** DATE OF THE LATEST REVISION: MARCH 25, 1977
!C     ** THIS PROGRAM WAS ORIGINALLY PUBLISHED IN
!C         "TIMSAC-74 A TIME SERIES ANALYSIS AND CONTROL PROGRAM PACKAGE(2
!C         BY H. AKAIKE, E. ARAHATA AND T. OZAKI, COMPUTER SCIENCE MONOGRA
!C         NO.6 MARCH 1976, THE INSTITUTE OF STATISTICAL MATHEMATICS
!C-----------------------------------------------------------------------
!C     THIS PROGRAM OPERATES ON A REAL RECORD OF A VECTOR PROCESS
!C     Y(I) (I=1,N) AND COMPUTES PREDICTED VALUES. ONE STEP AHEAD
!C     PREDICTION STARTS AT TIME P AND ENDS AT TIME Q. PREDICTION IS
!C     CONTINUED WITHOUT NEW OBSERVATIONS UNTIL TIME Q+H.
!C     BASIC MODEL IS THE AUTOREGRESSIVE MOVING AVERAGE
!C     MODEL OF Y(I) WHICH IS GIVEN BY
!C     Y(I)+B(1)Y(I-1)+...+B(K)Y(I-K) = X(I)+A(1)X(I-1)+...+A(L)X(I-L).
!C
!C    THE FOLLOWING INPUTS ARE REQUIRED:
!C     (N,P,Q,H):
!C                  N, LENGTH OF DATA
!C                  P, ONE STEP AHEAD PREDICTION STARTING POSITION
!C                  Q, LONG RANGE FORECAST STARTING POSITION
!C                  H, MAXIMUM SPAN OF FORECAST (LESS THAN OR EQUAL TO 100)
!C                  (Q+H MUST BE LESS THAN 1001)
!C     JSW: JSW=0 FOR DIRECT LOADING OF AR-MA COEFFICIENTS,
!C                  THE OUTPUTS OF PROGRAM MARKOV WITH ICONT=0.
!C            JSW=1 FOR LOADING OF THE OUTPUTS OF PROGRAM MARKOV,
!C                  THE OUTPUTS OF PROGRAM MARKOV WITH ICONT=1.
!C     (D,K,L):
!C              D, DIMENSION OF THE VECTOR Y(I)
!C              K, AR-ORDER (LESS THAN OR EQUAL TO 10)
!C              L, MA-ORDER (LESS THAN OR EQUAL TO 10)
!C     N,L,K,H,P,Q,D,JSW,ARE ALL INTEGERS
!C     (DFORM(I),I=1,20): INPUT FORMAT STATEMENT IN ONE CARD,
!C                             FOR EXAMPLE, (8F10.4)
!C     (NAME(I,J),I=1,20,J=1,D): NAME OF THE I-TH COMPONENT
!C     (Y(I,J),I=1,N;J=1,D): ORIGINAL DATA
!C     (B(I1,I2,J),I1=1,D,I2=1,D,J=1,K): AR-COEFFICIENT MATRICES.
!C     FOR JSW=0,
!C         (A(I1,I2,J),I1=1,D,I2=1,D,J=1,L): MA-COEFFICIENT MATRICES.
!C     FOR JSW=1,
!C         (W(I1,I2,J),I1=1,D,I2=1,D,J=1,L): IMPULSE RESPONSE MATRICES.
!C     (S(I,J),I=1,D,J=1,D): INNOVATION VARIANCE MATRIX
!C
!C     THE OUTPUTS OF THIS PROGRAM ARE THE REAL
!C     AND PREDICTED VALUES OF Y(I).
!C

          INTEGER(kind=4) :: N, P, Q ,H, D, K, L, JSW
          REAL(kind=8), dimension(N,D) :: YY 
          REAL(kind=8, dimension(D,D,K) :: B 
          REAL(kind=8), dimension(D,D,L) :: A, WW
          REAL(kind=8), dimension(D,D)   :: S
          REAL(kind=8), dimension(Q+H,D) :: Y, YD, Z1, Z2, Z3, ZZ1,ZZ2,ZZ3
          REAL(kind=8), dimension(H+1,D) :: YORI
          REAL(kind=8), dimension(N,D)   :: X

           ! Locals
          INTEGER(kind=4) :: H1,ISW,I,J,II,JJ,KK,JX,JY,IX,IM1,JZ,IJ,I2,ISR,IQH
          REAL(kind=8) ::  CST0, CST1, Z, CCC, AN, AVE, DMAX,  DMIN, YYD
              
          REAL(kind=8), dimension(D,D,H+1) ::  W
          REAL(kind=8), dimension(D,D,)    ::  C 
          REAL(kind=8), dimension(D,H+1)   ::  SD 
          REAL(kind=8), dimension(D)       ::  CX, EY, DMXT,DMIT,AV
#if defined __ICC
!DIR$     ATTRIBUTES ALIGN : 64 :: W,C,SD,CX,EY,DMXT,DMIT,AV     
#end

          CHARACTER(len=1), dimension(121) :: XX
          CHARACTER(len=1) :: K1, K2, K3, K4, K5, K6

          DATA XX/121*' '/
          DATA K1,K2,K3,K4,K5,K6 / '*', 'X', '+', 'Y', ' ', '!' /

          CST0=0.0_8
          CST1=1.0_8
          ISW=1
!C
!C      DATA INITIALIZE
!C
          IF (JSW.NE.0) CALL DINIT(A,D*D*L,CST0)
          IF (JSW.EQ.0) CALL DINIT(WW,D*D*L,CST0)
          CALL DINIT(W,D*D*(H+1),CST0)
          CALL DINIT(C,D*D,CST0)
          CALL DINIT(CX,D,CST0)
          CALL DINIT(X,N*D,CST0)
          CALL DINIT(SD,D*(H+1),CST0)
          CALL DINIT(EY,D,CST0)
          CALL DINIT(Y,(Q+H)*D,CST0)
          CALL DINIT(YORI,(H+1)*D,CST0)
          CALL DINIT(DMXT,D,CST0)
          CALL DINIT(DMIT,D,CST0)
          CALL DINIT(AV,D,SCT0)

          DO 71 I = 1,N
                   DO 70 J = 1,D
                           Y(I,J) = YY(I,J)
                70 CONTINUE
       71 CONTINUE

          DO 80 II = 1,D

                DO 79 JJ = 1,D
                       DO 78 KK = 1,L
                            W(II,JJ,KK) = WW(II,JJ,KK)
                    78 CONTINUE
             79 CONTINUE
       80 CONTINUE

          IF  (JSW.EQ.0) GO TO 99

          DO  84 I=1,L
                DO  83 JX=1,D
                     DO  82 JY=1,D

                           A(JX,JY,I)=W(JX,JY,I)+B(JX,JY,I)
                  82 CONTINUE
             83 CONTINUE
        84 CONTINUE
           DO  89 I=2,L
                  IM1=I-1
                  DO  88 IX=1,IM1
                         IY=I-IX
                         DO  87 JX=1,D
                                DO  86 JY=1,D
                                       Z=CST0
!$OMP SIMD REDUCTION(+:Z)
                                       DO  85 JZ=1,D

                                               Z=Z+B(JX,JZ,IX)*W(JZ,JY,IY)
                                    85 CONTINUE

                                       A(JX,JY,I)=A(JX,JY,I)+Z
                             86 CONTINUE
                       87 CONTINUE
               88 CONTINUE
       89 CONTINUE
          DO 8210 I=1,L

                  DO 8221 IX=1,D
                         DO 8220 JX=1,D

                                  C(IX,JX)=A(IX,JX,I)
                    8220 CONTINUE
            8221 CONTINUE

     8210 CONTINUE

          W(1:D,1:D,1:L)=CST0
!C
!C     IMPULSE RESPONSE W(M),M=0,H COMPUTATION
!C     W(0) = UNIT MATRIX
!C     W(M) = A(M)-(B(1)W(M-1)+...+B(K)W(M-K)) (FOR M LESS THAN OR EQUAL
!C     W(M) =-B(1)W(M-1)-...-B(K)W(M-K) (FOR M GREATER THAN L)
       99 DO  101 I=1,D

                  W(I,I,1)=CST1
      101 CONTINUE
          H1=H+1
          DO 120 I=2,H1
               DO  115 J=1,K
                       IJ=I-J

                       IF  (IJ.LE.0) GO TO 115
                       DO  105 JX=1,D
                            DO  104 IX=1,D
                                   Z=CST0
!$OMP SIMD REDUCTION(+:Z)
                                    DO  103 I2=1,D

                                         Z=Z+(B(IX,I2,J)*W(I2,JX,IJ))
                                103 CONTINUE
                                    W(IX,JX,I) = W(IX,JX,I) - Z
                      104 CONTINUE
                    105 CONTINUE
              115 CONTINUE

                  IF  (I-L-1.GT.0) GO TO 120

                  DO  118 JX=1,D
!$OMP SIMD 
                           DO  117 IX=1,D

                                     W(IX,JX,I) = W(IX,JX,I)+A(IX,JX,I-1)
                       117 CONTINUE
              118 CONTINUE
      120 CONTINUE
!C
!C     PREDICTION ERROR VARIANCE C(I) AND STANDARD DEVIATION SD(IX,I)
!C     COMPUTATION (I=1,H1)
!C     C(I)=W(0)*S*W(0)'+...+W(I)*S*W(I)' AND SD(IX,I) IS THE VECTOR OF
!C     THE POSITIVE SQUARE ROOTS OF THE DIAGONAL ELEMENTS OF THE PREDICTI
!C     ERROR VARIANCE MATRIX C(I).  ONLY THE DIAGONAL ELEMENTS OF C(I)
!C     ARE COMPUTED.
          DO 140 I=1,H1
                  DO  125 IX=1,D
                         DO  124 JX=1,D
                                 Z=CST0
!$OMP SIMD REDUCTION(+:Z)
                                 DO 123 I2=1,D

                                        Z=Z+W(IX,I2,I)*S(I2,JX)
                             123 CONTINUE
                                 C(IX,JX)=Z
                     124 CONTINUE
              125 CONTINUE
                  DO  139 IX=1,D
                          Z=CST0
!$OMP SIMD REDUCTION(+:Z)
                          DO  129 I2=1,D

                                  Z=Z+C(IX,I2)*W(IX,I2,I)
                      129 CONTINUE
                          CX(IX)=CX(IX)+Z
                          CCC=CX(IX)

                          IF  (CCC.GT.0) GO TO 131

                          SD(IX,I)=0.0_R64P
                          GO TO 139

                         131 SD(IX,I)=DSQRT(CCC)
                         139 CONTINUE
      140 CONTINUE
!C
!C     SUBTRACTION OF THE MEAN VALUES FROM THE ORIGINAL DATA Y(I)
          AN=N

          AN=1.0_R64P/AN
          DO  146  I=1,D
                   Z=CST0
                   DO  141  J=1,N

                             Z=Z+Y(J,I)
               141 CONTINUE
                   AVE=Z*AN
                   AV(I)=AVE
!$OMP SIMD LINEAR(I:1,J:1)
                   DO  145  J=1,N
                            Y(J,I)=Y(J,I)-AVE
               145 CONTINUE
      146 CONTINUE
!C
!C
!C     PREDICTIONS AND INNOVATIONS (X(I)) COMPUTATION OF Y(I) (I=1,Q+H)
!C     FOR I GREATER THAN OR EQUAL TO Q, X(I) IS SET EQUAL TO 0.
!C
         IQH=Q+H
!$OMP SIMD LINEAR(J:1)
         DO 6300 J=1,D
                DMXT(J)=Y(1,J)

                DMIT(J)=Y(1,J)
     6300 CONTINUE
          ISR=0
          DO 300 I=1,IQH
!C     EY, PREDICTED VALUE OF Y, COMPUTATION
                 DO  153 J=1,D

                       EY(J)=0.0_8
             153 CONTINUE
!C     B(1)Y(I-1)+...+B(K)Y(I-K) COMPUTATION
                 DO  160 J=1,K
                        IJ=I-J

                        IF  (IJ.LE.0) GO TO 160
                        DO  159 IX=1,D
                                Z=CST0
!$OMP SIMD REDUCTION(+:Z)
                                DO  158 I2=1,D

                                        Z=Z+B(IX,I2,J)*Y(IJ,I2)
                            158 CONTINUE
                                EY(IX)=EY(IX)-Z
                   159 CONTINUE
          160 CONTINUE
!C     A(1)X(I-1)+...+A(L)X(I-L) COMPUTATION
              DO  170 J=1,L
                      IJ=I-J

                      IF  (IJ.LE.0) GO TO 170

                      IF  (IJ-Q.GE.0) GO TO 170
                      DO  169 IX=1,D
                               Z=CST0
!$OMP SIMD REDUCTION(+:Z)
                               DO  168 I2=1,D

                                       Z=Z+(A(IX,I2,J)*X(IJ,I2))
                           168 CONTINUE
                               EY(IX)=EY(IX)+Z
                 169 CONTINUE
         170 CONTINUE
!C     MAXIMUM, MINIMUM SEARCH
             DO  249 J=1,D
                     DMAX=DMXT(J)
                     DMIN=DMIT(J)

                     YYD=Y(I,J)
                     CALL MAXMIN(DMAX,DMIN,YYD)
                     YYD=EY(J)
                     CALL MAXMIN(DMAX,DMIN,YYD)
                     DMXT(J)=DMAX
                     DMIT(J)=DMIN
          249 CONTINUE

             IF(I-Q.GE.0) GO TO 200

             DO  172  J=1,D
                      X(I,J)=Y(I,J)-EY(J)
         172 CONTINUE
             GO TO 300
         200 ISR=ISR+1
!$OMP SIMD 
             DO 250 J=1,D
                   YORI(ISR,J)=Y(I,J)+AV(J)
                   Y(I,J)=EY(J)
         250 CONTINUE
      300 CONTINUE

          DO 281 I=1,IQH
                  DO  280 J=1,D

                         Y(I,J)=Y(I,J)+AV(J)
              280 CONTINUE
      281 CONTINUE

          I2=0

          DO 500 II=1,IQH
                 I=II

                 IF  (I-Q.GE.0) GO TO 450

                 IF  (I-P.LT.0) GO TO 500

                 DO  410 J=1,D

                         YD(I,J)=Y(I,J)-X(I,J)

             410 CONTINUE

                 GO TO 500

             450 I2=I2+1
                 DO  480 J=1,D

                         YD(I,J)=Y(I,J)
                         Z1(I,J)=YD(I,J)+SD(J,I2)
                         Z2(I,J)=Z1(I,J)+SD(J,I2)
                         Z3(I,J)=Z2(I,J)+SD(J,I2)

                         ZZ1(I,J)=YD(I,J)-SD(J,I2)
                         ZZ2(I,J)=ZZ1(I,J)-SD(J,I2)
                         ZZ3(I,J)=ZZ2(I,J)-SD(J,I2)

             480 CONTINUE

      500 CONTINUE
   END SUBROUTINE
                        
                        



    SUBROUTINE MAXMIN(DMAX,DMIN,YD) !GCC$ ATTRIBUTES INLINE :: MAXMIN
         implicit none
      REAL(kind=8) :: DMAX, DMIN, YD

      IF(DMAX-YD.GE.0) GO TO 1002
      DMAX=YD

 1002 IF(DMIN-YD.LE.0) GO TO 1004

      DMIN=YD
 1004 RETURN
    END  SUBROUTINE
    

    






                      
                        
                       
                       

  

    


    
    
    

    
 

                      
                                                            
  

    

    
    

    




